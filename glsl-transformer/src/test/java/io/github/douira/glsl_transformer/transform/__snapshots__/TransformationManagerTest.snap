testGlslangErrors[100.frag]=[
// okay
#version 100
int a[3] = { 2, 3, 4, };  // ERROR (lots)
#version 100
int uint;

attribute vec4 v[3];     // ERROR

float f = 2;             // ERROR

uniform block {          // ERROR
    int x;
};

void foo(float);

void main()
{
    foo(3);              // ERROR
    int s = 1 << 4;      // ERROR
    s = 16 >> 2;         // ERROR
    if (a == a);         // ERROR
    int b, c;
    b = c & 4;           // ERROR
    b = c % 4;           // ERROR
    b = c | 4;           // ERROR
    b >>= 2;             // ERROR
    b <<= 2;             // ERROR
    b %= 3;              // ERROR

    struct S {
        float f;
        float a[10];
    } s1, s2;

    s1 = s2;             // ERROR
    if (s1 == s2);       // ERROR
    if (s1 != s2);       // ERROR

    switch(b) {          // ERROR
    }
}

invariant gl_FragColor;
float fa[];              // ERROR
float f13;
invariant f13;           // ERROR
struct S { int a; };
invariant S;             // ERROR, not an input or output
invariant float fi;      // ERROR
varying vec4 av;
invariant av;            // okay in v100

void foo10()
{
    invariant f;         // ERROR
    invariant float f2;  // ERROR
    float f3;
    invariant f3;        // ERROR
}

uniform vec2 uv2;
invariant uv2;              // ERROR
invariant uniform vec3 uv3; // ERROR

sampler2D glob2D;           // ERROR
void f11(sampler2D p2d)
{
    sampler2D v2D;          // ERROR
}
varying sampler2D vary2D;   // ERROR

struct sp {
    highp float f;
    in float g;             // ERROR
    uniform float h;        // ERROR
    invariant float i;      // ERROR
};

uniform sampler3D s3D;      // ERROR

#extension GL_OES_texture_3D : enable

precision highp sampler3D;
uniform sampler3D s3D2;

void foo234()
{
    texture3D(s3D2, vec3(0.2), 0.2);
    texture3DProj(s3D2, v[1], 0.4);
    dFdx(v[0]);    // ERROR
    dFdy(3.2);     // ERROR
    fwidth(f13);   // ERROR
}

#extension GL_OES_standard_derivatives : enable

void foo236()
{
    dFdx(v[0]);
    dFdy(3.2);
    fwidth(f13);
    gl_FragDepth = f13;    // ERROR
    gl_FragDepthEXT = f13; // ERROR
}

#extension GL_EXT_frag_depth : enable

void foo239()
{
    gl_FragDepth = f13;    // ERROR
    gl_FragDepthEXT = f13;
}

#extension GL_OES_EGL_image_external : enable

uniform samplerExternalOES sExt;

void foo245()
{
    texture2D(sExt, vec2(0.2));
    texture2DProj(sExt, vec3(f13));
    texture2DProj(sExt, v[2]);
}

precision mediump samplerExternalOES;
uniform samplerExternalOES mediumExt;
uniform highp samplerExternalOES highExt;

void foo246()
{
    texture2D(mediumExt, vec2(0.2));
    texture2DProj(highExt, v[2]);
    texture3D(sExt, vec3(f13));   // ERROR
    texture2DProjLod(sExt, vec3(f13), f13);  // ERROR
    int a;
    ~a;    // ERROR
    a | a; // ERROR
    a & a; // ERROR
}

#extension GL_OES_EGL_image_external : disable
uniform sampler2D s2Dg;

int foo203940(int a, float b, float a)  // ERROR, a redefined
{
    texture2DProjGradEXT(s2Dg, vec3(f13), uv2, uv2);  // ERROR, extension not enabled
    return a;
}

float f123 = 4.0f;   // ERROR
float f124 = 5e10F;  // ERROR

#extension GL_EXT_shader_texture_lod : enable

uniform samplerCube sCube;

void foo323433()
{
    texture2DLodEXT(s2Dg, uv2, f13);
    texture2DProjGradEXT(s2Dg, vec3(f13), uv2, uv2);
    texture2DGradEXT(s2Dg, uv2, uv2, uv2);
    textureCubeGradEXT(sCube, vec3(f13), vec3(f13), vec3(f13));
}

int fgfg(float f, mediump int i);
int fgfg(float f, highp int i) { return 2; }   // ERROR, precision qualifier difference

int fffg(float f);
int fffg(float f);  // ERROR, can't have multiple prototypes 

int gggf(float f);
int gggf(float f) { return 2; }

int agggf(float f) { return 2; }
int agggf(float f);
int agggf(float f);  // ERROR, second prototype

varying struct SSS { float f; } s; // ERROR

int vf(void);
int vf2();
int vf3(void v);      // ERROR
int vf4(int, void);   // ERROR
int vf5(int, void v); // ERROR

void badswizzle()
{
    vec3 a[5];
    a.y;        // ERROR, no array swizzle
    a.zy;       // ERROR, no array swizzle
    a.nothing;  // ERROR
    a.length(); // ERROR, not this version
    a.method(); // ERROR
}

float fooinit();

float fooinittest()
{
    return fooinit();
}

// Test extension GL_EXT_blend_func_extended
void blendFuncFail() // Error since extension GL_EXT_blend_func_extended is disabled
{
    gl_SecondaryFragColorEXT = vec4(1.0);   
    gl_SecondaryFragDataEXT[gl_MaxDualSourceDrawBuffersEXT - 1] = vec4(0.1);
}
#extension GL_EXT_blend_func_extended : enable
void blendFunc() 
{
    gl_SecondaryFragColorEXT = vec4(1.0);
    gl_SecondaryFragDataEXT[gl_MaxDualSourceDrawBuffersEXT - 1] = vec4(0.1);
}

// Test extra-function initializers
const float fi1 = 3.0;
const float fi2 = 4.0;
const float fi3 = 5.0;

float fooinit()
{
    return fi1 + fi2 + fi3;  // should make a constant of 12.0
}

int init1 = gl_FrontFacing ? 1 : 2; // ERROR, non-const initializer

#ifdef GL_EXT_shader_non_constant_global_initializers
#extension GL_EXT_shader_non_constant_global_initializers : enable
#endif

int init2 = gl_FrontFacing ? 1 : 2;

#define A__B // error
int a__b;    // error

#pragma STDGL invariant(all)

#line 3000
#error line of this error should be 3000

uniform samplerExternalOES badExt;  // syntax ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>
4:1; [@31,67:73='version',<'version'>,4:1]; no viable alternative at input '#version'; NoViableAltException:null
117:8; [@733,2380:2397='samplerExternalOES',<'samplerExternalOES'>,117:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
126:18; [@793,2551:2568='samplerExternalOES',<'samplerExternalOES'>,126:18]; mismatched input 'samplerExternalOES' expecting {'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', IDENTIFIER}; InputMismatchException:null
127:8; [@798,2580:2597='samplerExternalOES',<'samplerExternalOES'>,127:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
128:14; [@807,2625:2642='samplerExternalOES',<'samplerExternalOES'>,128:14]; no viable alternative at input 'uniform highp samplerExternalOES'; NoViableAltException:null
243:8; [@1631,5432:5449='samplerExternalOES',<'samplerExternalOES'>,243:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
]


testGlslangErrors[100Limits.vert]=[
#version 100

int ga, gb;
float f;

uniform sampler2D fsa[3];
uniform float fua[10];
attribute mat3 am3;
attribute vec2 av2;
varying vec4 va[4];

const mat2 m2 = mat2(1.0);
const vec3 v3 = vec3(2.0);

void foo(inout float a) {}

int bar()
{
    return 1;
}

void main()
{
    while (ga < gb) { }

    do { } while (false);

    for (           ;              ;         );           // ERROR
    for (           ;        ga==gb;         );           // ERROR
    for (           ;              ;      f++);           // ERROR
    for (     ga = 0;              ;         );           // ERROR
    for ( bool a = false;          ;         );           // ERROR
    for (float a = 0.0; a == sin(f);         );           // ERROR
    for (  int a = 0;       a  < 10;   a *= 2);           // ERROR
    for (  int a = 0;       a <= 20;      a++)  --a;      // ERROR
    for (  int a = 0;       a <= 20;      a++)  { if (ga==0) a = 4; } // ERROR
    for (float a = 0.0;   a <= 20.0; a += 2.0);
    for (float a = 0.0;   a != 20.0; a -= 2.0)  { if (ga==0) ga = 4; }
    for (float a = 0.0;   a == 20.0;      a--) for (float a = 0.0;   a == 20.0;      a--);  // two different 'a's, everything okay
    for (float a = 0.0;   a <= 20.0; a += 2.0);
    for (float a = 0.0;   a <= 20.0; a += 2.0);
    for (float a = 0.0;   a > 2.0 * 20.0; a += v3.y);
    for (float a = 0.0;   a >= 20.0; a += 2.0) foo(a);    // ERROR

    int ia[9];

    fsa[ga];  // ERROR
    fua[ga];
    am3[ga];  // ERROR
    av2[ga];  // ERROR
    va[2+ga]; // ERROR
    m2[ga];   // ERROR
    v3[ga/2]; // ERROR
    ia[ga];   // ERROR

    for (int a = 3; a >= 0; a--) {
        fsa[a];
        fua[a+2];
        am3[3*a];
        av2[3*a];
        va[a-1];
        m2[a/2];
        v3[a];
        ia[a];
        ia[bar()];  // ERROR
    }

    fsa[2];
    fua[3];
    am3[2];
    av2[1];
    va[1];
    m2[1];
    v3[1];
    ia[3];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[100samplerExternal.frag]=[
#version 100

#extension GL_OES_EGL_image_external : enable

uniform samplerExternalOES sExt;
precision mediump samplerExternalOES;
uniform samplerExternalOES mediumExt;
uniform highp samplerExternalOES highExt;

void main()
{
    texture2D(sExt, vec2(0.2));
    texture2D(mediumExt, vec2(0.2));
    texture2D(highExt, vec2(0.2));
    texture2DProj(sExt, vec3(0.3));
    texture2DProj(sExt, vec4(0.3));

    int lod = 0;
    highp float bias = 0.01;
    textureSize(sExt, lod);  // ERROR
    texture(sExt, vec2(0.2));  // ERROR
    texture(sExt, vec2(0.2), bias);  // ERROR
    textureProj(sExt, vec3(0.2));  // ERROR
    textureProj(sExt, vec3(0.2), bias);  // ERROR
    textureProj(sExt, vec4(0.2));  // ERROR
    textureProj(sExt, vec4(0.2), bias);  // ERROR
    texelFetch(sExt, ivec2(4), lod);  // ERROR

    texture3D(sExt, vec3(0.3));  // ERROR
    texture2DProjLod(sExt, vec3(0.3), 0.3);  // ERROR
    texture(sExt, vec3(0.3));  // ERROR
    textureProjLod(sExt, vec3(0.3), 0.3);  // ERROR
}

#extension GL_OES_EGL_image_external : disable

#extension GL_OES_EGL_image_external_essl3 : enable
uniform samplerExternalOES badExt;  // ERROR
#extension GL_OES_EGL_image_external_essl3 : disable

uniform samplerExternalOES badExt;  // ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>
5:8; [@18,73:90='samplerExternalOES',<'samplerExternalOES'>,5:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
6:18; [@27,117:134='samplerExternalOES',<'samplerExternalOES'>,6:18]; mismatched input 'samplerExternalOES' expecting {'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', IDENTIFIER}; InputMismatchException:null
7:8; [@32,146:163='samplerExternalOES',<'samplerExternalOES'>,7:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
8:14; [@41,191:208='samplerExternalOES',<'samplerExternalOES'>,8:14]; no viable alternative at input 'uniform highp samplerExternalOES'; NoViableAltException:null
38:8; [@351,1146:1163='samplerExternalOES',<'samplerExternalOES'>,38:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
41:8; [@369,1248:1265='samplerExternalOES',<'samplerExternalOES'>,41:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
]


testGlslangErrors[100scope.vert]=[
#version 100

int f(int a, int b, int c)
{
	int a = b;

    {
		float a = float(a) + 1.0;
    }

	return a;
}

int f(int a, int b, int c);  // okay to redeclare

bool b;
float b(int a);      // ERROR: redefinition

float c(int a);
bool c;              // ERROR: redefinition

float f;             // ERROR: redefinition
float tan;           // okay, built-in is in an outer scope
float sin(float x);  // ERROR: can't redefine built-in functions
float cos(float x)   // ERROR: can't redefine built-in functions
{
	return 1.0;
}
bool radians(bool x) // okay, can overload built-in functions
{
    return true;
}

invariant gl_Position;

void main()
{
    int g();    // ERROR: no local function declarations
	g();

    float sin;  // okay
	sin;
    sin(0.7);  // ERROR, use of hidden function
    f(1,2,3);

    float f;    // hides f()
    f = 3.0;

    gl_Position = vec4(f);

    for (int f = 0; f < 10; ++f)
        ++f;

    int x = 1;
    { 
        float x = 2.0, /* 2nd x visible here */ y = x; // y is initialized to 2
        int z = z; // ERROR: z not previously defined.
    }
    {
        int x = x; // x is initialized to '1'
    }

    struct S 
    { 
        int x; 
    };
    {
        S S = S(0); // 'S' is only visible as a struct and constructor 
        S.x;        // 'S' is now visible as a variable
    }

    int degrees;
    degrees(3.2);  // ERROR, use of hidden built-in function
}

varying struct SSS { float f; } s; // ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[110scope.vert]=[
#version 110

int f(int a, int b, int c)
{
	int a = b;  // ERROR, redefinition

    {
		float a = float(a) + 1.0; // okay
    }

	return a;
}

int f(int a, int b, int c);  // okay to redeclare

bool b;
float b(int a);      // okay, b and b() are different

float c(int a);
bool c;              // okay, and c() are different

float f;             // okay f and f() are different
float tan;           // okay, hides built-in function
float sin(float x);  // okay, can redefine built-in functions
float cos(float x)   // okay, can redefine built-in functions
{
	return 1.0;
}
bool radians(bool x) // okay, can overload built-in functions
{
    return true;
}

int gi = f(1,2,3);  // ERROR, can't call user-defined function from global scope

void main()
{
    int g();    // okay
    g();

    float sin; // okay
    sin;
    sin(0.7);  // okay
    f(1,2,3);

    float f;
    f = 3.0;

    gl_Position = vec4(f);

    for (int f = 0; f < 10; ++f)
        ++f;

    int x = 1;
    { 
        float x = 2.0, /* 2nd x visible here */ y = x; // y is initialized to 2
        int z = z; // ERROR: z not previously defined.
    }
    {
        int x = x; // x is initialized to '1'
    }

    struct S 
    { 
        int x; 
    };
    {
        S S = S(0); // 'S' is only visible as a struct and constructor 
        S.x;        // 'S' is now visible as a variable
    }

    int degrees;
    degrees(3.2);

    {
        S s;
        s.x = 3;
        struct S {   // okay, hides S
            bool b;
        };
        S t;
        t.b = true;
        struct S {    // ERROR, redefinition of struct S
            float f;
        };
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[120.frag]=[
#version 120

float lowp;
float mediump;
float highp;

float precision;

in vec4 i;
out vec4 o;

uniform sampler2D s2D;
centroid varying vec2 centTexCoord;

uniform mat4x2 m;

struct s {
    float f;
};

void main()
{
    mat2x3 m23 = mat2x3(m);

    int a;
    bool b;
    s sv = s(a);
    float[2] ia = float[2](3, i.y);
    float f1 = 1;
    float f = a;
    f = a;
    ivec3 iv3;
    vec3 v3 = iv3;
    f = f + a;
    f = a - f;
    f += a;
    f = a - f;
    v3 *= iv3;
    v3 = iv3 / 2.0f;
    v3 = 3.0 * iv3;
    v3 = 2 * v3;
    v3 = v3 - 2;
    if (f <  a ||
        a <= f ||
        f >  a ||
        f >= a ||
        a == f ||
        f != a);
    f = b ? a : f;
    f = b ? f : a;
    f = b ? a : a;
    s news = sv;
    
    i.xy + i.xyz;      // ERROR
    m * i.xyz;         // ERROR
    m + i;             // ERROR
    int aoeu = 1.0;    // ERROR
    f = b;             // ERROR
    f = a + b;         // ERROR
    f = b * a;         // ERROR
    b = a;             // ERROR
    b = b + f;         // ERROR
    f |= b;            // ERROR

    gl_FragColor = texture2D(s2D, centTexCoord);

    float flat;
    float smooth;
    float noperspective;
    float uvec2;
    float uvec3;
    float uvec4;
    //packed;     // ERROR, reserved word

    {
        mat4 m;
        vec4 v;
        bool b;
        gl_FragColor += b ? v : m;  // ERROR, types don't match around ":"
    }

    gl_FragColor.xr;    // ERROR, swizzlers not from same field space
    gl_FragColor.xyxyx.xy; // ERROR, cannot make a vec5, even temporarily
    centTexCoord.z;     // ERROR, swizzler out of range
    (a,b) = true;       // ERROR, not an l-value
}

float imageBuffer;
float uimage2DRect;

int main() {}           // ERROR
void main(int a) {}     // ERROR

const int a;            // ERROR

int foo(in float a);
int foo(out float a)    // ERROR
{
    return 3.2;         // ERROR
    foo(a);             // ERROR
}

bool gen(vec3 v)
{
    if (abs(v[0]) < 1e-4F && abs(v[1]) < 1e-4)
        return true;
}

void v1()
{
}

void v2()
{
    return v1();  // ERROR, no expression allowed, even though void
}

void atest()
{
    vec4 v = gl_TexCoord[1];
    v += gl_TexCoord[3];
}

varying vec4 gl_TexCoord[6];  // okay, assigning a size
varying vec4 gl_TexCoord[5];  // ERROR, changing size

mat2x2 m22;
mat2x3 m23;
mat2x4 m24;

mat3x2 m32;
mat3x3 m33;
mat3x4 m34;

mat4x2 m42;
mat4x3 m43;
mat4x4 m44;

void foo123()
{
    mat2 r2 = matrixCompMult(m22, m22);
    mat3 r3 = matrixCompMult(m33, m33);
    mat4 r4 = matrixCompMult(m44, m44);

    mat2x3 r23 = matrixCompMult(m23, m23);
    mat2x4 r24 = matrixCompMult(m24, m24);
    mat3x2 r32 = matrixCompMult(m32, m32);
    mat3x4 r34 = matrixCompMult(m34, m34);
    mat4x2 r42 = matrixCompMult(m42, m42);
    mat4x3 r43 = matrixCompMult(m43, m43);

    mat3x2 rfoo1 = matrixCompMult(m23, m32);  // ERROR
    mat3x4 rfoo2 = matrixCompMult(m34, m44);  // ERROR    
}

void matConst()
{
    vec2 v2;
    vec3 v3;
    mat4 m4b1 = mat4(v2, v3);                      // ERROR, not enough
    mat4 m4b2 = mat4(v2, v3, v3, v3, v3, v2, v2);  // ERROR, too much
    mat4 m4g = mat4(v2, v3, v3, v3, v3, v3);
    mat4 m4 = mat4(v2, v3, v3, v3, v3, v2);
    mat3 m3 = mat3(m4);
    mat3 m3b1 = mat3(m4, v2);                      // ERROR, extra arg
    mat3 m3b2 = mat3(m4, m4);                      // ERROR, extra arg
    mat3x2 m32 = mat3x2(m4);
    mat4 m4c = mat4(m32);
    mat3 m3s = mat3(v2.x);

    mat3 m3a1[2] = mat3[2](m3s, m3s);
    mat3 m3a2[2] = mat3[2](m3s, m3s, m3s);         // ERROR, too many args
}

uniform sampler3D s3D;
uniform sampler1D s1D;
uniform sampler2DShadow s2DS;

void foo2323()
{
    vec4 v;
    vec2 v2;
    float f;
    v = texture2DLod(s2D, v2, f);    // ERROR
    v = texture3DProjLod(s3D, v, f); // ERROR
    v = texture1DProjLod(s1D, v, f); // ERROR
    v = shadow2DProjLod(s2DS, v, f); // ERROR

    v = texture1DGradARB(s1D, f, f, f);         // ERROR
    v = texture2DProjGradARB(s2D, v, v2, v2);   // ERROR
    v = shadow2DProjGradARB(s2DS, v, v2, v2);   // ERROR
}

#extension GL_ARB_shader_texture_lod : require

void foo2324()
{
    vec4 v;
    vec2 v2;
    float f;
    v = texture2DLod(s2D, v2, f);
    v = texture3DProjLod(s3D, v, f);
    v = texture1DProjLod(s1D, v, f);
    v = shadow2DProjLod(s2DS, v, f);

    v = texture1DGradARB(s1D, f, f, f);
    v = texture2DProjGradARB(s2D, v, v2, v2);
    v = shadow2DProjGradARB(s2DS, v, v2, v2);
    v = shadow2DRectProjGradARB(s2DS, v, v2, v2);  // ERROR
}

uniform sampler2DRect s2DRbad;  // ERROR

void foo121111()
{
    vec2 v2;
    vec4 v = texture2DRect(s2DRbad, v2);
}

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect s2DR;
uniform sampler2DRectShadow s2DRS;

void foo12111()
{
    vec2 v2;
    vec3 v3;
    vec4 v4;
    vec4 v;
    v = texture2DRect(s2DR, v2);
    v = texture2DRectProj(s2DR, v3);
    v = texture2DRectProj(s2DR, v4);
    v = shadow2DRect(s2DRS, v3);
    v = shadow2DRectProj(s2DRS, v4);

    v = shadow2DRectProjGradARB(s2DRS, v, v2, v2);
}

void voidTernary()
{
	bool b;
	b ? foo121111() : foo12111();
	b ? foo121111() : 4;  // ERROR
	b ? 3 : foo12111();   // ERROR
}

float halfFloat1 = 1.0h;   // syntax ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>
3:6; [@8,20:23='lowp',<'lowp'>,3:6]; no viable alternative at input 'float lowp'; NoViableAltException:null
4:6; [@13,32:38='mediump',<'mediump'>,4:6]; no viable alternative at input 'float mediump'; NoViableAltException:null
5:6; [@18,47:51='highp',<'highp'>,5:6]; no viable alternative at input 'float highp'; NoViableAltException:null
7:6; [@24,61:69='precision',<'precision'>,7:6]; no viable alternative at input 'float precision'; NoViableAltException:null
7:15; [@25,70:70=';',<';'>,7:15]; mismatched input ';' expecting {'highp', 'mediump', 'lowp'}; InputMismatchException:null
67:10; [@545,1117:1120='flat',<'flat'>,67:10]; no viable alternative at input 'float flat'; NoViableAltException:null
68:10; [@551,1133:1138='smooth',<'smooth'>,68:10]; no viable alternative at input 'float smooth'; NoViableAltException:null
69:10; [@557,1151:1163='noperspective',<'noperspective'>,69:10]; no viable alternative at input 'float noperspective'; NoViableAltException:null
70:10; [@563,1176:1180='uvec2',<UI32VEC2>,70:10]; no viable alternative at input 'float uvec2'; NoViableAltException:null
71:10; [@569,1193:1197='uvec3',<UI32VEC3>,71:10]; no viable alternative at input 'float uvec3'; NoViableAltException:null
72:10; [@575,1210:1214='uvec4',<UI32VEC4>,72:10]; no viable alternative at input 'float uvec4'; NoViableAltException:null
88:6; [@664,1654:1664='imageBuffer',<'imageBuffer'>,88:6]; no viable alternative at input 'float imageBuffer'; NoViableAltException:null
89:6; [@669,1673:1684='uimage2DRect',<'uimage2DRect'>,89:6]; no viable alternative at input 'float uimage2DRect'; NoViableAltException:null
248:22; [@2033,5163:5163='h',<IDENTIFIER>,248:22]; extraneous input 'h' expecting ';'; <no exception>
]


testGlslangErrors[120.vert]=[
#version 120

in vec4 i;                // ERROR
out vec4 o;               // ERROR

attribute vec2 attv2;
attribute vec4 attv4;
uniform sampler2D s2D;
invariant varying vec2 centTexCoord;
invariant gl_Position;
centroid gl_Position;     // ERROR
centroid centroid foo;    // ERROR
invariant gl_Position, gl_PointSize;

void main()
{
    centTexCoord = attv2; 
    gl_Position = attv4;

    gl_ClipVertex = attv4;
    gl_ClipDistance[1] = 0.2;  // ERROR

    vec3[12] a;
    vec4[a.length()] b;
    gl_Position = b[b.length()-1];

    float f[];
    int a1 = f.length();  // ERROR
    float f[7];
    int aa = f.length();
    int a2 = f.length;    // ERROR
    int a3 = f.length(a); // ERROR
    int a4 = f.flizbit;   // ERROR
    int a4 = f.flizbit(); // ERROR
    float md[2][4];       // ERROR
    float[2] md2[4];      // ERROR
    float[2][4] md3;      // ERROR
    float md5, md6[2][3]; // ERROR
    float[2] md4, md7[4]; // ERROR
    float md9[2][3] = float[2][3](1, 2, 3, 4, 5, 6);  // ERROR
    float md10, md11[2][3] = float[2][3](1, 2, 3, 4, 5, 6);  // ERROR

    gl_PointSize = 3.8;
}

uniform float initted = 3.4;   // okay

const float concall = sin(0.3);

int[2][3] foo(                 // ERROR
              float[2][3] a,   // ERROR
              float[2] b[3],   // ERROR
              float c[2][3]);  // ERROR

int overloadA(in float f);
int overloadA(out float f);        // ERROR, different qualifiers
float overloadA(float);            // ERROR, different return value for same signature
float overloadA(out float f, int);
float overloadA(int i);

void overloadB(float, const in float) { }

vec2 overloadC(int, int);
vec2 overloadC(const in int, float);
vec2 overloadC(float, int);
vec2 overloadC(vec2, vec2);

vec3 overloadD(int, float);
vec3 overloadD(float, in int);

vec3 overloadE(float[2]);
vec3 overloadE(mat2 m);
vec3 overloadE(vec2 v);

vec3 overloadF(int);
vec3 overloadF(float);

void foo()
{
    float f;
    int i;

    overloadB(f, f);
    overloadB(f, 2);
    overloadB(1, i);

    overloadC(1);    // ERROR
    overloadC(1, i);
    overloadC(vec2(1), vec2(2));
    overloadC(f, 3.0);           // ERROR, no way
    overloadC(ivec2(1), vec2(2));

    overloadD(i, f);
    overloadD(f, i);
    overloadD(i, i);   // ERROR, ambiguous

    int overloadB;     // hiding
    overloadB(1, i);   // ERROR

    sin(1);
    texture2D(s2D, ivec2(0));
    clamp(attv4, 0, 1);
    clamp(ivec4(attv4), 0, 1);

    int a[2];
    overloadC(a, 3); // ERROR
    overloadE(a);    // ERROR
    overloadE(3.3);  // ERROR
    overloadE(vec2(3.3));
    overloadE(mat2(0.5));
    overloadE(ivec4(1)); // ERROR
    overloadE(ivec2(1));

    float b[2];
    overloadE(b);
    
    overloadF(1, 1); // ERROR
    overloadF(1);
}

varying vec4 gl_TexCoord[35]; // ERROR, size too big

// tests for output conversions
void outFun(in float, out ivec2, in int, out float);
int outFunRet(in float, out int, const in int, out ivec4);
ivec2 outFunRet(in float, out ivec4, in int, out ivec4);

void foo2()
{
    vec2 v2;
    vec4 v4;
    float f;
    int i;

    outFun(i, v2, i, f);
    outFunRet(i, f, i, v4);
    float ret = outFunRet(i, f, i, v4);
    vec2 ret2 = outFunRet(i, v4, i, v4);
    bool b = any(lessThan(v4, attv4));  // tests aggregate arg to unary built-in 
}

void noise()
{
    float f1 = noise1(1.0);
    vec2 f2 = noise2(vec2(1.0));
    vec3 f3 = noise3(vec3(1.0));
    vec4 f4 = noise4(vec4(1.0));
}

// version 130 features

uniform int c;

attribute ivec2 x;
attribute vec2 v2a;
attribute float c1D;
attribute vec2  c2D;
attribute vec3  c3D;

uniform vec4 v4;

void foo213()
{
    float f = 3;
    switch (c) {         // ERRORs...
    case 1:              
        f = sin(f);
        break;
    case 2:
        f = f * f;
    default:
        f = 3.0;
    }

    int i;          
    i << 3 | 0x8A >> 1 & 0xFF;      // ERRORs...

    vec3 modfOut, modfIn;
    vec3 v11 = modf(modfIn, modfOut); // ERRORS...
    float t = trunc(f);
    vec2 v12 = round(v2a);
    vec2 v13 = roundEven(v2a);
    bvec2 b10 = isnan(v2a);
    bvec4 b11 = isinf(v4);

    sinh(c1D) +                      // ERRORS...
    cosh(c1D) * tanh(c2D);
    asinh(c4D) + acosh(c4D);
    atanh(c3D);

    int id = gl_VertexID;            // ERROR
    gl_ClipDistance[1] = 0.3;        // ERROR
}

int gl_ModelViewMatrix[] = 0;

// token pasting (ERRORS...)

#define mac abc##def
int mac;

#define macr(A,B) A ## B
int macr(qrs,tuv);

layout(std140) uniform BlockName    // ERROR
{
    int test;
};

#extension GL_ARB_uniform_buffer_object : enable

layout(std140) uniform BlockName
{
    int test;
};
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[130.frag]=[
#version 130

lowp vec3 a;
mediump float b;
highp int c;

precision highp float;

in vec4 i;
out vec4 o;

flat in float fflat;
smooth in float fsmooth;
noperspective in float fnop;

void main()
{
    float clip = gl_ClipDistance[3];
}

uniform samplerCube sampC;

void foo()
{
    vec4 s = textureGather(sampC, vec3(0.2));
}

#extension GL_ARB_texture_gather : enable

void bar()
{
    vec4 s = textureGather(sampC, vec3(0.2));
}

flat in vec3 gl_Color;     // ERROR, type
in vec4 gl_Color;
flat in vec4 gl_Color;
flat in vec4 gl_Color[2];  // ERROR, array 
vec4 gl_Color;             // ERROR, storage

#extension GL_ARB_texture_gather : warn

void bar2()
{
    vec4 s = textureGather(sampC, vec3(0.2));

    uvec3 uv3;
    bvec3 b3;
    b3 = lessThan(uv3, uv3);
    b3 = equal(uv3, uv3);
    const bvec2 bl1 = greaterThanEqual(uvec2(2, 3), uvec2(3,3));
    const bvec2 bl2 = equal(uvec2(2, 3), uvec2(3,3));
    const bvec2 bl3 = equal(bl1, bl2);  // yes, equal
    int a1[int(bl3.x)];
    int a2[int(bl3.y)];
    a1[0];  // size 1
    a2[0];  // size 1
    const bvec4 bl4 = notEqual(greaterThan(uvec4(1,2,3,4), uvec4(0,2,0,6)), lessThanEqual(uvec4(7,8,9,10), uvec4(6, 8, 0, 11)));  // compare (t,f,t,f) with (f,t,f,t)
    int a3[int(bl4.x)+int(bl4.y)+int(bl4.z)+int(bl4.w)];
    a3[3];  // size 4
    b3 != b3;
    b3 < b3;                   // ERROR
    uv3 > uv3;                 // ERROR
    uvec2(2, 3) >= uvec2(3,3); // ERROR
    int samples = gl_NumSamples; // ERROR
    int(bl4) <= int(bl4);      // true
    int(bl4.x) > int(bl4.y);   // false
}

#extension GL_ARB_texture_gather : enable
#extension GL_ARB_texture_rectangle : enable
#extension GL_ARB_sample_shading : enable

uniform sampler2D samp2D;
uniform sampler2DShadow samp2DS;
uniform sampler2DRect samp2DR;
uniform sampler2DArray samp2DA;

void bar23()
{
    vec4 s;
    s = textureGatherOffset(sampC, vec3(0.3), ivec2(1));        // ERROR
    s = textureGatherOffset(samp2DR, vec2(0.3), ivec2(1));      // ERROR
    s = textureGatherOffset(samp2D, vec2(0.3), ivec2(1));
    s = textureGatherOffset(samp2DA, vec3(0.3), ivec2(1));
    s = textureGatherOffset(samp2DS, vec2(0.3), 1.3, ivec2(1)); // ERROR
    s = textureGatherOffset(samp2D, vec2(0.3), ivec2(1), 2);    // ERROR
    int samples = gl_NumSamples;
}

#extension GL_ARB_gpu_shader5 : enable

void bar234()
{
    vec4 s;
    s = textureGatherOffset(samp2D, vec2(0.3), ivec2(1));
    s = textureGatherOffset(samp2DA, vec3(0.3), ivec2(1));
    s = textureGatherOffset(samp2DR, vec2(0.3), ivec2(1));
    s = textureGatherOffset(samp2DS, vec2(0.3), 1.3, ivec2(1));
    s = textureGatherOffset(samp2D, vec2(0.3), ivec2(1), 2);
}

#extension GL_ARB_texture_cube_map_array : enable

uniform  samplerCubeArray Sca;
uniform isamplerCubeArray Isca;
uniform usamplerCubeArray Usca;
uniform samplerCubeArrayShadow Scas;

void bar235()
{
    ivec3 a = textureSize(Sca, 3);
    vec4 b = texture(Sca, i);
    ivec4 c = texture(Isca, i, 0.7);
    uvec4 d = texture(Usca, i);
    
    b = textureLod(Sca, i, 1.7);
    a = textureSize(Scas, a.x);
    float f = texture(Scas, i, b.y);
    c = textureGrad(Isca, i, vec3(0.1), vec3(0.2));
}

int \
    x;  // ERROR until 420pack is turned on

#extension GL_ARB_shading_language_420pack : enable

const int ai[3] = { 10, 23, 32 };
layout(binding=0) uniform blockname { int a; } instanceName;  // ERROR
uniform layout(binding=0) sampler2D bounds;

void bar23444()
{
    mat4x3 m43;  \
    float a1 = m43[3].y;
    vec3 v3;
    int a2 = m43.length();
    a2 += m43[1].length();
    a2 += v3.length();
    const float b = 2 * a1;
    a.x = gl_MinProgramTexelOffset + gl_MaxProgramTexelOffset;
    bool boolb;
    boolb.length();     // ERROR
    m43[3][1].length(); // ERROR
    v3.length;          // ERROR
    v3.length(b);       // ERROR
}

in float gl_FogFragCoord;

#extension GL_ARB_separate_shader_objects : enable

in float gl_FogFragCoord;
in int gl_FogFragCoord;    // ERROR

layout(early_fragment_tests) in;         // ERROR
layout(r32i) uniform iimage2D iimg2Dbad; // ERROR

#extension GL_ARB_shader_image_load_store : enable

layout(early_fragment_tests) in;

layout(r32i) uniform iimage2D iimg2D;

void qux2()
{
    int i;
    imageAtomicCompSwap(iimg2D, ivec2(i,i), i, i);
    ivec4 pos = imageLoad(iimg2D, ivec2(i,i));
}

layout(early_fragment_tests) out;         // ERROR

#extension GL_ARB_explicit_uniform_location : enable

layout(location = 3) uniform vec4 ucolor0; // ERROR: explicit attrib location is also required for version < 330

#extension GL_ARB_explicit_attrib_location : enable

layout(location = 4) uniform vec4 ucolor1;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[130.vert]=[
#version 130

uniform int c;
uniform usampler2D us2D;

in ivec2 x;
in vec2 v2a;
in float c1D;
in vec2  c2D;
in vec3  c3D;
smooth vec4  c4D;  // ??

uniform vec4 v4;

void main()
{
    float f = 3;
    switch (c) {     // full switch testing in switch.frag
    case 1:
        f = sin(f);
        break;
    case 2:
        f = f * f;
    default:
        f = 3.0;
    }

    uint i;
    i = texture(us2D, x).w;          // full uint testing in uint.frag
    i << 3u | 0x8Au >> 1u & 0xFFu;

    vec3 modfOut, modfIn;
    vec3 v11 = modf(modfIn, modfOut);
    float t = trunc(f);
    vec2 v12 = round(v2a);
    vec2 v13 = roundEven(v2a);
    bvec2 b10 = isnan(v2a);
    bvec4 b11 = isinf(v4);

    sinh(c1D) +
    cosh(c1D) * tanh(c2D);
    asinh(c4D) + acosh(c4D);
    atanh(c3D);

    int id = gl_VertexID;
    gl_ClipDistance[1] = 0.3;
}

// version 140 features

//uniform isamplerBuffer sbuf;

//layout(std140) uniform blockName {
//    int anonMem;
//};

void foo88()
{
    int id = gl_InstanceID;    // ERROR
    //id += anonMem;
    id += texelFetch(id, 8);

    gl_ClipVertex;         // these are all present...
    gl_Color;
    gl_LightSource[0];
    gl_DepthRange.far;
    gl_TexCoord;
    gl_FogFragCoord;
    gl_FrontColor;
}

// token pasting

#define mac abc##def
int mac;

#define macr(A,B) A##B
int macr(qrs,tuv);

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[140.frag]=[
#version 140

varying vec4 v;

in vec4 i;
out vec4 o;

in float gl_ClipDistance[5];

void main()
{
    float clip = gl_ClipDistance[2];
}
#ifdef GL_ES
#error GL_ES is set
#else
#error GL_ES is not set
#endif
.
.
in struct S { float f; } s; // ERROR

float patch = 3.1;

layout(location=3) in vec4 vl;  // ERROR

layout(location = 3) out vec4 factorBad;  // ERROR

#extension GL_ARB_explicit_attrib_location : enable

layout(location = 5) out vec4 factor;

#extension GL_ARB_separate_shader_objects : enable

layout(location=4) in vec4 vl2;

float fooi();

void foo()
{
    vec2 r1 = modf(v.xy, v.zw);  // ERROR, v.zw not l-value
    vec2 r2 = modf(o.xy, o.zw);
    o.z = fooi();
}

// Test extra-function initializers

float i1 = gl_FrontFacing ? -2.0 : 2.0;
float i2 = 102;

float fooi()
{
    return i1 + i2;
}

uniform sampler2DMS aaa1; // ERROR

#extension GL_ARB_texture_multisample : enable

uniform sampler2DMS aaa2;

<><><><><><><><><><><><><><><><><><><><><><><><><>
23:6; [@100,254:258='patch',<'patch'>,23:6]; no viable alternative at input 'float patch'; NoViableAltException:null
]


testGlslangErrors[140.vert]=[
#version 140

uniform isamplerBuffer sbuf;

layout(std140) uniform blockName {
    int anonMem;
};

void main()
{
    int id = gl_InstanceID;
    id += anonMem;
    id += texelFetch(sbuf, 8).w;
    gl_ClipVertex;      // could be ERROR, but compiling under compatibility profile
    gl_Color;           // could be ERROR, but compiling under compatibility profile
    gl_LightSource[0];  // could be ERROR, but compiling under compatibility profile
    gl_DepthRange.far;
    gl_TexCoord;        // could be ERROR, but compiling under compatibility profile
    gl_FogFragCoord;    // could be ERROR, but compiling under compatibility profile
    gl_FrontColor;      // could be ERROR, but compiling under compatibility profile
}

out vec4 gl_Position;  // ERROR

layout(location = 9) in vec4 locBad;  // ERROR

#extension GL_ARB_explicit_attrib_location : enable

layout(location = 9) in vec4 loc;

#extension GL_ARB_separate_shader_objects : enable

out vec4 gl_Position;
in vec4 gl_Position;   // ERROR
out vec3 gl_Position;  // ERROR

out float gl_PointSize;
out vec4 gl_ClipVertex;
out float gl_FogFragCoord;

uniform sampler2DRect s2dr;
uniform sampler2DRectShadow s2drs;
in ivec2 itloc2;
in vec2 tloc2;
in vec3 tloc3;
in vec4 tloc4;

void foo()
{
    vec4 v = texelFetch(s2dr, itloc2);
    v += texelFetch(s2dr, itloc2, 0.2);     // ERROR, no lod
    v += texture(s2dr, tloc2);
    v += texture(s2dr, tloc2, 0.3);         // ERROR, no bias
    v += texture(s2drs, tloc3);
    v += textureProj(s2dr, tloc3);
    v += textureProj(s2dr, tloc4);
    v += textureProjGradOffset(s2dr, tloc4, ivec2(0.0), ivec2(0.0), ivec2(1,2));
    v += textureProjGradOffset(s2drs, tloc4, ivec2(0.0), ivec2(0.0), ivec2(1,2));
}

void devi()
{
    gl_DeviceIndex; // ERROR, no extension
    gl_ViewIndex;   // ERROR, no extension
}

#ifdef GL_EXT_device_group
#extension GL_EXT_device_group : enable
#endif

#ifdef GL_EXT_multiview
#extension GL_EXT_multiview : enable
#endif

void devie()
{
    gl_DeviceIndex;
    gl_ViewIndex;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[150.frag]=[
#version 150 core

in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR
layout(pixel_center_integer) in vec4 gl_FragCoord;  // ERROR
layout(origin_upper_left) in vec4 foo;  // ERROR
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;

void main()
{
    vec4 c = gl_FragCoord;
}

layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR, declared after use

in struct S { float f; } s;

float patch = 3.1;

uniform sampler2DMS sms;
uniform isampler2DMS isms;
uniform usampler2DMS usms;
uniform sampler2DMSArray smsa;
uniform isampler2DMSArray ismsa;
uniform usampler2DMSArray usmsa;

flat in ivec2 p2;
flat in ivec3 p3;
flat in int samp;

void barWxyz()
{
    ivec2 t11 = textureSize( sms);
    ivec2 t12 = textureSize(isms);
    ivec2 t13 = textureSize(usms);
    ivec3 t21 = textureSize( smsa);
    ivec3 t22 = textureSize(ismsa);
    ivec3 t23 = textureSize(usmsa);
     vec4 t31 = texelFetch( sms, p2, samp);
    ivec4 t32 = texelFetch(isms, p2, samp);
    uvec4 t33 = texelFetch(usms, p2, 3);
     vec4 t41 = texelFetch( smsa, p3, samp);
    ivec4 t42 = texelFetch(ismsa, ivec3(2), samp);
    uvec4 t43 = texelFetch(usmsa, p3, samp);
}

int primitiveID()
{
   return gl_PrimitiveID;
   gl_PerFragment; // ERROR, block name can't get reused
}

in double type1;    // ERROR
#extension GL_ARB_gpu_shader_fp64 : enable
double type2;
double type3 = 2.0;
int absTest = sqrt(type3);
double absTest2 = sqrt(type3);
double absTest3 = sqrt(2);
float dk = sqrt(11);

#extension GL_ARB_shader_bit_encoding: enable

float f;
vec4 v4;
ivec4 iv4a;
uvec2 uv2c;
void bitEncodingPass()
{
    int i = floatBitsToInt(f);
    uvec4 uv11 = floatBitsToUint(v4);
    vec4 v14 = intBitsToFloat(iv4a);
    vec2 v15 = uintBitsToFloat(uv2c);
}

#extension GL_ARB_shader_bit_encoding: disable

void bitEncodingFail()
{
    int i = floatBitsToInt(f); // Error, extention GL_ARB_bit_encoding is diabled
}

#extension GL_ARB_shading_language_packing : enable
vec2 v2a;
uint uy;

void packingPass()
{
    uint u19 = packSnorm2x16(v2a);
    vec2 v20 = unpackSnorm2x16(uy);
    uint u15 = packUnorm2x16(v2a);
    vec2 v16 = unpackUnorm2x16(uy);
    uint u17 = packHalf2x16(v2a);
    vec2 v18 = unpackHalf2x16(uy);
}

#extension GL_ARB_shading_language_packing : disable
void packingFail()
{
    uint u19 = packSnorm2x16(v2a); // Error, extension GL_ARB_shading_language_packing is disabled
}

// Testing extension GL_ARB_texture_query_lod
uniform sampler1D samp1D;
uniform sampler2DShadow samp2Ds;

void qlodFail()
{
    vec2 lod;
    float pf;
    vec2 pf2;
    vec3 pf3;

    lod = textureQueryLod(samp1D, pf);      // ERROR, extension GL_ARB_texture_query_lod needed
    lod = textureQueryLod(samp2Ds, pf2);    // ERROR, extension GL_ARB_texture_query_lod needed
}

#extension GL_ARB_texture_query_lod : enable

uniform isampler2D isamp2D;
uniform usampler3D usamp3D;
uniform samplerCube sampCube;
uniform isampler1DArray isamp1DA;
uniform usampler2DArray usamp2DA;

uniform sampler1DShadow samp1Ds;
uniform samplerCubeShadow sampCubes;
uniform sampler1DArrayShadow samp1DAs;
uniform sampler2DArrayShadow samp2DAs;

uniform samplerBuffer sampBuf;
uniform sampler2DRect sampRect;

void qlodPass()
{
    vec2 lod;
    float pf;
    vec2 pf2;
    vec3 pf3;

    lod = textureQueryLod(samp1D, pf);
    lod = textureQueryLod(isamp2D, pf2);
    lod = textureQueryLod(usamp3D, pf3);
    lod = textureQueryLod(sampCube, pf3);
    lod = textureQueryLod(isamp1DA, pf);
    lod = textureQueryLod(usamp2DA, pf2);

    lod = textureQueryLod(samp1Ds, pf);
    lod = textureQueryLod(samp2Ds, pf2);
    lod = textureQueryLod(sampCubes, pf3);
    lod = textureQueryLod(samp1DAs, pf);
    lod = textureQueryLod(samp2DAs, pf2);

    lod = textureQueryLod(sampBuf, pf);     // ERROR
    lod = textureQueryLod(sampRect, pf2);   // ERROR
}

// Test extension GL_EXT_shader_integer_mix
#extension GL_EXT_shader_integer_mix : enable
bool b1, b2, b;
int x,y;
uint z,w;

void testmix()
{
    int ival  = mix(x, y, b);
    ivec2 iv2 = mix(ivec2(x), ivec2(y), bvec2(b));
    ivec3 iv3 = mix(ivec3(x), ivec3(y), bvec3(b));
    ivec4 iv4 = mix(ivec4(x), ivec4(x), bvec4(b));
    uint  uiv = mix(z, w, b);
    uvec2 uv2 = mix(uvec2(z), uvec2(z), bvec2(b));
    uvec3 uv3 = mix(uvec3(z), uvec3(z), bvec3(b));
    uvec4 uv4 = mix(uvec4(z), uvec4(z), bvec4(b));
    bool  bv  = mix(b1, b2, b);
    bvec2 bv2 = mix(bvec2(b1), bvec2(b2), bvec2(b));
    bvec3 bv3 = mix(bvec3(b1), bvec3(b2), bvec3(b));
    bvec4 bv4 = mix(bvec4(b1), bvec4(b2), bvec4(b));
}

#extension GL_EXT_shader_integer_mix : disable
void testmixFail()
{
    int ival  = mix(x, y, b); // Error since extenson GL_EXT_shader_integer_mix is disabled
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
18:6; [@132,499:503='patch',<'patch'>,18:6]; no viable alternative at input 'float patch'; NoViableAltException:null
]


testGlslangErrors[150.geom]=[
#version 150 core

in fromVertex {
    in vec3 color;
} fromV[];

out toFragment {
    out vec3 color;
} toF;

out fromVertex {  // okay to reuse a block name for another block name
    vec3 color;
};

out fooB {
    vec2 color;
} fromVertex;     // ERROR, cannot reuse block name as block instance

int fromVertex;   // ERROR, cannot reuse a block name for something else

out fooC {
    vec2 color;
} fooC;           // ERROR, cannot have same name for block and instance name

void main()
{
    EmitVertex();
    EndPrimitive();
    EmitStreamVertex(1);    // ERROR
    EndStreamPrimitive(0);  // ERROR

    color = fromV[0].color;
    gl_ClipDistance[3] = gl_in[1].gl_ClipDistance[2];
    gl_Position = gl_in[0].gl_Position;
    gl_PointSize = gl_in[3].gl_PointSize;
    gl_PrimitiveID = gl_PrimitiveIDIn;
    gl_Layer = 2;
}

out vec4 ov0;  // stream should be 0
layout(stream = 4) out vec4 ov4;
out vec4 o1v0;  // stream should be 0

layout(stream = 3) uniform;        // ERROR
layout(stream = 3) in;             // ERROR
layout(stream = 3) uniform int ua; // ERROR
layout(stream = 3) uniform ubb { int ua; } ibb; // ERROR

layout(line_strip, points, triangle_strip, stream = 3, points, triangle_strip) out;  // just means "stream = 3, triangle_strip"
layout(stream = 3, triangle_strip) out;
out vec4 ov3;  // stream should be 3

layout(stream = 6) out ooutb { vec4 a; } ouuaa6;

layout(stream = 6) out ooutb2 {
    layout(stream = 6) vec4 a;
} ouua6;

layout(stream = 7) out ooutb3 {
    layout(stream = 6) vec4 a;  // ERROR
} ouua7;

out vec4 ov2s3;  // stream should be 3

layout(max_vertices = 200) out;
layout(max_vertices = 300) out;   // ERROR, too big
void foo(layout(max_vertices = 4) int a)  // ERROR
{
    ouuaa6.a = vec4(1.0);
}

layout(line_strip, points, triangle_strip, stream = 3, points) out;  // ERROR, changing output primitive
layout(line_strip, points, stream = 3) out; // ERROR, changing output primitive
layout(triangle_strip) in; // ERROR, not an input primitive
layout(triangle_strip) uniform; // ERROR
layout(triangle_strip) out vec4 badv4;  // ERROR, not on a variable
layout(triangle_strip) in vec4 bad2v4[];  // ERROR, not on a variable or input
layout(invocations = 3) out outbn { int a; }; // 2 ERROR, not on a block, not until 4.0
out outbn2 {
    layout(invocations = 3)  int a; // 2 ERRORs, not on a block member, not until 4.0
    layout(max_vertices = 3) int b; // ERROR, not on a block member
    layout(triangle_strip)   int c; // ERROR, not on a block member
} outbi;

layout(lines) out;  // ERROR, not on output
layout(lines_adjacency) in;
layout(triangles) in;             // ERROR, can't change it
layout(triangles_adjacency) in;   // ERROR, can't change it
layout(invocations = 4) in;       // ERROR, not until 4.0

in inbn {
    layout(stream = 2) int a;     // ERROR, stream on input
} inbi[];

in sameName {
    int a15;
} insn[];

out sameName {
    float f15;
};

uniform sameName {
    bool b15;
};

float summ = gl_MaxVertexAttribs +
             gl_MaxVertexUniformComponents +
             gl_MaxVaryingFloats +
             gl_MaxVaryingComponents +
             gl_MaxVertexOutputComponents  +
             gl_MaxGeometryInputComponents  +
             gl_MaxGeometryOutputComponents  +
             gl_MaxFragmentInputComponents  +
             gl_MaxVertexTextureImageUnits +
             gl_MaxCombinedTextureImageUnits +
             gl_MaxTextureImageUnits +
             gl_MaxFragmentUniformComponents +
             gl_MaxDrawBuffers +
             gl_MaxClipDistances  +
             gl_MaxGeometryTextureImageUnits +
             gl_MaxGeometryOutputVertices +
             gl_MaxGeometryTotalOutputComponents  +
             gl_MaxGeometryUniformComponents  +
             gl_MaxGeometryVaryingComponents;

void fooe1()
{
    gl_ViewportIndex = gl_MaxViewports - 1;
}

#extension GL_ARB_viewport_array : enable

void fooe2()
{
    gl_ViewportIndex = gl_MaxViewports - 1;
}

out int gl_ViewportIndex;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[150.tesc]=[
#version 150

#extension GL_ARB_tessellation_shader : enable

layout(vertices = 4) out;
int outa[gl_out.length()];

patch out vec4 patchOut;

void main()
{
    barrier();

    int a = gl_MaxTessControlInputComponents +
            gl_MaxTessControlOutputComponents +
            gl_MaxTessControlTextureImageUnits +
            gl_MaxTessControlUniformComponents +
            gl_MaxTessControlTotalOutputComponents;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;
    gl_out[gl_InvocationID].gl_ClipDistance[1] = cd;

    gl_TessLevelOuter[3] = 3.2;
    gl_TessLevelInner[1] = 1.3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[150.tese]=[
#version 150

#extension GL_ARB_tessellation_shader : enable

layout(quads, cw) in;
layout(fractional_odd_spacing) in;    
layout(point_mode) in;
patch in vec4 patchIn;

void main()
{
    barrier(); // ERROR

    int a = gl_MaxTessEvaluationInputComponents +
            gl_MaxTessEvaluationOutputComponents +
            gl_MaxTessEvaluationTextureImageUnits +
            gl_MaxTessEvaluationUniformComponents +
            gl_MaxTessPatchComponents +
            gl_MaxPatchVertices +
            gl_MaxTessGenLevel;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    vec3 tc = gl_TessCoord;
    float tlo = gl_TessLevelOuter[3];
    float tli = gl_TessLevelInner[1];

    gl_Position = p;
    gl_PointSize = ps;
    gl_ClipDistance[2] = cd;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[150.vert]=[
#version 150 core

#ifndef GL_core_profile
#	error standard macro GL_core_profile not defined
#endif

in vec4 iv4;

uniform float ps;

invariant gl_Position;

void main()
{
    gl_Position = iv4;
    gl_PointSize = ps;
    gl_ClipDistance[2] = iv4.x;
    gl_ClipVertex = iv4;
}

out float gl_ClipDistance[4];

uniform foob {
    int a[];
};
int a[5]; // ERROR, resizing user-block member

in double dvarerr; // Error since extension GL_ARB_vertex_attrib_64bit is not enabled
#extension GL_ARB_vertex_attrib_64bit: enable
in double dvar;
in dvec2  dv2var;
in dvec3  dv3var;
in dvec4  dv4var;
in dmat2  dmat2var;
in dmat3  dmat3var;
in dmat4  dmat4var;
in dmat2x3 dmat23var;
in dmat2x4 dmat24var;
in dmat3x2 dmat32var;
in dmat3x4 dmat34var;
in dmat4x2 dmat42var;
in dmat4x3 dmat43var;

#line 3000
#error line of this error should be 3001

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300.frag]=[
#version 300 es
void nodef1(float f); // ERROR, no default precision
uniform sampler2D s2D;
uniform lowp sampler3D s3D;
uniform samplerCube sCube;
uniform lowp samplerCubeShadow sCubeShadow;
uniform lowp sampler2DShadow s2DShadow;
uniform lowp sampler2DArray s2DArray;
uniform lowp sampler2DArrayShadow s2DArrayShadow;

uniform lowp isampler2D is2D;
uniform lowp isampler3D is3D;
uniform lowp isamplerCube isCube;
uniform lowp isampler2DArray is2DArray;

uniform lowp usampler2D us2D;
uniform lowp usampler3D us3D;
uniform lowp usamplerCube usCube;
uniform lowp usampler2DArray us2DArray;
precision lowp float;
in float c1D;
in vec2  c2D;
in vec3  c3D;
smooth vec4  c4D;

flat in int   ic1D;
flat in ivec2 ic2D;
flat in ivec3 ic3D;
flat in ivec4 ic4D;
noperspective in vec4 badv; // ERROR
in sampler2D bads;          // ERROR
precision lowp uint;        // ERROR

struct s {
    int i;
    sampler2D s;
};

in s badout;               // ERROR, can't contain a sampler
                           // ERROR, can't have int in struct without flat
struct S2 {
    vec3 c;
    float f;
};

in S2 s2;

out vec3 sc;
out float sf;

uniform sampler2D arrayedSampler[5];

void main()
{
    float f;
    vec4 v;
    v = texture(s2D, c2D);
    v = textureProj(s3D, c4D);
    v = textureLod(s2DArray, c3D, 1.2);
    f = textureOffset(s2DShadow, c3D, ic2D, c1D);  // ERROR, offset argument not constant
    v = texelFetch(s3D, ic3D, ic1D);
    v = texelFetchOffset(arrayedSampler[2], ic2D, 4, ic2D);   // ERROR, offset argument not constant
    f = textureLodOffset(s2DShadow, c3D, c1D, ic2D);
    v = textureProjLodOffset(s2D, c3D, c1D, ic2D);
    v = textureGrad(sCube, c3D, c3D, c3D);
    f = textureGradOffset(s2DArrayShadow, c4D, c2D, c2D, ic2D);
    v = textureProjGrad(s3D, c4D, c3D, c3D);
    v = textureProjGradOffset(s2D, c3D, c2D, c2D, ic2D);
    v = texture(arrayedSampler[ic1D], c2D);                 // ERROR

    ivec4 iv;
    iv = texture(is2D, c2D);
    iv = textureProjOffset(is2D, c4D, ic2D);
    iv = textureProjLod(is2D, c3D, c1D);
    iv = textureProjGrad(is2D, c3D, c2D, c2D);
    iv = texture(is3D, c3D, 4.2);
    iv = textureLod(isCube, c3D, c1D);
    iv = texelFetch(is2DArray, ic3D, ic1D);

    iv.xy = textureSize(sCubeShadow, 2);

    float precise;
    double boo;       // ERROR
    dvec2 boo2;       // ERROR
    dvec3 boo3;       // ERROR
    dvec4 boo4;       // ERROR

    f += gl_FragCoord.y;
    gl_FragDepth = f;

    sc = s2.c;
    sf = s2.f;

    sinh(c1D) +
    cosh(c1D) * tanh(c2D);
    asinh(c4D) + acosh(c4D);
    atanh(c3D);
}

uniform multi {
    int[2] a[3];      // ERROR
    int[2][3] b;      // ERROR
    int c[2][3];      // ERROR
} multiInst[2][3];    // ERROR

out vec4 colors[4];

void foo()
{
    colors[2] = c4D;
    colors[ic1D] = c4D;  // ERROR
}

uniform s st1;
uniform s st2;

void foo13(s inSt2)
{
    if (st1 == st2);  // ERROR
    if (st1 != st2);  // ERROR
    st1.s == st2.s;   // ERROR
    inSt2 = st1;      // ERROR
    inSt2 == st1;     // ERROR
}

void foo23()
{
    textureOffset(s2DShadow, c3D, ivec2(-8, 7), c1D);
    textureOffset(s2DShadow, c3D, ivec2(-9, 8), c1D);
}

void foo324(void)
{
    float p = pow(3.2, 4.6);
    p += sin(0.4);
    p += distance(vec2(10.0, 11.0), vec2(13.0, 15.0)); // 5
    p += dot(vec3(2,3,5), vec3(-2,-1,4));              // 13
    vec3 c3 = cross(vec3(3,-3,1), vec3(4,9,2));        // (-15, -2, 39)
    c3 += faceforward(vec3(1,2,3), vec3(2,3,5), vec3(-2,-1,4));     // (-1,-2,-3)
    c3 += faceforward(vec3(1,2,3), vec3(-2,-3,-5), vec3(-2,-1,4));  // (1,2,3)
    vec2 c2 = reflect(vec2(1,3), vec2(0,1));           // (1,-3)
    c2 += refract(vec2(1,3), vec2(0,1), 1.0);          // (1,-3)
    c2 += refract(vec2(1,3), vec2(0,1), 3.0);
    c2 += refract(vec2(1,0.1), vec2(0,1), 5.0);        // (0,0)
    mat3x2 m32 = outerProduct(vec2(2,3), vec3(5,7,11));// rows: (10, 14, 22), (15, 21, 33)
}

uniform mediump;       // ERROR

layout(early_fragment_tests) in;  // ERROR

// Test extension GL_EXT_shader_integer_mix
#extension GL_EXT_shader_integer_mix : enable
bool b1, b2, b;
int x,y;
uint z,w;

void testmix()
{
    int ival  = mix(x, y, b);
    ivec2 iv2 = mix(ivec2(x), ivec2(y), bvec2(b));
    ivec3 iv3 = mix(ivec3(x), ivec3(y), bvec3(b));
    ivec4 iv4 = mix(ivec4(x), ivec4(x), bvec4(b));
    uint  uiv = mix(z, w, b);
    uvec2 uv2 = mix(uvec2(z), uvec2(z), bvec2(b));
    uvec3 uv3 = mix(uvec3(z), uvec3(z), bvec3(b));
    uvec4 uv4 = mix(uvec4(z), uvec4(z), bvec4(b));
    bool  bv  = mix(b1, b2, b);
    bvec2 bv2 = mix(bvec2(b1), bvec2(b2), bvec2(b));
    bvec3 bv3 = mix(bvec3(b1), bvec3(b2), bvec3(b));
    bvec4 bv4 = mix(bvec4(b1), bvec4(b2), bvec4(b));
}

#extension GL_EXT_shader_integer_mix : disable
void testmixFail()
{
    int ival  = mix(x, y, b); // Error since extenson GL_EXT_shader_integer_mix is disabled
}

// Test layout qualifier "index" with extension GL_EXT_blend_func_extended
layout(location = 0, index = 1) out vec4 outVarFail; // Error Index supported with extension GL_EXT_blend_func_extended enabled
#extension GL_EXT_blend_func_extended : enable
layout(location = 0, index = 2) out vec4 outVarPass;

#ifndef GL_FRAGMENT_PRECISION_HIGH
#error missing GL_FRAGMENT_PRECISION_HIGH
#endif

invariant in;                // ERROR
invariant in vec4;           // ERROR
invariant in vec4 fooinv;    // ERROR

float imageBuffer;    // ERROR, reserved
float uimage2DRect;   // ERROR, reserved

<><><><><><><><><><><><><><><><><><><><><><><><><>
82:10; [@756,2255:2261='precise',<'precise'>,82:10]; no viable alternative at input 'float precise'; NoViableAltException:null
193:6; [@1979,5338:5348='imageBuffer',<'imageBuffer'>,193:6]; no viable alternative at input 'float imageBuffer'; NoViableAltException:null
194:6; [@1985,5379:5390='uimage2DRect',<'uimage2DRect'>,194:6]; no viable alternative at input 'float uimage2DRect'; NoViableAltException:null
]


testGlslangErrors[300.vert]=[
#version 300 es

uniform mat4x3 m43;
uniform mat3x3 m33;
uniform mat4x4 m44;

in vec3 v3;
varying vec2 v2;               // ERROR, varying reserved
in vec4 bad[10];               // ERROR, no arrayed inputs
highp in vec4 badorder;        // ERROR, incorrect qualifier order
out invariant vec4 badorder2;  // ERROR, incorrect qualifier order
in centroid vec4 badorder4;    // ERROR, incorrect qualifier order
out flat vec4 badorder3;       // ERROR, incorrect qualifier order
void bar(in const float a);    // ERROR, incorrect qualifier order
void bar2(highp in float b);   // ERROR, incorrect qualifier order
smooth flat out vec4 rep;      // ERROR, replicating interpolation qualification
centroid sample out vec4 rep2; // ERROR, replicating auxiliary qualification
in uniform vec4 rep3;          // ERROR, replicating storage qualification

struct S {
    vec3 c;
    float f;
};

out S s;

void main()
{
    int id = gl_VertexID + gl_InstanceID;

    int c0 = gl_MaxVertexAttribs;
    int c1 = gl_MaxVertexUniformVectors;
    int c2 = gl_MaxVertexOutputVectors;
    int c3 = gl_MaxFragmentInputVectors;
    int c4 = gl_MaxVertexTextureImageUnits;
    int c5 = gl_MaxCombinedTextureImageUnits;
    int c6 = gl_MaxTextureImageUnits;
    int c7 = gl_MaxFragmentUniformVectors;
    int c8 = gl_MaxDrawBuffers;
    int c9 = gl_MinProgramTexelOffset;
    int c10 = gl_MaxProgramTexelOffset;

    mat3x4 tm = transpose(m43);
    highp float dm = determinant(m44);
    mat3x3 im = inverse(m33);

    mat3x2 op = outerProduct(v2, v3);

    gl_Position = m44[2];
    gl_PointSize = v2.y;

     s.c = v3;
     s.f = dm;

#ifdef GL_ES
#error GL_ES is set
#else
#error GL_ES is not set
#endif
}

float badsize[];    // ERROR
float[] badsize2;   // ERROR
uniform ub {
    int a[];        // ERROR
} ubInst[];         // ERROR
void foo(int a[]);  // ERROR
float okayA[] = float[](3.0f, 4.0F);  // Okay

out vec3 newV;
void newVFun()
{
    newV = v3;
}

invariant newV;  // ERROR, variable already used
in vec4 invIn;
invariant invIn; // ERROR, in v300
out S s2;
invariant s2;
invariant out S s3;
flat out int;

uniform ub2 {
    float f;
} a;

uniform ub2 {  // ERROR redeclaration of block name (same instance name)
    float g;
} a;

uniform ub2 {  // ERROR redeclaration of block name (different instance name)
    float f;
} c;

uniform ub2 {  // ERROR redeclaration of block name (no instance name)
    float f123;
};

uniform ub3 {
    bool b23;
};

uniform ub3 {  // ERROR redeclaration of block name (no instance name in first or declared)
    bool b234;
};

precision lowp sampler3D;
precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;

uniform sampler2D s2D;
uniform sampler3D s3D;
uniform sampler2DShadow s2DS;
uniform sampler2DArrayShadow s2DAS;
in vec2 c2D;

void foo23()
{
    ivec2 x1 = textureSize(s2D, 2);
    textureSize(s2D);        // ERROR, no lod
    ivec3 x3 = textureSize(s2DAS, -1);
    textureSize(s2DAS);      // ERROR, no lod
    vec4 x4 = texture(s2D, c2D);
    texture(s2D, c2D, 0.2);  // ERROR, bias
    vec4 x5 = textureProjOffset(s3D, vec4(0.2), ivec3(1));
    textureProjOffset(s3D, vec4(0.2), ivec3(1), .03);  // ERROR, bias
    float x6 = textureProjGradOffset(s2DS, invIn, vec2(4.2), vec2(5.3), ivec2(1));
}

int fgfg(float f, mediump int i);
int fgfg(float f, highp int i);   // ERROR, precision qualifier difference

int fgfgh(float f, const in mediump int i);
int fgfgh(float f, in mediump int i);   // ERROR, precision qualifier difference

void foo2349()
{
    float[] x = float[] (1.0, 2.0, 3.0);
	float[] y = x;
    float[3] z = x;
    float[3] w;
    w = y;
}

int[] foo213234();        // ERROR
int foo234234(float[]);   // ERROR
int foo234235(vec2[] v);  // ERROR
precision highp float[2]; // ERROR

int fffg(float f);
int fffg(float f);

int gggf(float f);
int gggf(float f) { return 2; }
int gggf(float f);

int agggf(float f) { return 2; }
int agggf(float f);

out struct Ssss { float f; } ssss;

uniform Bblock {
   int a;
} Binst;
int Bfoo;

layout(std140) Binst;    // ERROR
layout(std140) Bblock;   // ERROR
layout(std140) Bfoo;     // ERROR

layout(std430) uniform B430 { int a; } B430i;     // ERROR

struct SNA {
    int a[];             // ERROR
};

void fooDeeparray()
{
    float[] x = float[] (1.0, 2.0, 3.0),
            y = float[] (1.0, 2.0, 3.0, 4.0);
    float xp[3], yp[4];
    xp = x;
    yp = y;
    xp = y; // ERROR, wrong size
    yp = x; // ERROR, wrong size
}

layout(num_views = 2) in; // ERROR, no extension

void mwErr()
{
    gl_ViewID_OVR;   // ERROR, no extension
}

#extension GL_OVR_multiview : enable

layout(num_views = 2) uniform float mwUniform; // ERROR, must be global
layout(num_views = 2) in; // OK

void mwOk()
{
    gl_ViewID_OVR;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300BuiltIns.frag]=[
#version 300 es

int imax, imin;
uint umax, umin;

vec3 x, y;    // ERROR, needs default precision
bvec3 bv;

uint uy;
uvec2 uv2c;
uvec2 uv2y;
uvec2 uv2x;
uvec4 uv4y;

ivec3 iv3a;
ivec3 iv3b;

ivec4 iv4a;
ivec4 iv4b;

float f;

vec2 v2a, v2b;
vec4 v4;

void main()
{
    // 1.3 int
    vec3 v = mix(x, y, bv);
    ivec4 iv10 = abs(iv4a);
    ivec4 iv11 = sign(iv4a);
    ivec4 iv12 = min(iv4a, iv4b);
    ivec4 iv13 = min(iv4a, imin);
    uvec2 u = min(uv2x, uv2y);
    uvec4 uv = min(uv4y, uy);
    ivec3 iv14 = max(iv3a, iv3b);
    ivec4 iv15 = max(iv4a, imax);
    uvec2 u10 = max(uv2x, uv2y);
    uvec2 u11 = max(uv2x, uy);
    ivec4 iv16 = clamp(iv4a, iv4a, iv4b);
    ivec4 iv17 = clamp(iv4a, imin, imax);
    uvec2 u12 = clamp(uv2x, uv2y, uv2c);
    uvec4 uv10 = clamp(uv4y, umin, umax);

    // 1.3 float
    vec3 modfOut;
    vec3 v11 = modf(x, modfOut);

    float t = trunc(f);
    vec2 v12 = round(v2a);
    vec2 v13 = roundEven(v2a);
    bvec2 b10 = isnan(v2a);
    bvec4 b11 = isinf(v4);

    // 3.3 float
    int i = floatBitsToInt(f);
    uvec4 uv11 = floatBitsToUint(v4);
    vec4 v14 = intBitsToFloat(iv4a);
    vec2 v15 = uintBitsToFloat(uv2c);

    // 4.0  pack
    uint u19 = packSnorm2x16(v2a);
    vec2 v20 = unpackSnorm2x16(uy);
    uint u15 = packUnorm2x16(v2a);
    vec2 v16 = unpackUnorm2x16(uy);
    uint u17 = packHalf2x16(v2b);
    vec2 v18 = unpackHalf2x16(uy);

    // not present
    noise2(v18);  // ERROR, not present

    float t__;  // ERROR, no __ until revision 310

      // ERROR, no __ until revision 310
    #define __D
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300block.frag]=[
#version 300 es

precision mediump float;

struct S {
    vec4 u;
    uvec4 v;
    lowp isampler3D sampler;
    vec3 w;
    struct T1 {           // ERROR
        int a;
    } t;
};

uniform S s;

uniform fooBlock {
    uvec4 bv;
    uniform mat2 bm2;
    lowp isampler2D sampler;   // ERROR
    struct T2 {                // ERROR
        int a;
    } t;
    S fbs;                     // ERROR, contains a sampler
};

uniform barBlock {
    uvec4 nbv;
    int ni;
} inst;

uniform barBlockArray {
    uvec4 nbv;
    int ni;
} insts[4];

uniform unreferenced {
    float f;
    uint u;
};

void main()
{
    texture(s.sampler, vec3(inst.ni, bv.y, insts[2].nbv.z));
    insts[s.v.x];         // ERROR
    fooBlock;             // ERROR
    mat4(s);              // ERROR
    int insts;
    float barBlock;
    mat4(barBlock);
    mat4(unreferenced);   // ERROR, bad type
    ++s;                  // ERROR
    inst - 1;             // ERROR
    ++barBlock;
    2 * barBlockArray;    // ERROR
}

int fooBlock;             // ERROR, redef.

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300layout.frag]=[
#version 300 es
precision mediump float;
in vec4 pos;
layout (location = 2) in vec4 color;  // ERROR

layout(location = 1) out vec4 c;
layout(location = 3) out vec4 p;
layout(location = 4) out vec4 q[2];

void main()
{
    c = color;
    p = pos;
    q[1] = pos;
}

layout(location = 40) out float ca[4];  // ERROR, overlap, ERROR too big
layout(location = 41) out float cb[2];  // ERROR, overlap, ERROR too big
layout(location = 39) out float cc[6];  // ERROR, overlap, ERROR too big

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300layout.vert]=[
#version 300 es

struct s { vec4 v; };

layout(location = 7) in vec3 c;
layout(LocatioN = 3) in vec4 p;
layout(LocatioN = 9) in vec4 q[4]; // ERROR, no array
layout(LocatioN = 10) in s r[4];   // ERROR, no struct, ERROR, location overlap
out vec4 pos;
out vec3 color;

layout(shared, column_major) uniform mat4 badm4; // ERROR
layout(shared, column_major, row_major) uniform; // default is now shared and row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1; // row_major
    layout(column_major) mat4 M2; // column major
    mat3 N1; // row_major
    centroid float badf;  // ERROR
    in float badg;        // ERROR
    layout(std140) float bad1;
    layout(shared) float bad2;
    layout(packed) float bad3;
} tblock;

uniform T2 { // layout of this block is shared
    bool b;
    mat4 t2m;
};

layout(column_major) uniform T3 { // shared and column_major
    mat4 M3; // column_major
    layout(row_major) mat4 M4; // row major
    mat3 N2; // column_major
    int b;  // ERROR, redefinition (needs to be last member of block for testing, following members are skipped)
};

out badout {  // ERROR
    float f;
};

layout (location = 10) out vec4 badoutA;  // ERROR

void main()
{
    pos = p * (tblock.M1 + tblock.M2 + M4 + M3 + t2m);
    color = c * tblock.N1;
}

shared vec4 compute_only;  // ERROR

layout(packed) uniform;

layout(packed) uniform float aoeuntaoeu;  // ERROR, packed on variable

layout(location = 40) in float cd;
layout(location = 37) in mat4x3 ce; // ERROR, overlap

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300link.frag]=[
#version 300 es

precision highp float;

out vec4 color1;
out vec4 color2;

void main() {}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300link2.frag]=[
#version 300 es
precision mediump float;
in vec4 pos;

layout(location = 1) out vec4 c;
layout(location = 5) out vec4 p;
layout(location = 9) out vec4 q[2];

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300link3.frag]=[
#version 300 es

precision highp float;

out vec4 color1;

void main() {}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300operations.frag]=[
#version 300 es

uniform block {
    mediump float f;
} instanceName;

struct S {
    int i;
} s;

float a[5];

void main()
{
    bool b;
    float f;
    int i;
    uint u;
    bvec3 b3;
    vec3 v3;
    ivec3 iv3;
    uvec3 uv3;
    vec4 v4;
    ivec4 iv4;
    uvec4 uv4;
    mat2 m2;
    mat4 m4;

    // These are all errors:
    instanceName + instanceName;
    s + s;
    i + f;
    u + f;
    u + i;
    iv3 *= iv4;
    iv4 / uv4;
    i - v3;
    iv3 + uv3;
    a * a;
    b / b;

    f % f;
    i % f;
    f % u;
    instanceName++;
    ++s;
    a--;
    ++b3;

    iv3 < uv3;
    m2 > m2;
    m2 != m4;
    i >= u;
    a <= a;
    b > b;

    b && b3;
    b3 ^^ b3;
    b3 || b;
    i && i;
    u || u;
    m2 ^^ m2;

    !u;
    !i;
    !m2;
    !v3;
    !a;

    ~f;
    ~m4;
    ~v3;
    ~a;
    ~instanceName;

    i << iv3;
    u << uv3;
    i >> f;
    f >> i;
    m4 >> i;
    a >> u;
    iv3 >> iv4;

    i & u;    
    u &= uv3;
    i | uv3;
    u & f;
    m2 | m2;
    s ^ s;
    (f = f) = f;

    // These are all okay:
    f * v4;
    u + u;
    uv4 / u;
    iv3 -= iv3;
    
    i %= 3;
    uv3 % 4u;
    --m2;
    iv4++;

    m4 != m4;
    m2 == m2;
    i <= i;
    a == a;
    s != s;

    b && b;
    b || b;
    b ^^ b;

    !b, uv3;

    ~i;
    ~u;
    ~uv3;
    ~iv3;

    uv3 <<= i;
    i >> i;
    u << u;
    iv3 >> iv3;

    i & i;
    u | u;
    iv3 ^ iv3;
    u & uv3;
    uv3 | u;
    uv3 &= u;
    int arr[0x222 & 0xf];
    arr[1]; // size 2
    int arr2[(uvec2(0, 0x2) | 0x1u).y];
    arr2[2]; // size 3
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300samplerExternal.frag]=[
#version 300 es

#extension GL_OES_EGL_image_external_essl3 : enable

uniform samplerExternalOES sExt;
precision mediump samplerExternalOES;
uniform samplerExternalOES mediumExt;
uniform highp samplerExternalOES highExt;

void main()
{
    texture2D(sExt, vec2(0.2));  // ERROR
    texture2D(mediumExt, vec2(0.2));  // ERROR
    texture2D(highExt, vec2(0.2));  // ERROR
    texture2DProj(sExt, vec3(0.3));  // ERROR
    texture2DProj(sExt, vec4(0.3));  // ERROR

    int lod = 0;
    highp float bias = 0.01;
    textureSize(sExt, lod);
    texture(sExt, vec2(0.2));
    texture(sExt, vec2(0.2), bias);
    textureProj(sExt, vec3(0.2));
    textureProj(sExt, vec3(0.2), bias);
    textureProj(sExt, vec4(0.2));
    textureProj(sExt, vec4(0.2), bias);
    texelFetch(sExt, ivec2(4), lod);

    texture3D(sExt, vec3(0.3));  // ERROR
    texture2DProjLod(sExt, vec3(0.3), 0.3);  // ERROR
    texture(sExt, vec3(0.3));  // ERROR
    textureProjLod(sExt, vec3(0.3), 0.3);  // ERROR
}

#extension GL_OES_EGL_image_external_essl3 : disable

#extension GL_OES_EGL_image_external : enable
uniform samplerExternalOES badExt;  // ERROR
#extension GL_OES_EGL_image_external : disable

uniform samplerExternalOES badExt;  // ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>
5:8; [@20,82:99='samplerExternalOES',<'samplerExternalOES'>,5:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
6:18; [@29,126:143='samplerExternalOES',<'samplerExternalOES'>,6:18]; mismatched input 'samplerExternalOES' expecting {'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', IDENTIFIER}; InputMismatchException:null
7:8; [@34,155:172='samplerExternalOES',<'samplerExternalOES'>,7:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
8:14; [@43,200:217='samplerExternalOES',<'samplerExternalOES'>,8:14]; no viable alternative at input 'uniform highp samplerExternalOES'; NoViableAltException:null
38:8; [@350,1125:1142='samplerExternalOES',<'samplerExternalOES'>,38:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
41:8; [@368,1221:1238='samplerExternalOES',<'samplerExternalOES'>,41:8]; no viable alternative at input 'uniform samplerExternalOES'; NoViableAltException:null
]


testGlslangErrors[300samplerExternalYUV.frag]=[
#version 300 es

#extension GL_EXT_YUV_target : enable

uniform __samplerExternal2DY2YEXT sExt;
precision mediump __samplerExternal2DY2YEXT;
uniform __samplerExternal2DY2YEXT mediumExt;
uniform highp __samplerExternal2DY2YEXT highExt;

void main()
{
    texture2D(sExt, vec2(0.2));  // ERROR
    texture2D(mediumExt, vec2(0.2));  // ERROR
    texture2D(highExt, vec2(0.2));  // ERROR
    texture2DProj(sExt, vec3(0.3));  // ERROR
    texture2DProj(sExt, vec4(0.3));  // ERROR

    int lod = 0;
    highp float bias = 0.01;
    textureSize(sExt, lod);
    texture(sExt, vec2(0.2));
    texture(sExt, vec2(0.2), bias);
    textureProj(sExt, vec3(0.2));
    textureProj(sExt, vec3(0.2), bias);
    textureProj(sExt, vec4(0.2));
    textureProj(sExt, vec4(0.2), bias);
    texelFetch(sExt, ivec2(4), lod);

    texture3D(sExt, vec3(0.3));  // ERROR
    texture2DProjLod(sExt, vec3(0.3), 0.3);  // ERROR
    texture(sExt, vec3(0.3));  // ERROR
    textureProjLod(sExt, vec3(0.3), 0.3);  // ERROR
}

#extension GL_EXT_YUV_target : disable

uniform __samplerExternal2DY2YEXT badExt;  // ERROR
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[300scope.vert]=[
#version 300 es

int f(int a, int b, int c)
{
	int a = b;  // ERROR, redefinition

    {
		float a = float(a) + 1.0;
    }

	return a;
}

int f(int a, int b, int c);  // okay to redeclare

bool b;
float b(int a);      // ERROR: redefinition

float c(int a);
bool c;              // ERROR: redefinition

float f;             // ERROR: redefinition
float tan;           // ERROR: redefines built-in function
float sin(float x);  // ERROR: can't redefine built-in functions
float cos(float x)   // ERROR: can't redefine built-in functions
{
	return 1.0;
}
bool radians(bool x) // ERROR: can't overload built-in functions
{
    return true;
}

invariant gl_Position;

void main()
{
    int g();    // ERROR: no local function declarations
	g();

    float sin;  // okay
	sin;
    sin(0.7);  // ERROR, use of hidden function
    f(1,2,3);

    float f;    // hides f()
    f = 3.0;

    gl_Position = vec4(f);

    for (int f = 0; f < 10; ++f)
        ++f;

    int x = 1;
    { 
        float x = 2.0, /* 2nd x visible here */ y = x; // y is initialized to 2
        int z = z; // ERROR: z not previously defined.
    }
    {
        int x = x; // x is initialized to '1'
    }

    struct S 
    { 
        int x; 
    };
    {
        S S = S(0); // 'S' is only visible as a struct and constructor 
        S.x;        // 'S' is now visible as a variable
    }

    int degrees;
    degrees(3.2);  // ERROR, use of hidden built-in function
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.comp]=[
#version 310 es

layout(local_size_x = 2) in;
layout(local_size_x = 16) in;     // ERROR, changing
layout(local_size_z = 4096) in;   // ERROR, too large
layout(local_size_x = 2) in;
layout(local_size_y = 0) in;      // ERROR, 0 not allowed
const int total = gl_MaxComputeWorkGroupCount.y 
                + gl_MaxComputeUniformComponents
                + gl_MaxComputeTextureImageUnits
                + gl_MaxComputeImageUniforms
                + gl_MaxComputeAtomicCounters
                + gl_MaxComputeAtomicCounterBuffers;

buffer ShaderStorageBlock
{
    int value;
    float values[];
};

buffer InvalidShaderStorageBlock
{
    float values[];  // ERROR
    int value;
} invalid;

void main()
{
    barrier();
    memoryBarrier();
    memoryBarrierAtomicCounter();
    memoryBarrierBuffer();
    memoryBarrierShared();
    memoryBarrierImage();
    groupMemoryBarrier();
    value = int(values[gl_LocalInvocationIndex]);
}

layout(location = 2) in vec3 v3;      // ERROR
in float f;                           // ERROR
out float fo;                         // ERROR

shared vec4 s;
layout(location = 2) shared vec4 sl;  // ERROR
shared float fs = 4.2;                // ERROR

layout(local_size_x = 2, local_size_y = 3, local_size_z = 4) out;  // ERROR

int arrX[gl_WorkGroupSize.x];
int arrY[gl_WorkGroupSize.y];
int arrZ[gl_WorkGroupSize.z];

readonly buffer roblock
{
    int value;
    float values[];
} ro;

void foo()
{
    ro.values[2] = 4.7;        // ERROR, readonly
    ro.values.length();
    ++s;
}

buffer vec4 v;  // ERROR

uniform usampler2D us2dbad;  // ERROR, default precision

precision highp usampler2D;
precision highp iimage2DArray;
precision highp iimage2D;

uniform usampler2D us2d;

uniform iimage2DArray ii2dabad;  // ERROR, not writeonly
uniform writeonly iimage2DArray ii2da;

layout(r32i) uniform iimage2D iimg2D;
layout(rgba32i) uniform readonly iimage2D iimg2Drgba;
layout(rgba32f) uniform readonly image2D img2Drgba;   // ERROR, no default
layout(r32ui) uniform uimage2D uimg2D;                // ERROR, no default

void qux()
{
    int i = 4;
    imageAtomicCompSwap(iimg2D, ivec2(i,i), i, i);// ERROR no longer in 310
    imageAtomicAdd(uimg2D, ivec2(i,i), uint(i));  // ERROR no longer in 310
    imageAtomicMin(iimg2Drgba, ivec2(i,i), i);    // ERROR no longer in 310  // ERROR iimg2Drgba does not have r32i layout
    imageAtomicMax(img2Drgba, ivec2(i,i), i);     // ERROR no longer in 310  // ERROR img2Drgba is not integer image
    ivec4 pos = imageLoad(iimg2D, ivec2(i,i));
    imageStore(ii2da, ivec3(i,i,i), ivec4(0));
    imageLoad(img2Drgba, ivec2(i,i));
    imageLoad(ii2da, ivec3(i,i,i));       // ERROR, drops writeonly
}

volatile float vol; // ERROR, not an image
readonly int vol2;  // ERROR, not an image

void passr(coherent readonly iimage2D image)
{
}

layout(r32i) coherent readonly uniform iimage2D qualim1;
layout(r32i) coherent restrict readonly uniform iimage2D qualim2;

void passrc()
{
    passr(qualim1);   // ERROR, changing formats
    passr(qualim2);   // ERROR, drops restrict, ERROR, changing formats
    passr(iimg2D);    // ERROR, changing formats
}

highp layout(rg8i)     uniform readonly uimage2D i1bad; // ERROR, type mismatch
highp layout(rgba32i)  uniform readonly image2D i2bad;  // ERROR, type mismatch
highp layout(rgba32f)  uniform readonly uimage2D i3bad; // ERROR, type mismatch
layout(r8_snorm) uniform readonly iimage2D i4bad; // ERROR, type mismatch
layout(rgba32ui) uniform readonly iimage2D i5bad; // ERROR, type mismatch
layout(r8ui)     uniform readonly iimage2D i6bad; // ERROR, type mismatch

layout(binding = 0) uniform atomic_uint counter;

uint func(atomic_uint c)
{
    return atomicCounterIncrement(c);
}

uint func2(out atomic_uint c) // ERROR, output
{
    return counter;           // ERROR, type mismatch
    return atomicCounter(counter);
}

void mainAC()
{
     atomic_uint non_uniform_counter; // ERROR
     uint val = atomicCounter(counter);
     atomicCounterDecrement(counter);
}

layout(binding = 1) uniform mediump atomic_uint counterBad;  // ERROR, not highp

layout(binding = 2, offset = 4) uniform atomic_uint countArr[4];
uniform int i;

void opac()
{
    int a[3];
    a[counter];         // ERROR, non-integer
    countArr[2];
    countArr[i];
}

shared int atomi;
shared uint atomu;

void atoms()
{
    int origi = atomicAdd(atomi, 3);
    uint origu = atomicAnd(atomu, 7u);
    origi = atomicExchange(atomi, 4);
    origu = atomicCompSwap(atomu, 10u, 8u);
}

precision highp atomic_uint;
precision lowp atomic_uint;   // ERROR

precise int pfoo;  // ERROR, reserved

dmat2x4 dm;                     // ERROR
uniform samplerCubeArray sca;   // ERROR
uniform iimage2DRect i2dr;      // ERROR
highp uniform image2DMS i2dms;  // ERROR
uniform uimage2DMSArray u2dmsa; // ERROR

highp layout(r32f)  coherent volatile restrict readonly writeonly uniform  image2D okay1;
      layout(r32i)  coherent volatile restrict readonly           uniform iimage2D okay2;
highp layout(r32ui) coherent volatile restrict          writeonly uniform uimage2D okay3;
highp layout(r32f)  coherent volatile restrict                    uniform  image2D okay4;
 
highp layout(rgba32f)  coherent volatile restrict                 uniform  image2D badQ1;  // ERROR, bad qualifiers
      layout(rgba8i)   coherent volatile restrict                 uniform iimage2D badQ2;  // ERROR, bad qualifiers
highp layout(rgba16ui) coherent volatile restrict                 uniform uimage2D badQ3;  // ERROR, bad qualifiers

writeonly buffer woblock
{
    int value;
    float values[];
} wo;

void foowo()
{
    float g;
    g = wo.values[2];            // ERROR, writeonly
    float f = wo.values[2];      // ERROR, writeonly
    ++wo.values[2];              // ERROR, writeonly
    wo.values[2]--;              // ERROR, writeonly
    f + wo.values[2];            // ERROR, writeonly
    wo.values[2] - f;            // ERROR, writeonly
    bool b;
    b ? f : wo.values[2];        // ERROR, writeonly
    b ? wo.values[2] : f;        // ERROR, writeonly
    if (f == wo.values[2])       // ERROR, writeonly
        ++f;
    if (f >= wo.values[2])       // ERROR, writeonly
        ++f;
    f = vec3(wo.values[2]).x;    // ERROR, writeonly
    ~wo.value;                   // ERROR, writeonly
    wo.values[2] = 3.4;
}

buffer multioblock
{
    readonly int value;
    writeonly float values[];
} multio;

void foomultio()
{
    float g;
    g = wo.values[2];            // ERROR, writeonly
    ~wo.value;
    wo.values[2] = 3.4;
    wo.value = 2;                // ERROR, readonly
}

in inb {     // ERROR
    int a;
} inbi;

out outb {     // ERROR
    int a;
} outbi;

float t__;  // ERROR, no __ until revision 310

    // ERROR, no __ until revision 310
#define __D

shared vec4 arr[2][3][4];

void devi()
{
    gl_DeviceIndex; // ERROR, no extension
    gl_ViewIndex;   // ERROR, never this stage
}

#ifdef GL_EXT_device_group
#extension GL_EXT_device_group : enable
#endif

void devie()
{
    gl_DeviceIndex;
    gl_ViewIndex;   // ERROR, never this stage
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.frag]=[
#version 310 es
highp float nodef3(float); // ERROR, no default precision
precision mediump float;
precision highp usampler2D;
precision highp sampler2D;
precision highp isampler2DArray;

layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR, not supported

layout(location = 2) in vec3 v3;
layout(location = 2) in mat4 yi;  // ERROR, locations conflict with xi

uniform sampler2D arrayedSampler[5];
uniform usampler2D usamp2d;
uniform usampler2DRect samp2dr;      // ERROR, reserved
uniform isampler2DArray isamp2DA;

in vec2 c2D;
uniform int i;

void main()
{
    vec4 v = texture(arrayedSampler[i], c2D);  // ERROR

    ivec2 offsets[4];
    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));
    uvec4 uv4 = textureGatherOffsets(samp2dr, c2D, offsets, 2);  // ERROR, not supported
    vec4 v4 = textureGather(arrayedSampler[0], c2D);
    ivec4 iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 3);
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), i);  // ERROR, last argument not const
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 4);  // ERROR, last argument out of range
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 1+2);
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(0.5));
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(i));     // ERROR, offset not constant
}

out vec4 outp;
void foo23()
{
    const ivec2[3] offsets = ivec2[3](ivec2(1,2), ivec2(3,4), ivec2(15,16));

    textureProjGradOffset(usamp2d, outp, vec2(0.0), vec2(0.0), ivec2(c2D));     // ERROR, offset not constant
    textureProjGradOffset(usamp2d, outp, vec2(0.0), vec2(0.0), offsets[1]);
    textureProjGradOffset(usamp2d, outp, vec2(0.0), vec2(0.0), offsets[2]);     // ERROR, offset out of range
    textureProjGradOffset(usamp2d, outp, vec2(0.0), vec2(0.0), ivec2(-10, 20)); // ERROR, offset out of range

    if (gl_HelperInvocation)
        ++outp;

    int sum = gl_MaxVertexImageUniforms +
              gl_MaxFragmentImageUniforms +
              gl_MaxComputeImageUniforms +
              gl_MaxCombinedImageUniforms +
              gl_MaxCombinedShaderOutputResources;

    bool b1, b2, b3, b;

    b1 = mix(b2, b3, b);
    uvec3 um3 = mix(uvec3(i), uvec3(i), bvec3(b));
    ivec4 im4 = mix(ivec4(i), ivec4(i), bvec4(b));
    1 << mix(1u, 1u, false);  // does not require folding
}
layout(binding=3) uniform sampler2D s1;
layout(binding=3) uniform sampler2D s2; // ERROR: overlapping bindings?  Don't see that in the 310 spec.
highp layout(binding=2) uniform writeonly image2D      i2D;
      layout(binding=4) uniform readonly  image3D      i3D;    // ERROR, no default precision
      layout(binding=5) uniform           imageCube    iCube;  // ERROR, no default precision
      layout(binding=6) uniform           image2DArray i2DA;   // ERROR, no default precision
      layout(binding=6) uniform coherent volatile restrict image2D i2Dqualified;    // ERROR, no default precision

layout(binding = 1) uniform bb {
    int foo;
    layout(binding = 2) float f;     // ERROR
} bbi;

in centroid vec4 centroidIn;
layout(location = 200000) uniform vec4 bigl;  // ERROR, location too big

layout(early_fragment_tests) in;

layout(location = 40) out vec4 bigout1;  // ERROR, too big
layout(location = 40) out vec4 bigout2;  // ERROR, overlap
layout(location = -2) out vec4 neg;      // ERROR, negative

layout(std430) buffer b430 {
    int i;
} b430i;

layout(shared) uniform bshar {
    int i;
} bshari;

in smooth vec4 smoothIn;
in flat int flatIn;

uniform sampler2DMS s2dms;  // ERROR, no default precision qualifier

void foots()
{
    highp ivec2 v2 = textureSize(s1, 2);
    highp ivec3 v3 = textureSize(isamp2DA, 3);
    v2 = textureSize(s2dms);
    v2 = imageSize(i2D);
    v3 = imageSize(i3D);
    v2 = imageSize(iCube);
    v3 = imageSize(i2DA);
    v2 = imageSize(i2Dqualified);
}

out bool bout;          // ERROR
highp out image2D imageOut;   // ERROR
out mat2x3 mout;        // ERROR

in bool inb;         // ERROR
in sampler2D ino;    // ERROR
in float ina[4];
in float inaa[4][2]; // ERROR
struct S { float f; };
in S ins;
in S[4] inasa;       // ERROR
in S insa[4];        // ERROR
struct SA { float f[4]; };
in SA inSA;          // ERROR
struct SS { float f; S s; };
in SS inSS;          // ERROR

#ifndef GL_EXT_shader_io_blocks
#error GL_EXT_shader_io_blocks not defined
#endif

#extension GL_EXT_shader_io_blocks : enable

out outbname { int a; } outbinst;   // ERROR, not out block in fragment shader

in inbname {
    int a;
    vec4 v;
    struct { int b; } s;     // ERROR, nested struct definition
} inbinst;

in inbname2 {
    layout(location = 12) int aAnon;
    layout(location = 13) centroid in vec4 vAnon;
};

in layout(location = 13) vec4 aliased; // ERROR, aliased

in inbname2 {                // ERROR, reuse of block name
    int aAnon;
    centroid in vec4 vAnon;
};

in badmember {               // ERROR, aAnon already in global scope
    int aAnon;
};

int inbname;                 // ERROR, redefinition of block name

vec4 vAnon;                  // ERROR, anon in global scope; redefinition

in arrayed {
    float f;
} arrayedInst[4];

void fooIO()
{
    vec4 v = inbinst.v + vAnon;
    v *= arrayedInst[2].f;
    v *= arrayedInst[i].f;
}

in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR, non-ES

layout(early_fragment_tests) in;
out float gl_FragDepth;
layout(depth_any) out float gl_FragDepth;  // ERROR, non-ES

void foo_IO()
{
    gl_FragDepth = 0.2;  // ERROR, early_fragment_tests declared
    gl_Layer;            // ERROR, not present
    gl_PrimitiveID;      // ERROR, not present
    bool f = gl_FrontFacing;
}

out float gl_FragDepth;

#extension GL_OES_geometry_shader : enable

void foo_GS()
{
    highp int l = gl_Layer;
    highp int p = gl_PrimitiveID;
}

in vec2 inf, ing;
uniform ivec2 offsets[4];
uniform sampler2D sArray[4];
uniform int sIndex;
layout(binding = 0) uniform atomic_uint auArray[2];
uniform ubName { int i; } ubInst[4];
buffer bbName { int i; } bbInst[4];
highp uniform writeonly image2D iArray[5];
const ivec2 constOffsets[4] = ivec2[4](ivec2(0.1), ivec2(0.2), ivec2(0.3), ivec2(0.4));

void pfooBad()
{
    precise vec2 h;                                            // ERROR reserved
    h = fma(inf, ing, h);                                      // ERROR, not available
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));     // ERROR, offset not constant
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);  // ERROR, not available
}

#extension GL_OES_gpu_shader5 : enable

void pfoo()
{
    precise vec2 h;
    h = fma(inf, ing, h);
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);
    textureGatherOffsets(sArray[0], vec2(0.1), offsets);       // ERROR, offset not constant
}

#extension GL_EXT_texture_cube_map_array : enable

precision highp imageCubeArray        ;
precision highp iimageCubeArray       ;
precision highp uimageCubeArray       ;

precision highp samplerCubeArray      ;
precision highp samplerCubeArrayShadow;
precision highp isamplerCubeArray     ;
precision highp usamplerCubeArray     ;

uniform writeonly imageCubeArray  CA1;
uniform writeonly iimageCubeArray CA2;
uniform writeonly uimageCubeArray CA3;

#ifdef GL_EXT_texture_cube_map_array
uniform samplerCubeArray          CA4;
uniform samplerCubeArrayShadow    CA5;
uniform isamplerCubeArray         CA6;
uniform usamplerCubeArray         CA7;
#endif

void CAT()
{
    highp vec4 b4 = texture(CA4, vec4(0.5), 0.24);
    highp ivec4 b6 = texture(CA6, vec4(0.5), 0.26);
    highp uvec4 b7 = texture(CA7, vec4(0.5), 0.27);
}

void badSample()
{
    lowp     int  a1 = gl_SampleID;         // ERROR, need extension
    mediump  vec2 a2 = gl_SamplePosition;   // ERROR, need extension
    highp    int  a3 = gl_SampleMaskIn[0];  // ERROR, need extension
    gl_SampleMask[0] = a3;                  // ERROR, need extension
    mediump int n = gl_NumSamples;          // ERROR, need extension
}

#ifdef GL_OES_sample_variables
#extension GL_OES_sample_variables : enable
#endif

void goodSample()
{
    lowp     int  a1 = gl_SampleID;       
    mediump  vec2 a2 = gl_SamplePosition; 
    highp    int  a3 = gl_SampleMaskIn[0];
    gl_SampleMask[0] = a3;
    mediump int n1 = gl_MaxSamples;
    mediump int n2 = gl_NumSamples;
}

uniform layout(r32f)  highp  image2D im2Df;
uniform layout(r32ui) highp uimage2D im2Du;
uniform layout(r32i)  highp iimage2D im2Di;
uniform ivec2 P;

void badImageAtom()
{
    float datf;
    int dati;
    uint datu;

    imageAtomicAdd(     im2Di, P, dati);        // ERROR, need extension
    imageAtomicAdd(     im2Du, P, datu);        // ERROR, need extension
    imageAtomicMin(     im2Di, P, dati);        // ERROR, need extension
    imageAtomicMin(     im2Du, P, datu);        // ERROR, need extension
    imageAtomicMax(     im2Di, P, dati);        // ERROR, need extension
    imageAtomicMax(     im2Du, P, datu);        // ERROR, need extension
    imageAtomicAnd(     im2Di, P, dati);        // ERROR, need extension
    imageAtomicAnd(     im2Du, P, datu);        // ERROR, need extension
    imageAtomicOr(      im2Di, P, dati);        // ERROR, need extension
    imageAtomicOr(      im2Du, P, datu);        // ERROR, need extension
    imageAtomicXor(     im2Di, P, dati);        // ERROR, need extension
    imageAtomicXor(     im2Du, P, datu);        // ERROR, need extension
    imageAtomicExchange(im2Di, P, dati);        // ERROR, need extension
    imageAtomicExchange(im2Du, P, datu);        // ERROR, need extension
    imageAtomicExchange(im2Df, P, datf);        // ERROR, need extension
    imageAtomicCompSwap(im2Di, P,  3, dati);    // ERROR, need extension
    imageAtomicCompSwap(im2Du, P, 5u, datu);    // ERROR, need extension
}

#ifdef GL_OES_shader_image_atomic 
#extension GL_OES_shader_image_atomic : enable
#endif

uniform layout(rgba32f)  highp  image2D badIm2Df;  // ERROR, needs readonly or writeonly
uniform layout(rgba8ui) highp uimage2D badIm2Du;   // ERROR, needs readonly or writeonly
uniform layout(rgba16i)  highp iimage2D badIm2Di;  // ERROR, needs readonly or writeonly

void goodImageAtom()
{
    float datf;
    int dati;
    uint datu;

    imageAtomicAdd(     im2Di, P, dati);
    imageAtomicAdd(     im2Du, P, datu);
    imageAtomicMin(     im2Di, P, dati);
    imageAtomicMin(     im2Du, P, datu);
    imageAtomicMax(     im2Di, P, dati);
    imageAtomicMax(     im2Du, P, datu);
    imageAtomicAnd(     im2Di, P, dati);
    imageAtomicAnd(     im2Du, P, datu);
    imageAtomicOr(      im2Di, P, dati);
    imageAtomicOr(      im2Du, P, datu);
    imageAtomicXor(     im2Di, P, dati);
    imageAtomicXor(     im2Du, P, datu);
    imageAtomicExchange(im2Di, P, dati);
    imageAtomicExchange(im2Du, P, datu);
    imageAtomicExchange(im2Df, P, datf);
    imageAtomicCompSwap(im2Di, P,  3, dati);
    imageAtomicCompSwap(im2Du, P, 5u, datu);

    imageAtomicMax(badIm2Di, P, dati);      // ERROR, not an allowed layout() on the image
    imageAtomicMax(badIm2Du, P, datu);      // ERROR, not an allowed layout() on the image
    imageAtomicExchange(badIm2Df, P, datf); // ERROR, not an allowed layout() on the image
}

sample in vec4 colorSampInBad;       // ERROR, reserved
centroid out vec4 colorCentroidBad;  // ERROR
flat out vec4 colorBadFlat;          // ERROR
smooth out vec4 colorBadSmooth;      // ERROR
noperspective out vec4 colorBadNo;   // ERROR
flat centroid in vec2 colorfc;
in float scalarIn;

void badInterp()
{
    interpolateAtCentroid(colorfc);             // ERROR, need extension
    interpolateAtSample(colorfc, 1);            // ERROR, need extension
    interpolateAtOffset(colorfc, vec2(0.2));    // ERROR, need extension
}

#if defined GL_OES_shader_multisample_interpolation
#extension GL_OES_shader_multisample_interpolation : enable
#endif

sample in vec4 colorSampIn;
sample out vec4 colorSampleBad;     // ERROR
flat sample in vec4 colorfsi;
sample in vec3 sampInArray[4];

void interp()
{
    float res;
    vec2 res2;
    vec3 res3;
    vec4 res4;

    res2 = interpolateAtCentroid(colorfc);
    res4 = interpolateAtCentroid(colorSampIn);
    res4 = interpolateAtCentroid(colorfsi);
    res  = interpolateAtCentroid(scalarIn);
    res3 = interpolateAtCentroid(sampInArray);         // ERROR
    res3 = interpolateAtCentroid(sampInArray[2]);
    res2 = interpolateAtCentroid(sampInArray[2].xy);   // ERROR

    res3 = interpolateAtSample(sampInArray, 1);        // ERROR
    res3 = interpolateAtSample(sampInArray[i], 0);
    res2 = interpolateAtSample(sampInArray[2].xy, 2);  // ERROR
    res  = interpolateAtSample(scalarIn, 1);

    res3 = interpolateAtOffset(sampInArray, vec2(0.2));         // ERROR
    res3 = interpolateAtOffset(sampInArray[2], vec2(0.2));
    res2 = interpolateAtOffset(sampInArray[2].xy, vec2(0.2));   // ERROR, no swizzle
    res  = interpolateAtOffset(scalarIn + scalarIn, vec2(0.2)); // ERROR, no binary ops other than dereference
    res  = interpolateAtOffset(scalarIn, vec2(0.2));

    float f;
    res  = interpolateAtCentroid(f);           // ERROR, not interpolant
    res4 = interpolateAtSample(outp, 0);       // ERROR, not interpolant
}

layout(blend_support_softlight) out;           // ERROR, need extension

#ifdef GL_KHR_blend_equation_advanced
#extension GL_KHR_blend_equation_advanced : enable
#endif

layout(blend_support_multiply) out;
layout(blend_support_screen) out;
layout(blend_support_overlay) out;
layout(blend_support_darken, blend_support_lighten) out;
layout(blend_support_colordodge) layout(blend_support_colorburn) out;
layout(blend_support_hardlight) out;
layout(blend_support_softlight) out;
layout(blend_support_difference) out;
layout(blend_support_exclusion) out;
layout(blend_support_hsl_hue) out;
layout(blend_support_hsl_saturation) out;
layout(blend_support_hsl_color) out;
layout(blend_support_hsl_luminosity) out;
layout(blend_support_all_equations) out;

layout(blend_support_hsl_luminosity) out;              // okay to repeat

layout(blend_support_hsl_luminosity) in;                       // ERROR, only on "out"
layout(blend_support_hsl_luminosity) out vec4;                 // ERROR, only on standalone
layout(blend_support_hsl_luminosity) out vec4 badout;          // ERROR, only on standalone
layout(blend_support_hsl_luminosity) struct badS {int i;};     // ERROR, only on standalone
layout(blend_support_hsl_luminosity) void blendFoo() { }       // ERROR, only on standalone
void blendFoo(layout(blend_support_hsl_luminosity) vec3 v) { } // ERROR, only on standalone
layout(blend_support_flizbit) out;                             // ERROR, no flizbit

out vec4 outAA[2][2];  // ERROR

void devi()
{
    gl_DeviceIndex; // ERROR, no extension
    gl_ViewIndex;   // ERROR, no extension
}

#ifdef GL_EXT_device_group
#extension GL_EXT_device_group : enable
#endif

#ifdef GL_EXT_multiview
#extension GL_EXT_multiview : enable
#endif

void devie()
{
    gl_DeviceIndex;
    gl_ViewIndex;
}

#extension GL_EXT_shader_implicit_conversions : enable

// Test function overloading
void func(uint a, uvec4 b)
{

}

int func(uint a, uvec4 b) // Error function overloading because of same signature and different return type
{
    return 0;
}

int b;

void testimplicit() {

    uint a = b; // int->uint
    mediump vec4 col = vec4(1, 2, 3, 4); // ivec4 -> vec4
    int  b = a + 2; // ERROR: cannot convert from ' temp uint' to ' temp int'

    // Test binary ops
    uint c = b * 3; 
    uint d = b * 3u;
    uint e = b%3;
    uint f = (b > 3)? b : c;     
    func(b, ivec4(1,2,3,4)); 
}

#extension GL_EXT_shader_implicit_conversions : disable

void testimplicitFail() {
    uint a = b; // Error GL_EXT_shader_implicit_conversions is disabled
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.geom]=[
#version 310 es

#ifdef GL_EXT_geometry_shader
#extension GL_EXT_geometry_shader : enable
#else
#error no GL_EXT_geometry_shader 
#endif

#ifndef GL_OES_geometry_shader
#error no GL_OES_geometry_shader
#endif

precision mediump float;

in fromVertex {
    in vec3 color;
} fromV[];

in vec4 nonBlockUnsized[];

out toFragment {
    out vec3 color;
} toF;

out fromVertex {  // okay to reuse a block name for another block name
    vec3 color;
};

out fooB {        // ERROR, cannot reuse block name as block instance
    vec2 color;
} fromVertex;

int fromVertex;   // ERROR, cannot reuse a block name for something else

out fooC {        // ERROR, cannot have same name for block and instance name
    vec2 color;
} fooC;

void main()
{
    EmitVertex();
    EndPrimitive();
    EmitStreamVertex(1);    // ERROR
    EndStreamPrimitive(0);  // ERROR

    color = fromV[0].color;
    gl_ClipDistance[3] =              // ERROR, no ClipDistance
        gl_in[1].gl_ClipDistance[2];  // ERROR, no ClipDistance
    gl_Position = gl_in[0].gl_Position;

    gl_PrimitiveID = gl_PrimitiveIDIn;
    gl_Layer = 2;
}

layout(stream = 4) out vec4 ov4; // ERROR, no streams

layout(line_strip, points, triangle_strip, points, triangle_strip) out;  // just means triangle_strip"

out ooutb { vec4 a; } ouuaa6;

layout(max_vertices = 200) out;
layout(max_vertices = 300) out;   // ERROR, too big
void foo(layout(max_vertices = 4) int a)  // ERROR
{
    ouuaa6.a = vec4(1.0);
}

layout(line_strip, points, triangle_strip, points) out;  // ERROR, changing output primitive
layout(line_strip, points) out; // ERROR, changing output primitive
layout(triangle_strip) in; // ERROR, not an input primitive
layout(triangle_strip) uniform; // ERROR
layout(triangle_strip) out vec4 badv4;  // ERROR, not on a variable
layout(triangle_strip) in vec4 bad2v4[];  // ERROR, not on a variable or input
layout(invocations = 3) out outbn { int a; }; // 2 ERROR, not on a block, not until 4.0
out outbn2 {
    layout(invocations = 3)  int a; // 2 ERRORs, not on a block member, not until 4.0
    layout(max_vertices = 3) int b; // ERROR, not on a block member
    layout(triangle_strip)   int c; // ERROR, not on a block member
} outbi;

layout(lines) out;  // ERROR, not on output
layout(lines_adjacency) in;
layout(triangles) in;             // ERROR, can't change it
layout(triangles_adjacency) in;   // ERROR, can't change it
layout(invocations = 4) in;

in sameName {
    int a15;
} insn[];

out sameName {
    float f15;
};

uniform sameName {
    bool b15;
};

const int summ = gl_MaxVertexAttribs +
             gl_MaxGeometryInputComponents +
             gl_MaxGeometryOutputComponents +
             gl_MaxGeometryImageUniforms +
             gl_MaxGeometryTextureImageUnits +
             gl_MaxGeometryOutputVertices +
             gl_MaxGeometryTotalOutputComponents +
             gl_MaxGeometryUniformComponents +
             gl_MaxGeometryAtomicCounters +
             gl_MaxGeometryAtomicCounterBuffers +
             gl_MaxVertexTextureImageUnits +
             gl_MaxCombinedTextureImageUnits +
             gl_MaxTextureImageUnits +
             gl_MaxDrawBuffers;

void fooe1()
{
    gl_ViewportIndex;  // ERROR, not in ES
    gl_MaxViewports;   // ERROR, not in ES
    insn.length();     // 4: lines_adjacency
    int inv = gl_InvocationID;
}

in vec4 explArray[4];
in vec4 explArrayBad[5];  // ERROR, wrong size
in vec4 nonArrayed;       // ERROR, not an array
flat out vec3 myColor1;
centroid out vec3 myColor2;
centroid in vec3 centr[];
sample out vec4 perSampleColor;  // ERROR without sample extensions

layout(max_vertices = 200) out;  // matching redecl

layout(location = 7, component = 2) in float comp[];  // ERROR, es has no component

void notHere()
{
    gl_MaxGeometryVaryingComponents;  // ERROR, not in ES
    gl_VerticesIn;                    // ERROR, not in ES
}

void pointSize1()
{
    highp float ps = gl_in[3].gl_PointSize;  // ERROR, need point_size extension
    gl_PointSize = ps;                       // ERROR, need point_size extension
}

#extension GL_OES_geometry_point_size : enable

void pointSize2()
{
    highp float ps = gl_in[3].gl_PointSize;
    gl_PointSize = ps;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.inheritMemory.frag]=[
#version 310 es
precision mediump float;

struct S {
    float buff[10];
};

layout(std430, binding=2) readonly buffer RoBuff {
    float buff_ro[10];
    S s_ro;
} ro_buffer;

layout(std430, binding=2) buffer Buff {
    float buff[10];
    S s;
} non_ro_buffer;

void non_ro_fun(float[10] buff) { }
void non_ro_funf(float el) { }
void non_ro_funS(S s) { }

out vec4 fragColor;

void main()
{
    S s;

    non_ro_fun(s.buff);
    non_ro_funf(s.buff[3]);
    non_ro_funS(s);

    non_ro_fun(non_ro_buffer.buff);
    non_ro_fun(non_ro_buffer.s.buff);
    non_ro_funf(non_ro_buffer.buff[3]);
    non_ro_funf(non_ro_buffer.s.buff[3]);
    non_ro_funS(non_ro_buffer.s);

    non_ro_fun(ro_buffer.buff_ro);
    non_ro_fun(ro_buffer.s_ro.buff);
    non_ro_funf(ro_buffer.buff_ro[3]);
    non_ro_funf(ro_buffer.s_ro.buff[3]);
    non_ro_funS(ro_buffer.s_ro);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.tesc]=[
#version 310 es

#extension GL_OES_tessellation_shader : enable

layout(vertices = 4) out;
out int outa[gl_out.length()];

layout(quads) in;                   // ERROR
layout(ccw) out;                    // ERROR
layout(fractional_even_spacing) in; // ERROR

patch in vec4 patchIn;              // ERROR
patch out vec4 patchOut;

void main()
{
    barrier();

    int a = gl_MaxTessControlInputComponents +
            gl_MaxTessControlOutputComponents +
            gl_MaxTessControlTextureImageUnits +
            gl_MaxTessControlUniformComponents +
            gl_MaxTessControlTotalOutputComponents;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;        // ERROR, need point_size extension
    float cd = gl_in[1].gl_ClipDistance[2];  // ERROR, not in ES

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;        // ERROR, need point_size extension
    gl_out[gl_InvocationID].gl_ClipDistance[1] = cd;  // ERROR, not in ES

    gl_TessLevelOuter[3] = 3.2;
    gl_TessLevelInner[1] = 1.3;

    if (a > 10)
        barrier();           // ERROR
    else
        barrier();           // ERROR

    barrier();

    do {
        barrier();           // ERROR
    } while (a > 10);

    switch (a) {
    default:
        barrier();           // ERROR
        break;
    }
    a < 12 ? a : (barrier(), a); // ERROR
    {
        barrier();
    }

    return;

    barrier();               // ERROR
}

layout(vertices = 4) in;    // ERROR, not on in
layout(vertices = 5) out;   // ERROR, changing #

void foo()
{
    gl_out[4].gl_Position;  // ERROR, out of range

    barrier();              // ERROR, not in main
}

in vec2 ina;                // ERROR, not array
in vec2 inb[];
in vec2 inc[18];            // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];
patch out float implA[];    // ERROR, not sized

#extension GL_ARB_separate_shader_objects : enable

layout(location = 3) in vec4 ivla[];
layout(location = 4) in vec4 ivlb[];
layout(location = 4) in vec4 ivlc[];  // ERROR, overlapping

layout(location = 3) out vec4 ovla[];
layout(location = 4) out vec4 ovlb[];
layout(location = 4) out vec4 ovlc[];  // ERROR, overlapping

void foop()
{
    precise float d;                  // ERROR without gpu_shader5
    d = fma(d, d, d);                 // ERROR without gpu_shader5
}

patch out pinbn {
    int a;
} pinbi;

centroid out vec3 myColor2[];
centroid in vec3 centr[];
sample out vec4 perSampleColor[];   // ERROR without sample extensions

layout(vertices = 4) out float badlay[];   // ERROR, not on a variable
out float misSized[5];              // ERROR, size doesn't match
out float okaySize[4];

#extension GL_OES_tessellation_point_size : enable

void pointSize2()
{
    float ps = gl_in[1].gl_PointSize;
    gl_out[gl_InvocationID].gl_PointSize = ps;
}

#extension GL_OES_gpu_shader5 : enable

precise vec3 pv3;

void goodfoop()
{
    precise float d;

    pv3 *= pv3;
    pv3 = fma(pv3, pv3, pv3);
    d = fma(d, d, d);
}

void bbextBad()
{
    gl_BoundingBoxEXT;  // ERROR without GL_EXT_primitive_bounding_box
    gl_BoundingBox;  // ERROR, version < 320
}

#extension GL_EXT_primitive_bounding_box : enable

void bbext()
{
    gl_BoundingBoxEXT[0] = vec4(0.0);
    gl_BoundingBoxEXT[1] = vec4(1.0);
    gl_BoundingBoxEXT[2] = vec4(2.0);  // ERROR, overflow
}

void bbBad()
{
    gl_BoundingBoxOES;  // ERROR without GL_OES_primitive_bounding_box 
}

#extension GL_OES_primitive_bounding_box : enable

void bb()
{
    gl_BoundingBoxOES[0] = vec4(0.0);
    gl_BoundingBoxOES[1] = vec4(1.0);
    gl_BoundingBoxOES[2] = vec4(2.0);  // ERROR, overflow
}

out patch badpatchBName {  // ERROR, array size required
    float f;
} badpatchIName[];

out patch patchBName {
    float f;
} patchIName[4];

void outputtingOutparam(out int a)
{
    a = 2;
}

void outputting()
{
    outa[gl_InvocationID] = 2;
    outa[1] = 2;                         // ERROR, not gl_InvocationID
    gl_out[0].gl_Position = vec4(1.0);   // ERROR, not gl_InvocationID
    outa[1];
    gl_out[0];
    outputtingOutparam(outa[0]);         // ERROR, not gl_InvocationID
    outputtingOutparam(outa[gl_InvocationID]);
    patchIName[1].f = 3.14;
    outa[(gl_InvocationID)] = 2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.tese]=[
#version 310 es

#extension GL_EXT_tessellation_shader : enable
#extension GL_OES_tessellation_shader : enable
#extension GL_EXT_tessellation_shader : disable

layout(vertices = 4) out; // ERROR
layout(quads, cw) in;
layout(triangles) in;     // ERROR
layout(isolines) in;      // ERROR

layout(ccw) in;           // ERROR
layout(cw) in;

layout(fractional_odd_spacing) in;    
layout(equal_spacing) in;              // ERROR
layout(fractional_even_spacing) in;    // ERROR

layout(point_mode) in;

patch in vec4 patchIn;
patch out vec4 patchOut;  // ERROR

void main()
{
    barrier(); // ERROR

    int a = gl_MaxTessEvaluationInputComponents +
            gl_MaxTessEvaluationOutputComponents +
            gl_MaxTessEvaluationTextureImageUnits +
            gl_MaxTessEvaluationUniformComponents +
            gl_MaxTessPatchComponents +
            gl_MaxPatchVertices +
            gl_MaxTessGenLevel;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;        // ERROR, need point_size extension
    float cd = gl_in[1].gl_ClipDistance[2];  // ERROR, not in ES

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    vec3 tc = gl_TessCoord;
    float tlo = gl_TessLevelOuter[3];
    float tli = gl_TessLevelInner[1];

    gl_Position = p;
    gl_PointSize = ps;             // ERROR, need point_size extension
    gl_ClipDistance[2] = cd;       // ERROR, not in ES
}

smooth patch in vec4 badp1;         // ERROR
flat patch in vec4 badp2;           // ERROR
noperspective patch in vec4 badp3;  // ERROR
patch sample in vec3 badp4;         // ERROR

#extension GL_ARB_separate_shader_objects : enable

in gl_PerVertex
{
    vec4 gl_Position;
} gl_in[];

in gl_PerVertex           // ERROR, second redeclaration of gl_in
{
    vec4 gl_Position;
} gl_in[];

layout(quads, cw) out;     // ERROR
layout(triangles) out;     // ERROR
layout(isolines) out;      // ERROR
layout(cw) out;            // ERROR
layout(fractional_odd_spacing) out;    // ERROR
layout(equal_spacing) out;             // ERROR
layout(fractional_even_spacing) out;   // ERROR
layout(point_mode) out;                // ERROR

in vec2 ina;      // ERROR, not array
in vec2 inb[];
in vec2 inc[18];  // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];

in testbla {      // ERROR, not array
    int f;
} bla;

in testblb {
    int f;
} blb[];

in testblc { // ERROR wrong size
    int f;
} blc[18];

in testbld {
    int f;
} bld[gl_MaxPatchVertices];

layout(location = 23) in vec4 ivla[];
layout(location = 24) in vec4 ivlb[];
layout(location = 24) in vec4 ivlc[];  // ERROR, overlap

layout(location = 23) out vec4 ovla[2];
layout(location = 24) out vec4 ovlb[2];  // ERROR, overlap

in float gl_TessLevelOuter[4];           // ERROR, can't redeclare

patch in pinbn {
    int a;
} pinbi;

centroid out vec3 myColor2;
centroid in vec3 centr[];
sample out vec4 perSampleColor;  // ERROR without sample extensions

#extension GL_OES_tessellation_point_size : enable

void pointSize2()
{
    float ps = gl_in[1].gl_PointSize;  // ERROR, not in the redeclaration, but no error on use of gl_PointSize
    gl_PointSize = ps;
}

#extension GL_EXT_primitive_bounding_box : enable

void bbbad()
{
    gl_BoundingBoxOES; // ERROR, wrong stage
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310.vert]=[
#version 310 es

shared vec4 s;   // ERROR
layout(local_size_x = 2) out;  // ERROR
buffer vec4 v;  // ERROR
in int ini;
layout(location = 2) uniform mat4 x;
layout(location = 3) uniform mat4 y;
layout(location = 2) out mat4 xi;
layout(location = 3) out mat4 yi;  // ERROR, locations conflict with xi

void main()
{
    uvec2 u2;
    u2 = uaddCarry(u2, u2, u2);
    uint u1;
    u1 = usubBorrow(u1, u1, u1);
    uvec4 u4;
    umulExtended(u4, u4, u4, u4);
    ivec4 i4;
    imulExtended(i4, i4, i4, i4);
    int i1;
    i1 = bitfieldExtract(i1, 4, 5);
    uvec3 u3;
    u3 = bitfieldExtract(u3, 4, 5);
    ivec3 i3;
    i3 = bitfieldInsert(i3, i3, 4, 5);
    u1 = bitfieldInsert(u1, u1, 4, 5);
    ivec2 i2;
    i2 = bitfieldReverse(i2);
    u4 = bitfieldReverse(u4);
    i1 = bitCount(i1);
    i3 = bitCount(u3);
    i2 = findLSB(i2);
    i4 = findLSB(u4);
    i1 = findMSB(i1);
    i2 = findMSB(u2);

    vec3 v3;
    v3 = frexp(v3, i3);
    vec2 v2;
    v2 = ldexp(v2, i2);

    mediump vec4 v4;
    u1 = packUnorm4x8(v4);
    u1 = packSnorm4x8(v4);
    v4 = unpackUnorm4x8(u1);
    v4 = unpackSnorm4x8(u1);
}

precision highp sampler2DMS;
precision highp isampler2DMS;
precision highp usampler2DMS;

uniform sampler2DMS s2dms;
uniform isampler2DMS is2dms;
uniform usampler2DMS us2dms;
uniform usampler2DMSArray us2dmsa;   // ERROR

void foo()
{
    ivec2 v2;
    v2 = textureSize(s2dms);
    v2 = textureSize(us2dms);
    vec4 v4 = texelFetch(s2dms, v2, 2);
    ivec4 iv4 = texelFetch(is2dms, v2, 2);
    textureSamples(s2dms);   // ERROR
    float f;
    frexp(f, ini);     // ERROR, i not writable
}

out bool outb;         // ERROR
out sampler2D outo;    // ERROR
out float outa[4];
out float outaa[4][2]; // ERROR
struct S { float f; };
out S outs;
out S[4] outasa;       // ERROR
out S outsa[4];        // ERROR
struct SA { float f[4]; };
out SA outSA;          // ERROR
struct SS { float f; S s; };
out SS outSS;          // ERROR

layout(std430) uniform U430 { int a; } U430i;    // ERROR
layout(std430) buffer B430 { int a; } B430i;

#ifndef GL_OES_shader_io_blocks
#error GL_OES_shader_io_blocks not defined
#endif

#extension GL_OES_shader_io_blocks : enable

out outbname {
    int a;
    out vec4 v;
    highp sampler2D s;   // ERROR, opaque type
} outbinst;

out outbname2 {
    layout(location = 12) int aAnon;
    layout(location = 13) vec4 vAnon;
};

layout(location = 12) out highp int aliased;  // ERROR, aliasing location

in inbname { int a; } inbinst;  // ERROR, no in block in vertex shader

out gl_PerVertex {              // ERROR, has extra member
    highp vec4 gl_Position;
    highp vec4 t;
};

void foo_IO()
{
    int sum  = gl_VertexID +
               gl_InstanceID;
    gl_Position = vec4(1.0);
    gl_PointSize = 2.0;         // ERROR, removed by redeclaration
}

out gl_PerVertex {              // ERROR, already used and already redeclared
    highp vec4 gl_Position;
    highp vec4 t;
};

smooth out smo {                // ERROR, no smooth on a block
    int i;
} smon;

flat out fmo {                  // ERROR, no flat on a block
    int i;
} fmon;

centroid out cmo {              // ERROR, no centroid on a block
    int i;
} cmon;

invariant out imo {             // ERROR, no invariant on a block
    int i;
} imon;

in vec2 inf, ing;
uniform ivec2 offsets[4];
uniform sampler2D sArray[4];
uniform int sIndex;
layout(binding = 0) uniform atomic_uint auArray[2];
uniform ubName { int i; } ubInst[4];
buffer bbName { int i; } bbInst[4];
highp uniform writeonly image2D iArray[5];
const ivec2 constOffsets[4] = ivec2[4](ivec2(0.1), ivec2(0.2), ivec2(0.3), ivec2(0.4));

void pfooBad()
{
    precise vec2 h;          // ERROR reserved
    h = fma(inf, ing, h);    // ERROR, not available
    sArray[sIndex + 1];      // ERRRO, not supported
    auArray[sIndex + 1];
    ubInst[1];
    bbInst[2];
    ubInst[sIndex + 1];      // ERROR, not supported
    bbInst[sIndex];          // ERROR, not supported
    iArray[2];
    iArray[sIndex * 2];      // ERROR, not supported
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));     // ERROR, offset not constant
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);  // ERROR, not available
}

#extension GL_OES_gpu_shader5 : enable

void pfoo()
{
    precise vec2 h;
    h = fma(inf, ing, h);
    sArray[sIndex + 1];
    ubInst[sIndex + 1];
    bbInst[sIndex - 2];      // ERROR, still not supported
    iArray[2];
    iArray[sIndex - 2];
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);
    textureGatherOffsets(sArray[0], vec2(0.1), offsets);   // ERROR, offset not constant
}

uniform samplerBuffer  badSamp1;             // ERROR, reserved
uniform isamplerBuffer badSamp2;             // ERROR, reserved
uniform usamplerBuffer badSamp3;             // ERROR, reserved
uniform writeonly imageBuffer    badSamp4;   // ERROR, reserved
uniform writeonly iimageBuffer   badSamp5;   // ERROR, reserved
uniform writeonly uimageBuffer   badSamp6;   // ERROR, reserved

#extension GL_OES_texture_buffer : enable
#extension GL_EXT_texture_buffer : enable

uniform samplerBuffer  noPreSamp1;            // ERROR, no default precision
uniform isamplerBuffer noPreSamp2;            // ERROR, no default precision
uniform usamplerBuffer noPreSamp3;            // ERROR, no default precision
uniform writeonly imageBuffer    noPreSamp4;  // ERROR, no default precision
uniform writeonly iimageBuffer   noPreSamp5;  // ERROR, no default precision
uniform writeonly uimageBuffer   noPreSamp6;  // ERROR, no default precision

precision highp samplerBuffer; 
precision highp isamplerBuffer;
precision highp usamplerBuffer;
precision highp imageBuffer;   
precision highp iimageBuffer;  
precision highp uimageBuffer;  

#ifdef GL_OES_texture_buffer
uniform samplerBuffer  bufSamp1;          
uniform isamplerBuffer bufSamp2;          
uniform usamplerBuffer bufSamp3;          
#endif
#ifdef GL_EXT_texture_buffer
uniform writeonly imageBuffer    bufSamp4;
uniform writeonly iimageBuffer   bufSamp5;
uniform writeonly uimageBuffer   bufSamp6;
#endif

void bufferT()
{
    highp int s1 = textureSize(bufSamp1);
    highp int s2 = textureSize(bufSamp2);
    highp int s3 = textureSize(bufSamp3);

    highp int s4 = imageSize(bufSamp4);
    highp int s5 = imageSize(bufSamp5);
    highp int s6 = imageSize(bufSamp6);
    
    highp vec4 f1 = texelFetch(bufSamp1, s1);
    highp ivec4 f2 = texelFetch(bufSamp2, s2);
    highp uvec4 f3 = texelFetch(bufSamp3, s3);
}

uniform writeonly imageCubeArray  badCA1;  // ERROR, reserved
uniform writeonly iimageCubeArray badCA2;  // ERROR, reserved
uniform writeonly uimageCubeArray badCA3;  // ERROR, reserved

uniform samplerCubeArray          badCA4;  // ERROR, reserved
uniform samplerCubeArrayShadow    badCA5;  // ERROR, reserved
uniform isamplerCubeArray         badCA6;  // ERROR, reserved
uniform usamplerCubeArray         badCA7;  // ERROR, reserved

#extension GL_OES_texture_cube_map_array : enable

uniform writeonly imageCubeArray  noPreCA1;   // ERROR, no default precision
uniform writeonly iimageCubeArray noPreCA2;   // ERROR, no default precision
uniform writeonly uimageCubeArray noPreCA3;   // ERROR, no default precision

uniform samplerCubeArray          noPreCA4;   // ERROR, no default precision
uniform samplerCubeArrayShadow    noPreCA5;   // ERROR, no default precision
uniform isamplerCubeArray         noPreCA6;   // ERROR, no default precision
uniform usamplerCubeArray         noPreCA7;   // ERROR, no default precision

precision highp imageCubeArray        ;
precision highp iimageCubeArray       ;
precision highp uimageCubeArray       ;

precision highp samplerCubeArray      ;
precision highp samplerCubeArrayShadow;
precision highp isamplerCubeArray     ;
precision highp usamplerCubeArray     ;

uniform writeonly imageCubeArray  CA1;
uniform writeonly iimageCubeArray CA2;
uniform writeonly uimageCubeArray CA3;

layout(rgba16f) uniform readonly imageCubeArray  rCA1;
layout(rgba32i) uniform readonly iimageCubeArray rCA2;
layout(r32ui) uniform readonly uimageCubeArray rCA3;

#ifdef GL_OES_texture_cube_map_array
uniform samplerCubeArray          CA4;
uniform samplerCubeArrayShadow    CA5;
uniform isamplerCubeArray         CA6;
uniform usamplerCubeArray         CA7;
#endif

void CAT()
{
    highp ivec3 s4 = textureSize(CA4, 1);
    highp ivec3 s5 = textureSize(CA5, 1);
    highp ivec3 s6 = textureSize(CA6, 1);
    highp ivec3 s7 = textureSize(CA7, 1);
    
    highp vec4 t4 = texture(CA4, vec4(0.5));
    highp float t5 = texture(CA5, vec4(0.5), 3.0);
    highp ivec4 t6 = texture(CA6, vec4(0.5));
    highp uvec4 t7 = texture(CA7, vec4(0.5));

    highp vec4 L4 = textureLod(CA4, vec4(0.5), 0.24);
    highp ivec4 L6 = textureLod(CA6, vec4(0.5), 0.26);
    highp uvec4 L7 = textureLod(CA7, vec4(0.5), 0.27);

    highp vec4 g4 = textureGrad(CA4, vec4(0.5), vec3(0.1), vec3(0.2));
    highp ivec4 g6 = textureGrad(CA6, vec4(0.5), vec3(0.1), vec3(0.2));
    highp uvec4 g7 = textureGrad(CA7, vec4(0.5), vec3(0.1), vec3(0.2));

    highp vec4 gath4 = textureGather(CA4, vec4(0.5));
    highp vec4 gathC4 = textureGather(CA4, vec4(0.5), 2);
    highp ivec4 gath6 = textureGather(CA6, vec4(0.5));
    highp ivec4 gathC6 = textureGather(CA6, vec4(0.5), 1);
    highp uvec4 gath7 = textureGather(CA7, vec4(0.5));
    highp uvec4 gathC7 = textureGather(CA7, vec4(0.5), 0);

    highp vec4 gath5 = textureGather(CA5, vec4(0.5), 2.5);

    highp ivec3 s1 = imageSize(CA1);
    highp ivec3 s2 = imageSize(CA2);
    highp ivec3 s3 = imageSize(CA3);

    imageStore(CA1, s3, vec4(1));
    imageStore(CA2, s3, ivec4(1));
    imageStore(CA3, s3, uvec4(1));

    highp vec4 cl1 = imageLoad(rCA1, s3);
    highp ivec4 cl2 = imageLoad(rCA2, s3);
    highp uvec4 cl3 = imageLoad(rCA3, s3);
}

uniform sampler2DMSArray  bad2DMS;    // ERROR, reserved
uniform isampler2DMSArray bad2DMSi;   // ERROR, reserved
uniform usampler2DMSArray bad2DMSu;   // ERROR, reserved

#extension GL_OES_texture_storage_multisample_2d_array : enable

#ifdef GL_OES_texture_storage_multisample_2d_array

uniform sampler2DMSArray  noPrec2DMS;    // ERROR, no default
uniform isampler2DMSArray noPrec2DMSi;   // ERROR, no default
uniform usampler2DMSArray noPrec2DMSu;   // ERROR, no default

#endif

precision highp sampler2DMSArray;
precision highp isampler2DMSArray;
precision highp usampler2DMSArray;

uniform sampler2DMSArray  samp2DMSA;
uniform isampler2DMSArray samp2DMSAi;
uniform usampler2DMSArray samp2DMSAu;

void MSA()
{
    vec4 tf = texelFetch(samp2DMSA, ivec3(5), 2);
    ivec4 tfi = texelFetch(samp2DMSAi, ivec3(5), 2);
    uvec4 tfu = texelFetch(samp2DMSAu, ivec3(5), 2);
    
    ivec3 tfs = textureSize(samp2DMSA);
    ivec3 tfsi = textureSize(samp2DMSAi);
    ivec3 tfsb = textureSize(samp2DMSAi, 4);  // ERROR, no lod
    ivec3 tfsu = textureSize(samp2DMSAu);
}

#ifdef GL_OES_shader_image_atomic 
#extension GL_OES_shader_image_atomic : enable
#endif

uniform layout(r32f)  highp  image2D im2Df;
uniform layout(r32ui) highp uimage2D im2Du;
uniform layout(r32i)  highp iimage2D im2Di;
uniform ivec2 P;

void goodImageAtom()
{
    float datf;
    int dati;
    uint datu;

    imageAtomicAdd(     im2Di, P, dati);
    imageAtomicAdd(     im2Du, P, datu);
    imageAtomicMin(     im2Di, P, dati);
    imageAtomicMin(     im2Du, P, datu);
    imageAtomicMax(     im2Di, P, dati);
    imageAtomicMax(     im2Du, P, datu);
    imageAtomicAnd(     im2Di, P, dati);
    imageAtomicAnd(     im2Du, P, datu);
    imageAtomicOr(      im2Di, P, dati);
    imageAtomicOr(      im2Du, P, datu);
    imageAtomicXor(     im2Di, P, dati);
    imageAtomicXor(     im2Du, P, datu);
    imageAtomicExchange(im2Di, P, dati);
    imageAtomicExchange(im2Du, P, datu);
    imageAtomicExchange(im2Df, P, datf);
    imageAtomicCompSwap(im2Di, P,  3, dati);
    imageAtomicCompSwap(im2Du, P, 5u, datu);
}

sample out vec4 colorSampInBad;       // ERROR, reserved

#extension GL_OES_shader_multisample_interpolation : enable

sample out vec4 colorSample;
flat sample out vec4 colorfsi;
sample out vec3 sampInArray[4];
in vec4 inv4;

void badInterp()
{
    interpolateAtCentroid(inv4);             // ERROR, wrong stage
    interpolateAtSample(inv4, 1);            // ERROR, need extension
    interpolateAtOffset(inv4, vec2(0.2));    // ERROR, need extension
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[310AofA.vert]=[
#version 310 es

// Check name mangling of functions with parameters that are multi-dimensional arrays.

#define NX 2
#define NY 3
#define NZ 4
void f(bool a, float b, uint[4] c, int[NY][NX] d) {
}

void main() {
  int[NY][NX] d;
  f(false, 12.1, uint[NZ](uint(0),uint(1),uint(1),uint(2)), d);
}

buffer b {
    float u[];  // ERROR
    vec4 v[];
} name[3];

uniform ub {
    float u;
    vec4 v[];   // ERROR
} uname[3];

buffer b2 {
    float u;
    vec4 v[][];  // ERROR
} name2[3];

buffer b3 {
    float u; 
    vec4 v[][7];
} name3[3];

// General arrays of arrays

float[4][5][6] many[1][2][3];

float gu[][7];     // ERROR, size required
float g4[4][7];
float g5[5][7];

float[4][7] foo(float a[5][7])
{
    float r[7];
    r = a[2];
    float[](a[0], a[1], r, a[3]);              // ERROR, too few dims
    float[4][7][4](a[0], a[1], r, a[3]);       // ERROR, too many dims
    return float[4][7](a[0], a[1], r, a[3]);
    return float[][](a[0], a[1], r, a[3]);
    return float[][7](a[0], a[1], a[2], a[3]);
}

void bar(float[5][7]) {}

void foo2()
{
    {
        float gu[3][4][2];

        gu[2][4][1] = 4.0;                     // ERROR, overflow
    }
    vec4 ca4[3][2] = vec4[][](vec4[2](vec4(0.0), vec4(1.0)),
                              vec4[2](vec4(0.0), vec4(1.0)),
                              vec4[2](vec4(0.0), vec4(1.0)));
    vec4 caim[][2] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)));
    vec4 caim2[][] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)));
    vec4 caim3[3][] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                               vec4[2](vec4(4.0), vec4(2.0)),
                               vec4[2](vec4(4.0), vec4(2.0)));

    g4 = foo(g5);
    g5 = g4;           // ERROR, wrong types
    gu = g4;           // ERROR, not yet sized

    foo(gu);           // ERROR, not yet sized
    bar(g5);

    if (foo(g5) == g4)
        ;
    if (foo(g5) == g5)  // ERROR, different types
        ;

    float u[5][7];
    u[5][2] = 5.0;      // ERROR
    foo(u);

    vec4 badAss[3];
    name[1].v[-1];     // ERROR
    name[1].v[1] = vec4(4.3);
    name[1].v = badAss;  // ERROR, bad assignemnt

    name3[0].v[1].length();  // 7
    name3[0].v.length();     // run time
}

struct badS {
    int sa[];     // ERROR
    int a[][];    // ERROR
    int b[][2];   // ERROR
    int c[2][];   // ERROR
    int d[][4];   // ERROR
};

in float inArray[2][3];    // ERROR
out float outArray[2][3];  // ERROR

uniform ubaa {
    int a;
} ubaaname[2][3];  // ERROR

vec3 func(in mat3[2] x[3])
{
	mat3 a0 = x[2][1];
    return a0[2];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.comp]=[
#version 320 es

float fX;
float fY;

void main()
{
    dFdx(fX);
    dFdy(fY);
    fwidth(fX);
    dFdxCoarse(fX);
    dFdyCoarse(fY);
    fwidthCoarse(fX);
    dFdxFine(fX);
    dFdyFine(fY);
    fwidthFine(fX);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.frag]=[
#version 320 es

out outbname { int a; } outbinst;   // ERROR, not out block in fragment shader

in inbname {
    int a;
    vec4 v;
    struct { int b; } s;     // ERROR, nested struct definition
} inbinst;

in inbname2 {
    layout(location = 12) int aAnon;
    layout(location = 13) centroid in vec4 vAnon;
};

in layout(location = 13) vec4 aliased; // ERROR, aliased

in inbname2 {                // ERROR, reuse of block name
    int aAnon;
    centroid in vec4 vAnon;
};

in badmember {               // ERROR, aAnon already in global scope
    int aAnon;
};

int inbname;                 // ERROR, redefinition of block name

vec4 vAnon;                  // ERROR, anon in global scope; redefinition

in arrayed {
    float f;
} arrayedInst[4];
uniform int i;
void fooIO()
{
    vec4 v = inbinst.v + vAnon;
    v *= arrayedInst[2].f;
    v *= arrayedInst[i].f;
}

in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR, non-ES

layout(early_fragment_tests) in;
out float gl_FragDepth;
layout(depth_any) out float gl_FragDepth;  // ERROR, non-ES

void main()
{
    gl_FragDepth = 0.2;  // ERROR, early_fragment_tests declared
    bool f = gl_FrontFacing;
}

out float gl_FragDepth;

void foo_GS()
{
    highp int l = gl_Layer;
    highp int p = gl_PrimitiveID;
}

in vec2 inf, ing;
uniform ivec2 offsets[4];
uniform sampler2D sArray[4];
uniform int sIndex;
layout(binding = 0) uniform atomic_uint auArray[2];
uniform ubName { int i; } ubInst[4];
buffer bbName { int i; } bbInst[4];
highp uniform writeonly image2D iArray[5];
const ivec2 constOffsets[4] = ivec2[4](ivec2(0.1), ivec2(0.2), ivec2(0.3), ivec2(0.4));

void pfoo()
{
    precise vec2 h;
    h = fma(inf, ing, h);
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);
    textureGatherOffsets(sArray[0], vec2(0.1), offsets);       // ERROR, offset not constant
}

precision highp imageCubeArray        ;
precision highp iimageCubeArray       ;
precision highp uimageCubeArray       ;

precision highp samplerCubeArray      ;
precision highp samplerCubeArrayShadow;
precision highp isamplerCubeArray     ;
precision highp usamplerCubeArray     ;

uniform writeonly imageCubeArray  CA1;
uniform writeonly iimageCubeArray CA2;
uniform writeonly uimageCubeArray CA3;

#ifdef GL_EXT_texture_cube_map_array
uniform samplerCubeArray          CA4;
uniform samplerCubeArrayShadow    CA5;
uniform isamplerCubeArray         CA6;
uniform usamplerCubeArray         CA7;
#endif

void CAT()
{
    highp vec4 b4 = texture(CA4, vec4(0.5), 0.24);
    highp ivec4 b6 = texture(CA6, vec4(0.5), 0.26);
    highp uvec4 b7 = texture(CA7, vec4(0.5), 0.27);
}

void goodSample()
{
    lowp     int  a1 = gl_SampleID;       
    mediump  vec2 a2 = gl_SamplePosition; 
    highp    int  a3 = gl_SampleMaskIn[0];
    gl_SampleMask[0] = a3;
    mediump int n1 = gl_MaxSamples;
    mediump int n2 = gl_NumSamples;
}

uniform layout(r32f)  highp  image2D im2Df;
uniform layout(r32ui) highp uimage2D im2Du;
uniform layout(r32i)  highp iimage2D im2Di;
uniform ivec2 P;

uniform layout(rgba32f)  highp  image2D badIm2Df;  // ERROR, needs readonly or writeonly
uniform layout(rgba8ui) highp uimage2D badIm2Du;   // ERROR, needs readonly or writeonly
uniform layout(rgba16i)  highp iimage2D badIm2Di;  // ERROR, needs readonly or writeonly

void goodImageAtom()
{
    float datf;
    int dati;
    uint datu;

    imageAtomicAdd(     im2Di, P, dati);
    imageAtomicAdd(     im2Du, P, datu);
    imageAtomicMin(     im2Di, P, dati);
    imageAtomicMin(     im2Du, P, datu);
    imageAtomicMax(     im2Di, P, dati);
    imageAtomicMax(     im2Du, P, datu);
    imageAtomicAnd(     im2Di, P, dati);
    imageAtomicAnd(     im2Du, P, datu);
    imageAtomicOr(      im2Di, P, dati);
    imageAtomicOr(      im2Du, P, datu);
    imageAtomicXor(     im2Di, P, dati);
    imageAtomicXor(     im2Du, P, datu);
    imageAtomicExchange(im2Di, P, dati);
    imageAtomicExchange(im2Du, P, datu);
    imageAtomicExchange(im2Df, P, datf);
    imageAtomicCompSwap(im2Di, P,  3, dati);
    imageAtomicCompSwap(im2Du, P, 5u, datu);

    imageAtomicMax(badIm2Di, P, dati);      // ERROR, not an allowed layout() on the image
    imageAtomicMax(badIm2Du, P, datu);      // ERROR, not an allowed layout() on the image
    imageAtomicExchange(badIm2Df, P, datf); // ERROR, not an allowed layout() on the image
}

centroid out vec4 colorCentroidBad;  // ERROR
flat out vec4 colorBadFlat;          // ERROR
smooth out vec4 colorBadSmooth;      // ERROR
noperspective out vec4 colorBadNo;   // ERROR
flat centroid in vec2 colorfc;
in float scalarIn;

sample in vec4 colorSampIn;
sample out vec4 colorSampleBad;     // ERROR
flat sample in vec4 colorfsi;
sample in vec3 sampInArray[4];

void interp()
{
    float res;
    vec2 res2;
    vec3 res3;
    vec4 res4;

    res2 = interpolateAtCentroid(colorfc);
    res4 = interpolateAtCentroid(colorSampIn);
    res4 = interpolateAtCentroid(colorfsi);
    res  = interpolateAtCentroid(scalarIn);
    res3 = interpolateAtCentroid(sampInArray);         // ERROR
    res3 = interpolateAtCentroid(sampInArray[2]);
    res2 = interpolateAtCentroid(sampInArray[2].xy);   // ERROR

    res3 = interpolateAtSample(sampInArray, 1);        // ERROR
    res3 = interpolateAtSample(sampInArray[i], 0);
    res2 = interpolateAtSample(sampInArray[2].xy, 2);  // ERROR
    res  = interpolateAtSample(scalarIn, 1);

    res3 = interpolateAtOffset(sampInArray, vec2(0.2));         // ERROR
    res3 = interpolateAtOffset(sampInArray[2], vec2(0.2));
    res2 = interpolateAtOffset(sampInArray[2].xy, vec2(0.2));   // ERROR, no swizzle
    res  = interpolateAtOffset(scalarIn + scalarIn, vec2(0.2)); // ERROR, no binary ops other than dereference
    res  = interpolateAtOffset(scalarIn, vec2(0.2));

    float f;
    res  = interpolateAtCentroid(f);           // ERROR, not interpolant
    res4 = interpolateAtSample(outp, 0);       // ERROR, not interpolant
}

layout(blend_support_multiply) out;
layout(blend_support_screen) out;
layout(blend_support_overlay) out;
layout(blend_support_darken, blend_support_lighten) out;
layout(blend_support_colordodge) layout(blend_support_colorburn) out;
layout(blend_support_hardlight) out;
layout(blend_support_softlight) out;
layout(blend_support_difference) out;
layout(blend_support_exclusion) out;
layout(blend_support_hsl_hue) out;
layout(blend_support_hsl_saturation) out;
layout(blend_support_hsl_color) out;
layout(blend_support_hsl_luminosity) out;
layout(blend_support_all_equations) out;

layout(blend_support_hsl_luminosity) out;              // okay to repeat

layout(blend_support_hsl_luminosity) in;                       // ERROR, only on "out"
layout(blend_support_hsl_luminosity) out vec4;                 // ERROR, only on standalone
layout(blend_support_hsl_luminosity) out vec4 badout;          // ERROR, only on standalone
layout(blend_support_hsl_luminosity) struct badS {int i;};     // ERROR, only on standalone
layout(blend_support_hsl_luminosity) void blendFoo() { }       // ERROR, only on standalone
void blendFoo(layout(blend_support_hsl_luminosity) vec3 v) { } // ERROR, only on standalone
layout(blend_support_flizbit) out;                             // ERROR, no flizbit

out vec4 outAA[2][2];  // ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.geom]=[
#version 320 es

precision mediump float;

in fromVertex {
    in vec3 color;
} fromV[];

in vec4 nonBlockUnsized[];

out toFragment {
    out vec3 color;
} toF;

out fromVertex {  // okay to reuse a block name for another block name
    vec3 color;
};

out fooB {        // ERROR, cannot reuse block name as block instance
    vec2 color;
} fromVertex;

int fromVertex;   // ERROR, cannot reuse a block name for something else

out fooC {        // ERROR, cannot have same name for block and instance name
    vec2 color;
} fooC;

void main()
{
    EmitVertex();
    EndPrimitive();
    EmitStreamVertex(1);    // ERROR
    EndStreamPrimitive(0);  // ERROR

    color = fromV[0].color;
    gl_ClipDistance[3] =              // ERROR, no ClipDistance
        gl_in[1].gl_ClipDistance[2];  // ERROR, no ClipDistance
    gl_Position = gl_in[0].gl_Position;

    gl_PrimitiveID = gl_PrimitiveIDIn;
    gl_Layer = 2;
}

layout(stream = 4) out vec4 ov4; // ERROR, no streams

layout(line_strip, points, triangle_strip, points, triangle_strip) out;  // just means triangle_strip"

out ooutb { vec4 a; } ouuaa6;

layout(max_vertices = 200) out;
layout(max_vertices = 300) out;   // ERROR, too big
void foo(layout(max_vertices = 4) int a)  // ERROR
{
    ouuaa6.a = vec4(1.0);
}

layout(line_strip, points, triangle_strip, points) out;  // ERROR, changing output primitive
layout(line_strip, points) out; // ERROR, changing output primitive
layout(triangle_strip) in; // ERROR, not an input primitive
layout(triangle_strip) uniform; // ERROR
layout(triangle_strip) out vec4 badv4;  // ERROR, not on a variable
layout(triangle_strip) in vec4 bad2v4[];  // ERROR, not on a variable or input
layout(invocations = 3) out outbn { int a; }; // 2 ERROR, not on a block, not until 4.0
out outbn2 {
    layout(invocations = 3)  int a; // 2 ERRORs, not on a block member, not until 4.0
    layout(max_vertices = 3) int b; // ERROR, not on a block member
    layout(triangle_strip)   int c; // ERROR, not on a block member
} outbi;

layout(lines) out;  // ERROR, not on output
layout(lines_adjacency) in;
layout(triangles) in;             // ERROR, can't change it
layout(triangles_adjacency) in;   // ERROR, can't change it
layout(invocations = 4) in;

in sameName {
    int a15;
} insn[];

out sameName {
    float f15;
};

uniform sameName {
    bool b15;
};

const int summ = gl_MaxVertexAttribs +
             gl_MaxGeometryInputComponents +
             gl_MaxGeometryOutputComponents +
             gl_MaxGeometryImageUniforms +
             gl_MaxGeometryTextureImageUnits +
             gl_MaxGeometryOutputVertices +
             gl_MaxGeometryTotalOutputComponents +
             gl_MaxGeometryUniformComponents +
             gl_MaxGeometryAtomicCounters +
             gl_MaxGeometryAtomicCounterBuffers +
             gl_MaxVertexTextureImageUnits +
             gl_MaxCombinedTextureImageUnits +
             gl_MaxTextureImageUnits +
             gl_MaxDrawBuffers;

void fooe1()
{
    gl_ViewportIndex;  // ERROR, not in ES
    gl_MaxViewports;   // ERROR, not in ES
    insn.length();     // 4: lines_adjacency
    int inv = gl_InvocationID;
}

in vec4 explArray[4];
in vec4 explArrayBad[5];  // ERROR, wrong size
in vec4 nonArrayed;       // ERROR, not an array
flat out vec3 myColor1;
centroid out vec3 myColor2;
centroid in vec3 centr[];
sample out vec4 perSampleColor;  // ERROR without sample extensions

layout(max_vertices = 200) out;  // matching redecl

layout(location = 7, component = 2) in float comp[];  // ERROR, es has no component

void notHere()
{
    gl_MaxGeometryVaryingComponents;  // ERROR, not in ES
    gl_VerticesIn;                    // ERROR, not in ES
}

void pointSize2()
{
    highp float ps = gl_in[3].gl_PointSize;  // ERROR, need extension
    gl_PointSize = ps;                       // ERROR, need extension
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.tesc]=[
#version 320 es

layout(vertices = 4) out;
out int outa[gl_out.length()];

layout(quads) in;                   // ERROR
layout(ccw) out;                    // ERROR
layout(fractional_even_spacing) in; // ERROR

patch in vec4 patchIn;              // ERROR
patch out vec4 patchOut;

void main()
{
    barrier();

    int a = gl_MaxTessControlInputComponents +
            gl_MaxTessControlOutputComponents +
            gl_MaxTessControlTextureImageUnits +
            gl_MaxTessControlUniformComponents +
            gl_MaxTessControlTotalOutputComponents;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;        // ERROR, need point_size extension
    float cd = gl_in[1].gl_ClipDistance[2];  // ERROR, not in ES

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;        // ERROR, need point_size extension
    gl_out[gl_InvocationID].gl_ClipDistance[1] = cd;  // ERROR, not in ES

    gl_TessLevelOuter[3] = 3.2;
    gl_TessLevelInner[1] = 1.3;

    if (a > 10)
        barrier();           // ERROR
    else
        barrier();           // ERROR

    barrier();

    do {
        barrier();           // ERROR
    } while (a > 10);

    switch (a) {
    default:
        barrier();           // ERROR
        break;
    }
    a < 12 ? a : (barrier(), a); // ERROR
    {
        barrier();
    }

    return;

    barrier();               // ERROR
}

layout(vertices = 4) in;    // ERROR, not on in
layout(vertices = 5) out;   // ERROR, changing #

void foo()
{
    gl_out[4].gl_Position;  // ERROR, out of range

    barrier();              // ERROR, not in main
}

in vec2 ina;                // ERROR, not array
in vec2 inb[];
in vec2 inc[18];            // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];
patch out float implA[];    // ERROR, not sized

#extension GL_ARB_separate_shader_objects : enable

layout(location = 3) in vec4 ivla[];
layout(location = 4) in vec4 ivlb[];
layout(location = 4) in vec4 ivlc[];  // ERROR, overlapping

layout(location = 3) out vec4 ovla[];
layout(location = 4) out vec4 ovlb[];
layout(location = 4) out vec4 ovlc[];  // ERROR, overlapping

patch out pinbn {
    int a;
} pinbi;

centroid out vec3 myColor2[];
centroid in vec3 centr[];
sample out vec4 perSampleColor[];

layout(vertices = 4) out float badlay[];   // ERROR, not on a variable
out float misSized[5];              // ERROR, size doesn't match
out float okaySize[4];

void pointSize2()
{
    float ps = gl_in[1].gl_PointSize;  // ERROR, need point_size extension
    gl_out[gl_InvocationID].gl_PointSize = ps;   // ERROR, need point_size extension
}

precise vec3 pv3;

void goodfoop()
{
    precise float d;

    pv3 *= pv3;
    pv3 = fma(pv3, pv3, pv3);
    d = fma(d, d, d);
}

void bb()
{
    gl_BoundingBoxEXT[0] = vec4(0.0); // ERROR without GL_EXT_primitive_bounding_box 
    gl_BoundingBoxOES[0] = vec4(0.0); // ERROR without GL_OES_primitive_bounding_box 
    gl_BoundingBox[0] = vec4(1.0);
    gl_BoundingBox[1] = vec4(1.0);
    gl_BoundingBox[2] = vec4(2.0);  // ERROR, overflow
}

#extension GL_EXT_primitive_bounding_box : enable
#extension GL_OES_primitive_bounding_box : enable

void bbext()
{
    gl_BoundingBoxEXT[1] = vec4(0.0);
    gl_BoundingBoxOES[1] = vec4(0.0);
}

out patch badpatchBName {  // ERROR, array size required
    float f;
} badpatchIName[];

out patch patchBName {
    float f;
} patchIName[4];

void outputtingOutparam(out int a)
{
    a = 2;
}

void outputting()
{
    outa[gl_InvocationID] = 2;
    outa[1] = 2;                         // ERROR, not gl_InvocationID
    gl_out[0].gl_Position = vec4(1.0);   // ERROR, not gl_InvocationID
    outa[1];
    gl_out[0];
    outputtingOutparam(outa[0]);         // ERROR, not gl_InvocationID
    outputtingOutparam(outa[gl_InvocationID]);
    patchIName[1].f = 3.14;
    outa[(gl_InvocationID)] = 2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.tese]=[
#version 320 es

layout(vertices = 4) out; // ERROR
layout(quads, cw) in;
layout(triangles) in;     // ERROR
layout(isolines) in;      // ERROR

layout(ccw) in;           // ERROR
layout(cw) in;

layout(fractional_odd_spacing) in;    
layout(equal_spacing) in;              // ERROR
layout(fractional_even_spacing) in;    // ERROR

layout(point_mode) in;

patch in vec4 patchIn;
patch out vec4 patchOut;  // ERROR

void main()
{
    barrier(); // ERROR

    int a = gl_MaxTessEvaluationInputComponents +
            gl_MaxTessEvaluationOutputComponents +
            gl_MaxTessEvaluationTextureImageUnits +
            gl_MaxTessEvaluationUniformComponents +
            gl_MaxTessPatchComponents +
            gl_MaxPatchVertices +
            gl_MaxTessGenLevel;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;        // ERROR, need point_size extension
    float cd = gl_in[1].gl_ClipDistance[2];  // ERROR, not in ES

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    vec3 tc = gl_TessCoord;
    float tlo = gl_TessLevelOuter[3];
    float tli = gl_TessLevelInner[1];

    gl_Position = p;
    gl_PointSize = ps;             // ERROR, need point_size extension
    gl_ClipDistance[2] = cd;       // ERROR, not in ES
}

smooth patch in vec4 badp1;         // ERROR
flat patch in vec4 badp2;           // ERROR
noperspective patch in vec4 badp3;  // ERROR
patch sample in vec3 badp4;         // ERROR

#extension GL_ARB_separate_shader_objects : enable

in gl_PerVertex
{
    vec4 gl_Position;
} gl_in[];

in gl_PerVertex           // ERROR, second redeclaration of gl_in
{
    vec4 gl_Position;
} gl_in[];

layout(quads, cw) out;     // ERROR
layout(triangles) out;     // ERROR
layout(isolines) out;      // ERROR
layout(cw) out;            // ERROR
layout(fractional_odd_spacing) out;    // ERROR
layout(equal_spacing) out;             // ERROR
layout(fractional_even_spacing) out;   // ERROR
layout(point_mode) out;                // ERROR

in vec2 ina;      // ERROR, not array
in vec2 inb[];
in vec2 inc[18];  // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];

in testbla {      // ERROR, not array
    int f;
} bla;

in testblb {
    int f;
} blb[];

in testblc { // ERROR wrong size
    int f;
} blc[18];

in testbld {
    int f;
} bld[gl_MaxPatchVertices];

layout(location = 23) in vec4 ivla[];
layout(location = 24) in vec4 ivlb[];
layout(location = 24) in vec4 ivlc[];  // ERROR, overlap

layout(location = 23) out vec4 ovla[2];
layout(location = 24) out vec4 ovlb[2];  // ERROR, overlap

in float gl_TessLevelOuter[4];           // ERROR, can't redeclare

patch in pinbn {
    int a;
} pinbi;

centroid out vec3 myColor2;
centroid in vec3 centr[];
sample out vec4 perSampleColor;

void bbbad()
{
    gl_BoundingBoxOES; // ERROR, wrong stage
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[320.vert]=[
#version 320 es

out outbname {
    int a;
    out vec4 v;
    highp sampler2D s;   // ERROR, opaque type
} outbinst;

out outbname2 {
    layout(location = 12) int aAnon;
    layout(location = 13) vec4 vAnon;
};

layout(location = 12) out highp int aliased;  // ERROR, aliasing location

in inbname { int a; } inbinst;  // ERROR, no in block in vertex shader

out gl_PerVertex {              // ERROR, has extra member
    highp vec4 gl_Position;
    highp vec4 t;
};

void main()
{
    int sum  = gl_VertexID +
               gl_InstanceID;
    gl_Position = vec4(1.0);
    gl_PointSize = 2.0;         // ERROR, removed by redeclaration
}

out gl_PerVertex {              // ERROR, already used and already redeclared
    highp vec4 gl_Position;
    highp vec4 t;
};

smooth out smo {                // ERROR, no smooth on a block
    int i;
} smon;

flat out fmo {                  // ERROR, no flat on a block
    int i;
} fmon;

centroid out cmo {              // ERROR, no centroid on a block
    int i;
} cmon;

invariant out imo {             // ERROR, no invariant on a block
    int i;
} imon;

in vec2 inf, ing;
uniform ivec2 offsets[4];
uniform sampler2D sArray[4];
uniform int sIndex;
layout(binding = 0) uniform atomic_uint auArray[2];
uniform ubName { int i; } ubInst[4];
buffer bbName { int i; } bbInst[4];
highp uniform writeonly image2D iArray[5];
const ivec2 constOffsets[4] = ivec2[4](ivec2(0.1), ivec2(0.2), ivec2(0.3), ivec2(0.4));

void pfoo()
{
    precise vec2 h;
    h = fma(inf, ing, h);
    sArray[sIndex + 1];
    ubInst[sIndex + 1];
    bbInst[sIndex - 2];      // ERROR, still not supported
    iArray[2];
    iArray[sIndex - 2];
    textureGatherOffset(sArray[0], vec2(0.1), ivec2(inf));
    textureGatherOffsets(sArray[0], vec2(0.1), constOffsets);
    textureGatherOffsets(sArray[0], vec2(0.1), offsets);   // ERROR, offset not constant
}

uniform samplerBuffer  noPreSamp1;            // ERROR, no default precision
uniform isamplerBuffer noPreSamp2;            // ERROR, no default precision
uniform usamplerBuffer noPreSamp3;            // ERROR, no default precision
uniform writeonly imageBuffer    noPreSamp4;  // ERROR, no default precision
uniform writeonly iimageBuffer   noPreSamp5;  // ERROR, no default precision
uniform writeonly uimageBuffer   noPreSamp6;  // ERROR, no default precision

precision highp samplerBuffer; 
precision highp isamplerBuffer;
precision highp usamplerBuffer;
precision highp imageBuffer;   
precision highp iimageBuffer;  
precision highp uimageBuffer;  

#ifdef GL_OES_texture_buffer
uniform samplerBuffer  bufSamp1;          
uniform isamplerBuffer bufSamp2;          
uniform usamplerBuffer bufSamp3;          
#endif
#ifdef GL_EXT_texture_buffer
uniform writeonly imageBuffer    bufSamp4;
uniform writeonly iimageBuffer   bufSamp5;
uniform writeonly uimageBuffer   bufSamp6;
#endif

void bufferT()
{
    highp int s1 = textureSize(bufSamp1);
    highp int s2 = textureSize(bufSamp2);
    highp int s3 = textureSize(bufSamp3);

    highp int s4 = imageSize(bufSamp4);
    highp int s5 = imageSize(bufSamp5);
    highp int s6 = imageSize(bufSamp6);
    
    highp vec4 f1 = texelFetch(bufSamp1, s1);
    highp ivec4 f2 = texelFetch(bufSamp2, s2);
    highp uvec4 f3 = texelFetch(bufSamp3, s3);
}

uniform writeonly imageCubeArray  noPreCA1;   // ERROR, no default precision
uniform writeonly iimageCubeArray noPreCA2;   // ERROR, no default precision
uniform writeonly uimageCubeArray noPreCA3;   // ERROR, no default precision

uniform samplerCubeArray          noPreCA4;   // ERROR, no default precision
uniform samplerCubeArrayShadow    noPreCA5;   // ERROR, no default precision
uniform isamplerCubeArray         noPreCA6;   // ERROR, no default precision
uniform usamplerCubeArray         noPreCA7;   // ERROR, no default precision

precision highp imageCubeArray        ;
precision highp iimageCubeArray       ;
precision highp uimageCubeArray       ;

precision highp samplerCubeArray      ;
precision highp samplerCubeArrayShadow;
precision highp isamplerCubeArray     ;
precision highp usamplerCubeArray     ;

uniform writeonly imageCubeArray  CA1;
uniform writeonly iimageCubeArray CA2;
uniform writeonly uimageCubeArray CA3;

layout(rgba16f) uniform readonly imageCubeArray  rCA1;
layout(rgba32i) uniform readonly iimageCubeArray rCA2;
layout(r32ui) uniform readonly uimageCubeArray rCA3;

#ifdef GL_OES_texture_cube_map_array
uniform samplerCubeArray          CA4;
uniform samplerCubeArrayShadow    CA5;
uniform isamplerCubeArray         CA6;
uniform usamplerCubeArray         CA7;
#endif

void CAT()
{
    highp ivec3 s4 = textureSize(CA4, 1);
    highp ivec3 s5 = textureSize(CA5, 1);
    highp ivec3 s6 = textureSize(CA6, 1);
    highp ivec3 s7 = textureSize(CA7, 1);
    
    highp vec4 t4 = texture(CA4, vec4(0.5));
    highp float t5 = texture(CA5, vec4(0.5), 3.0);
    highp ivec4 t6 = texture(CA6, vec4(0.5));
    highp uvec4 t7 = texture(CA7, vec4(0.5));

    highp vec4 L4 = textureLod(CA4, vec4(0.5), 0.24);
    highp ivec4 L6 = textureLod(CA6, vec4(0.5), 0.26);
    highp uvec4 L7 = textureLod(CA7, vec4(0.5), 0.27);

    highp vec4 g4 = textureGrad(CA4, vec4(0.5), vec3(0.1), vec3(0.2));
    highp ivec4 g6 = textureGrad(CA6, vec4(0.5), vec3(0.1), vec3(0.2));
    highp uvec4 g7 = textureGrad(CA7, vec4(0.5), vec3(0.1), vec3(0.2));

    highp vec4 gath4 = textureGather(CA4, vec4(0.5));
    highp vec4 gathC4 = textureGather(CA4, vec4(0.5), 2);
    highp ivec4 gath6 = textureGather(CA6, vec4(0.5));
    highp ivec4 gathC6 = textureGather(CA6, vec4(0.5), 1);
    highp uvec4 gath7 = textureGather(CA7, vec4(0.5));
    highp uvec4 gathC7 = textureGather(CA7, vec4(0.5), 0);

    highp vec4 gath5 = textureGather(CA5, vec4(0.5), 2.5);

    highp ivec3 s1 = imageSize(CA1);
    highp ivec3 s2 = imageSize(CA2);
    highp ivec3 s3 = imageSize(CA3);

    imageStore(CA1, s3, vec4(1));
    imageStore(CA2, s3, ivec4(1));
    imageStore(CA3, s3, uvec4(1));

    highp vec4 cl1 = imageLoad(rCA1, s3);
    highp ivec4 cl2 = imageLoad(rCA2, s3);
    highp uvec4 cl3 = imageLoad(rCA3, s3);
}

uniform sampler2DMSArray  noPrec2DMS;    // ERROR, no default
uniform isampler2DMSArray noPrec2DMSi;   // ERROR, no default
uniform usampler2DMSArray noPrec2DMSu;   // ERROR, no default

precision highp sampler2DMSArray;
precision highp isampler2DMSArray;
precision highp usampler2DMSArray;

uniform sampler2DMSArray  samp2DMSA;
uniform isampler2DMSArray samp2DMSAi;
uniform usampler2DMSArray samp2DMSAu;

void MSA()
{
    vec4 tf = texelFetch(samp2DMSA, ivec3(5), 2);
    ivec4 tfi = texelFetch(samp2DMSAi, ivec3(5), 2);
    uvec4 tfu = texelFetch(samp2DMSAu, ivec3(5), 2);
    
    ivec3 tfs = textureSize(samp2DMSA);
    ivec3 tfsi = textureSize(samp2DMSAi);
    ivec3 tfsb = textureSize(samp2DMSAi, 4);  // ERROR, no lod
    ivec3 tfsu = textureSize(samp2DMSAu);
}

uniform layout(r32f)  highp  image2D im2Df;
uniform layout(r32ui) highp uimage2D im2Du;
uniform layout(r32i)  highp iimage2D im2Di;
uniform ivec2 P;

void goodImageAtom()
{
    float datf;
    int dati;
    uint datu;

    imageAtomicAdd(     im2Di, P, dati);
    imageAtomicAdd(     im2Du, P, datu);
    imageAtomicMin(     im2Di, P, dati);
    imageAtomicMin(     im2Du, P, datu);
    imageAtomicMax(     im2Di, P, dati);
    imageAtomicMax(     im2Du, P, datu);
    imageAtomicAnd(     im2Di, P, dati);
    imageAtomicAnd(     im2Du, P, datu);
    imageAtomicOr(      im2Di, P, dati);
    imageAtomicOr(      im2Du, P, datu);
    imageAtomicXor(     im2Di, P, dati);
    imageAtomicXor(     im2Du, P, datu);
    imageAtomicExchange(im2Di, P, dati);
    imageAtomicExchange(im2Du, P, datu);
    imageAtomicExchange(im2Df, P, datf);
    imageAtomicCompSwap(im2Di, P,  3, dati);
    imageAtomicCompSwap(im2Du, P, 5u, datu);
}

sample out vec4 colorSample;
flat sample out vec4 colorfsi;
sample out vec3 sampInArray[4];
in vec4 inv4;

void badInterp()
{
    interpolateAtCentroid(inv4);             // ERROR, wrong stage
    interpolateAtSample(inv4, 1);            // ERROR, need extension
    interpolateAtOffset(inv4, vec2(0.2));    // ERROR, need extension
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[330.frag]=[
#version 330 compatibility

in vec4 inVar;
layout(location=0, index=0) out vec4 outVar;

varying vec4 varyingVar;

void main()
{
    gl_FragColor = varyingVar;  // link ERROR: user output was used
    gl_FragData[1] = inVar;     // link ERROR: user output was used
    int buffer = 4;
}

#extension GL_ARB_separate_shader_objects : enable

in gl_PerFragment {
    vec4 gl_Color;
};

void foo()
{
    vec4 c = gl_Color;
    outVar = inVar;
}

in gl_block { // ERROR
    int gl_i;
} gl_name;

in myBlock {
    int gl_i;  // ERROR
} gl_name;     // ERROR

in gl_PerVertex {  // ERROR
    vec4 gl_FragCoord;
} gl_in[];

in gl_PerVertex {  // ERROR
    vec4 gl_FragCoord;
};  // ERROR

const int start = 6;
layout(location = -2) in vec4 v1;         // ERROR
layout(location = start + 2) in vec4 v2;  // ERROR
layout(location = 4.7e10) in vec4 v20;    // ERROR
layout(location = +60) in float v21;      // ERROR
layout(location = (2)) in float v22;      // ERROR

struct S {
    float f1;
    layout(location = 3) float f2;        // ERROR
};

layout(location = 1) in inblock {         // ERROR
    float f1;
    layout(location = 3) float f2;        // ERROR
};

layout(location = 1) uniform ublock {     // ERROR
    float f1;
    layout(location = 3) float f2;        // ERROR
} uinst;

#extension GL_ARB_enhanced_layouts : enable

layout(location = start) in vec4 v3;
layout(location = -2) in vec4 v4;         // ERROR
layout(location = -start) in vec4 v5;     // ERROR
layout(location = start*start - 2 - 4) in vec4 v6;
layout(location = +61) in float v23;
layout(location = (62)) in float v24;

struct S2 {
    float f1;
    layout(location = 3) float f2;        // ERROR
};

layout(location = 28) in inblock2 {
    bool b1;
    float f1;
    layout(location = 25) float f2;
    vec4 f3;
    layout(location = 21) S2 s2;
    vec4 f4;
    vec4 f5;
} ininst2;

layout(location = 13) uniform ublock2 {   // ERROR
    float f1;
    layout(location = 3) float f2;        // ERROR
} uinst2;

in inblock3 {                             // ERROR, mix of location internal with no location external
    float f1;
    layout(location = 40) float f2;
} in3;

in ublock4 {
    layout(location = 50) float f1;
    layout(location = 51) float f2;
} in4;

layout(location = 33) in struct SS {
    vec3 a;    // gets location 33
    mat2 b;    // gets locations 34 and 35
    vec4 c[2]; // gets locations 36 and 37
    layout (location = 38) vec2 A; // ERROR, can't use on struct member
} s;

layout(location = 44) in block {
    vec4 d; // gets location 44
    vec4 e; // gets location 45
    layout(location = 47) vec4 f; // gets location 47
    vec4 g; // gets location 48
    layout (location = 41) vec4 h; // gets location 41
    vec4 i; // gets location 42
    vec4 j; // gets location 43
    vec4 k; // ERROR, location 44 already used
};

layout(index=0) out vec4 outVar2; // ERROR: missing explicit location
layout(location=0, index=1) out vec4 outVar3; // no error even though location is overlapping
layout(location=0, index=1) out vec4 outVar4; // ERROR overlapping
layout(location=27, index=0) in vec4 indexIn; // ERROR, not on in
layout(location=0, index=0) in; // ERROR, not just on in
layout(location=0, index=0) out; // ERROR, need a variable
layout(location=26, index=0) out indexBlock { int a; } indexBlockI; // ERROR, not on a block

int precise;                // okay, not a keyword yet
struct SKeyMem { int precise; } KeyMem; // okay, not a keyword yet

void fooKeyMem()
{
    KeyMem.precise;
}

layout(location=28, index=2) out vec4 outIndex2; // ERROR index out of range

layout(location=4) uniform vec4 ucolor0; // ERROR: extension is not enabled

#extension GL_ARB_explicit_uniform_location : enable

layout(location=5) uniform vec4 ucolor1;

layout(location=6) uniform ColorsBuffer // ERROR: location cannot be applied in uniform buffer block
{
    vec4 colors[128];
} colorsBuffer;
.
.
void testOverload() {
    float overloadTest = 42;
    overloadTest = smoothstep(0, 1, overloadTest);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>
12:8; [@75,273:278='buffer',<'buffer'>,12:8]; no viable alternative at input 'int buffer'; NoViableAltException:null
130:4; [@1095,3340:3346='precise',<'precise'>,130:4]; no viable alternative at input 'int precise'; NoViableAltException:null
131:21; [@1107,3412:3418='precise',<'precise'>,131:21]; no viable alternative at input 'struct SKeyMem { int precise'; NoViableAltException:null
131:30; [@1110,3421:3421='}',<'}'>,131:30]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
135:11; [@1128,3489:3495='precise',<'precise'>,135:11]; no viable alternative at input 'KeyMem.precise'; NoViableAltException:null
]


testGlslangErrors[330comp.frag]=[
#version 330 compatibility

in vec4 inVar;
out vec4 outVar;

varying vec4 varyingVar;

void main()
{
    gl_FragColor = varyingVar;
    gl_FragData[1] = inVar * gl_ModelViewMatrix;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[400.frag]=[
#version 400 core

in vec2 c2D;
flat in int i;
out vec4 outp;
uniform sampler2D arrayedSampler[5];
uniform usampler2DRect samp2dr;
uniform isampler2DArray isamp2DA;

void main()
{
    vec4 v;
    v = texture(arrayedSampler[i], c2D);
    outp.x = gl_ClipDistance[1];

    ivec2 offsets[4];
    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));
    uvec4 uv4 = textureGatherOffsets(samp2dr, c2D, offsets, 2);  // ERROR, offsets not constant
    uv4 = textureGatherOffsets(samp2dr, c2D, constOffsets, 2);
    vec4 v4 = textureGather(arrayedSampler[0], c2D);
    ivec4 iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 3);
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), i);  // ERROR, last argument not const
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 4);  // ERROR, last argument out of range
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 1+2);
    iv4 = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(i));

    vec4 c = gl_FragCoord;
}

layout(location = 4) in vec4 vl; // ERROR, not supported

#ifdef GL_ARB_separate_shader_objects
#extension GL_ARB_separate_shader_objects : enable
#endif

layout(location = 6) in vec4 vl2;

layout(location = 3) uniform vec3 uv3;

layout(location = 5) in vec4 gl_Color;      // ERROR, layout
noperspective in float gl_ClipDistance[4];  // ERROR, can't change qualifier

layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;  // ERROR, declared after use

uniform sampler2DRectShadow u2drs;

void foo23()
{
    const ivec2[3] offsets = ivec2[3](ivec2(1,2), ivec2(3,4), ivec2(15,16));

    textureProjGradOffset(u2drs, outp, vec2(0.0), vec2(0.0), ivec2(c2D));     // ERROR, offset not constant
    textureProjGradOffset(u2drs, outp, vec2(0.0), vec2(0.0), offsets[1]);
    textureProjGradOffset(u2drs, outp, vec2(0.0), vec2(0.0), offsets[2]);     // ERROR, offset out of range
    textureProjGradOffset(u2drs, outp, vec2(0.0), vec2(0.0), ivec2(-10, 20)); // ERROR, offset out of range
}

patch in vec4 patchIn;              // ERROR
patch out vec4 patchOut;            // ERROR

void foo24()
{
    dvec3 df, di;
    df = modf(dvec3(outp.xyz), di);
}

in float in1;
in vec2 in2;
in vec3 in3;
in vec4 in4;

void foodc1()
{
    vec2 v2 = dFdxFine(in2);           // ERROR
    vec3 v3 = dFdyCoarse(in3);         // ERROR
    vec4 v4 = fwidthCoarse(in4) + fwidthFine(in4);   // ERROR
}

#extension GL_ARB_derivative_control : enable

void foodc2()
{
    vec2 v2 = dFdxFine(in2);
    vec3 v3 = dFdyCoarse(in3);
    vec4 v4 = fwidthCoarse(in4) + fwidthFine(in4);

    uint u1;
    ivec3 i3;
    ivec2 i2;
    v2 = frexp(v2, i2);
    v3 = ldexp(v3, i3);

    u1 = packUnorm4x8(v4);
    u1 = packSnorm4x8(v4);
    v4 = unpackUnorm4x8(u1);
    v4 = unpackSnorm4x8(u1);

    double d;
    uvec2 u2;
    d = packDouble2x32(u2);
    u2 = unpackDouble2x32(d);
}

sample in vec4 colorSampIn;
sample out vec4 colorSampleBad;     // ERROR
noperspective in vec4 colorfsi;
sample in vec3 sampInArray[4];
smooth in float scalarIn;
flat centroid in vec2 colorfc;

struct S {
    float x;
};

in S s1;
sample S s2;

void interp()
{
    interpolateAtCentroid(colorfc);
    interpolateAtCentroid(colorSampIn);
    interpolateAtCentroid(colorfsi);
    interpolateAtCentroid(scalarIn);
    interpolateAtCentroid(sampInArray);         // ERROR
    interpolateAtCentroid(sampInArray[2]);
    interpolateAtCentroid(sampInArray[2].xy);   // ERROR

    interpolateAtSample(sampInArray, 1);        // ERROR
    interpolateAtSample(sampInArray[i], 0);
    interpolateAtSample(s1.x, 2);
    interpolateAtSample(scalarIn, 1);

    interpolateAtOffset(sampInArray, vec2(0.2));         // ERROR
    interpolateAtOffset(sampInArray[2], vec2(0.2));
    interpolateAtOffset(sampInArray[2].xy, vec2(0.2));   // ERROR, no swizzle
    interpolateAtOffset(scalarIn + scalarIn, vec2(0.2)); // ERROR, no binary ops other than dereference
    interpolateAtOffset(s2.x, vec2(0.2));      // ERROR

    float f;
    interpolateAtCentroid(f);           // ERROR, not interpolant
    interpolateAtSample(outp, 0);       // ERROR, not interpolant
}

uniform sampler1D samp1D;
uniform isampler2D isamp2D;
uniform usampler3D usamp3D;
uniform samplerCube sampCube; 
uniform isampler1DArray isamp1DA;
uniform usampler2DArray usamp2DA;
uniform isamplerCubeArray isampCubeA;

uniform sampler1DShadow samp1Ds;
uniform sampler2DShadow samp2Ds;
uniform samplerCubeShadow sampCubes;
uniform sampler1DArrayShadow samp1DAs;
uniform sampler2DArrayShadow samp2DAs;
uniform samplerCubeArrayShadow sampCubeAs;

uniform samplerBuffer sampBuf;
uniform sampler2DRect sampRect;

void qlod()
{
    vec2 lod;
    float pf;
    vec2 pf2;
    vec3 pf3;

    lod = textureQueryLod(samp1D, pf);
    lod = textureQueryLod(isamp2D, pf2);
    lod = textureQueryLod(usamp3D, pf3);
    lod = textureQueryLod(sampCube, pf3);
    lod = textureQueryLod(isamp1DA, pf);
    lod = textureQueryLod(usamp2DA, pf2);
    lod = textureQueryLod(isampCubeA, pf3);

    lod = textureQueryLod(samp1Ds, pf);
    lod = textureQueryLod(samp2Ds, pf2);
    lod = textureQueryLod(sampCubes, pf3);
    lod = textureQueryLod(samp1DAs, pf);
    lod = textureQueryLod(samp2DAs, pf2);
    lod = textureQueryLod(sampCubeAs, pf3);

    lod = textureQueryLod(sampBuf, pf);     // ERROR
    lod = textureQueryLod(sampRect, pf2);   // ERROR
}

uniform uint uu;
out uint iout;

void bitwiseConv()
{
    iout = uu & i;
    iout += uu ^ i;
    iout += i | uu;
}

subroutine(subT1, subT2);
subroutine float subT1() { return 1.0; }
subroutine float subT2() { return 1.0; }

struct SKeyMem { int precise; } KeyMem;     // ERROR, keyword can't be a member

<><><><><><><><><><><><><><><><><><><><><><><><><>
201:21; [@1801,5716:5722='precise',<'precise'>,201:21]; no viable alternative at input 'struct SKeyMem { int precise'; NoViableAltException:null
201:30; [@1804,5725:5725='}',<'}'>,201:30]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[400.geom]=[
#version 400 core

void main()
{
    EmitStreamVertex(1);
    EndStreamPrimitive(0);
    EmitVertex();
    EndPrimitive();
    int id = gl_InvocationID;
}

layout(invocations = 4) in outbn { int a; } bn[]; // ERROR, not on a block
layout(max_vertices = 127) out;
layout(invocations = 4) in;

#extension GL_ARB_separate_shader_objects : enable

in gl_PerVertex {      // testing input arrays with a block redeclaration, see 420.geom for without
    vec4 gl_Position;
    layout(std140, location = 3) patch float gl_PointSize; // ERRORs...
} gl_in[];

void foo()
{
    gl_in.length();  // ERROR
    gl_in[1].gl_Position;
}

in vec4 color[];
in vec4 color2[];
in vec4 colorS[3];
in vec4 colorBad[4];

void foo2()
{
    color.length(); // ERROR
    colorS.length();
}

layout(triangles) in;  // give ERROR just for colorBad

in vec4 color[3];
in vec4 color2[3];
in vec4 colorbad2[2];  // ERROR

void foo3()
{
    gl_in.length();
    color.length();
    color2.length();
    colorS.length();
}

layout(location = 4) in vec4 cva[3];
layout(location = 5) in vec4 cvb[3];
layout(location = 2) in mat3 cmc[3];  // ERROR, collision

patch in vec4 patchIn[];            // ERROR
patch out vec4 patchOut;            // ERROR

in float scalar;  // ERROR, no array

layout(max_vertices = 127, invocations = 4) out;      // ERROR
layout(invocations = 4, max_vertices = 127) in;       // ERROR
layout(max_vertices = 127, invocations = 4) uniform;  // 2 ERRORs

in inblockscalar {
    int a;
} inbls;  // ERROR, not an array

in inblocka {
    int a;
} inbla[17];  // ERROR, wrong array size

void bits()
{
    uvec2 u2;
    u2 = uaddCarry(u2, u2, u2);
    uint u1;
    u1 = usubBorrow(u1, u1, u1);
    uvec4 u4;
    umulExtended(u4, u4, u4, u4);
    ivec4 i4;
    imulExtended(i4, i4, i4, i4);
    int i1;
    i1 = bitfieldExtract(i1, 4, 5);
    uvec3 u3;
    u3 = bitfieldExtract(u3, 4, 5);
    ivec3 i3;
    i3 = bitfieldInsert(i3, i3, 4, 5);
    u1 = bitfieldInsert(u1, u1, 4, 5);
    ivec2 i2;
    i2 = bitfieldReverse(i2);
    u4 = bitfieldReverse(u4);
    i1 = bitCount(i1);
    i3 = bitCount(u3);
    i2 = findLSB(i2);
    i4 = findLSB(u4);
    i1 = findMSB(i1);
    i2 = findMSB(u2);
}

layout(location = 7, index = 1) out vec4 indexedOut;

uniform sampler1D samp1D;
uniform sampler2DShadow samp2Ds;

void qlod()
{
    vec2 lod;
    float pf;
    vec2 pf2;
    vec3 pf3;

    lod = textureQueryLod(samp1D, pf);      // ERROR, only in fragment
    lod = textureQueryLod(samp2Ds, pf2);    // ERROR, only in fragment
}

void doubles()
{
    double doublev;
    dvec2 dvec2v;
    dvec3 dvec3v;
    dvec4 dvec4v;

    bool boolv;
    bvec2 bvec2v;
    bvec3 bvec3v;
    bvec4 bvec4v;

    doublev = sqrt(2.9);
    dvec2v  = sqrt(dvec2(2.7));
    dvec3v  = sqrt(dvec3(2.0));
    dvec4v  = sqrt(dvec4(2.1));

    doublev += inversesqrt(doublev);
    dvec2v  += inversesqrt(dvec2v);
    dvec3v  += inversesqrt(dvec3v);
    dvec4v  += inversesqrt(dvec4v);

    doublev += abs(doublev);
    dvec2v  += abs(dvec2v);
    dvec3v  += abs(dvec3v);
    dvec4v  += abs(dvec4v);

    doublev += sign(doublev);
    dvec2v  += sign(dvec2v);
    dvec3v  += sign(dvec3v);
    dvec4v  += sign(dvec4v);

    doublev += floor(doublev);
    dvec2v  += floor(dvec2v);
    dvec3v  += floor(dvec3v);
    dvec4v  += floor(dvec4v);

    doublev += trunc(doublev);
    dvec2v  += trunc(dvec2v);
    dvec3v  += trunc(dvec3v);
    dvec4v  += trunc(dvec4v);

    doublev += round(doublev);
    dvec2v  += round(dvec2v);
    dvec3v  += round(dvec3v);
    dvec4v  += round(dvec4v);

    doublev += roundEven(doublev);
    dvec2v  += roundEven(dvec2v);
    dvec3v  += roundEven(dvec3v);
    dvec4v  += roundEven(dvec4v);

    doublev += ceil(doublev);
    dvec2v  += ceil(dvec2v);
    dvec3v  += ceil(dvec3v);
    dvec4v  += ceil(dvec4v);

    doublev += fract(doublev);
    dvec2v  += fract(dvec2v);
    dvec3v  += fract(dvec3v);
    dvec4v  += fract(dvec4v);

    doublev += mod(doublev, doublev);
    dvec2v  += mod(dvec2v, doublev);
    dvec3v  += mod(dvec3v, doublev);
    dvec4v  += mod(dvec4v, doublev);
    dvec2v  += mod(dvec2v, dvec2v);
    dvec3v  += mod(dvec3v, dvec3v);
    dvec4v  += mod(dvec4v, dvec4v);

    doublev += modf(doublev, doublev);
    dvec2v  += modf(dvec2v,  dvec2v);
    dvec3v  += modf(dvec3v,  dvec3v);
    dvec4v  += modf(dvec4v,  dvec4v);

    doublev += min(doublev, doublev);
    dvec2v  += min(dvec2v, doublev);
    dvec3v  += min(dvec3v, doublev);
    dvec4v  += min(dvec4v, doublev);
    dvec2v  += min(dvec2v, dvec2v);
    dvec3v  += min(dvec3v, dvec3v);
    dvec4v  += min(dvec4v, dvec4v);

    doublev += max(doublev, doublev);
    dvec2v  += max(dvec2v, doublev);
    dvec3v  += max(dvec3v, doublev);
    dvec4v  += max(dvec4v, doublev);
    dvec2v  += max(dvec2v, dvec2v);
    dvec3v  += max(dvec3v, dvec3v);
    dvec4v  += max(dvec4v, dvec4v);

    doublev += clamp(doublev, doublev, doublev);
    dvec2v  += clamp(dvec2v, doublev, doublev);
    dvec3v  += clamp(dvec3v, doublev, doublev);
    dvec4v  += clamp(dvec4v, doublev, doublev);
    dvec2v  += clamp(dvec2v, dvec2v, dvec2v);
    dvec3v  += clamp(dvec3v, dvec3v, dvec3v);
    dvec4v  += clamp(dvec4v, dvec4v, dvec4v);

    doublev += mix(doublev, doublev, doublev);
    dvec2v  += mix(dvec2v, dvec2v, doublev);
    dvec3v  += mix(dvec3v, dvec3v, doublev);
    dvec4v  += mix(dvec4v, dvec4v, doublev);
    dvec2v  += mix(dvec2v, dvec2v, dvec2v);
    dvec3v  += mix(dvec3v, dvec3v, dvec3v);
    dvec4v  += mix(dvec4v, dvec4v, dvec4v);
    doublev += mix(doublev, doublev, boolv);
    dvec2v  += mix(dvec2v, dvec2v, bvec2v);
    dvec3v  += mix(dvec3v, dvec3v, bvec3v);
    dvec4v  += mix(dvec4v, dvec4v, bvec4v);

    doublev += step(doublev, doublev);
    dvec2v  += step(dvec2v, dvec2v);
    dvec3v  += step(dvec3v, dvec3v);
    dvec4v  += step(dvec4v, dvec4v);
    dvec2v  += step(doublev, dvec2v);
    dvec3v  += step(doublev, dvec3v);
    dvec4v  += step(doublev, dvec4v);

    doublev += smoothstep(doublev, doublev, doublev);
    dvec2v  += smoothstep(dvec2v, dvec2v, dvec2v);
    dvec3v  += smoothstep(dvec3v, dvec3v, dvec3v);
    dvec4v  += smoothstep(dvec4v, dvec4v, dvec4v);
    dvec2v  += smoothstep(doublev, doublev, dvec2v);
    dvec3v  += smoothstep(doublev, doublev, dvec3v);
    dvec4v  += smoothstep(doublev, doublev, dvec4v);

    boolv  = isnan(doublev);
    bvec2v = isnan(dvec2v);
    bvec3v = isnan(dvec3v);
    bvec4v = isnan(dvec4v);

    boolv  = boolv ? isinf(doublev) : false;
    bvec2v = boolv ? isinf(dvec2v)  : bvec2(false);
    bvec3v = boolv ? isinf(dvec3v)  : bvec3(false);
    bvec4v = boolv ? isinf(dvec4v)  : bvec4(false);

    doublev += length(doublev);
    doublev += length(dvec2v);
    doublev += length(dvec3v);
    doublev += length(dvec4v);

    doublev += distance(doublev, doublev);
    doublev += distance(dvec2v, dvec2v);
    doublev += distance(dvec3v, dvec3v);
    doublev += distance(dvec4v, dvec4v);

    doublev += dot(doublev, doublev);
    doublev += dot(dvec2v, dvec2v);
    doublev += dot(dvec3v, dvec3v);
    doublev += dot(dvec4v, dvec4v);

    dvec3v += cross(dvec3v, dvec3v);

    doublev += normalize(doublev);
    dvec2v  += normalize(dvec2v);
    dvec3v  += normalize(dvec3v);
    dvec4v  += normalize(dvec4v);

    doublev += faceforward(doublev, doublev, doublev);
    dvec2v  += faceforward(dvec2v, dvec2v, dvec2v);
    dvec3v  += faceforward(dvec3v, dvec3v, dvec3v);
    dvec4v  += faceforward(dvec4v, dvec4v, dvec4v);

    doublev += reflect(doublev, doublev);
    dvec2v  += reflect(dvec2v, dvec2v);
    dvec3v  += reflect(dvec3v, dvec3v);
    dvec4v  += reflect(dvec4v, dvec4v);

    doublev += refract(doublev, doublev, doublev);
    dvec2v  += refract(dvec2v, dvec2v, doublev);
    dvec3v  += refract(dvec3v, dvec3v, doublev);
    dvec4v  += refract(dvec4v, dvec4v, doublev);

    dmat2   dmat2v   = outerProduct(dvec2v, dvec2v);
    dmat3   dmat3v   = outerProduct(dvec3v, dvec3v);
    dmat4   dmat4v   = outerProduct(dvec4v, dvec4v);
    dmat2x3 dmat2x3v = outerProduct(dvec3v, dvec2v);
    dmat3x2 dmat3x2v = outerProduct(dvec2v, dvec3v);
    dmat2x4 dmat2x4v = outerProduct(dvec4v, dvec2v);
    dmat4x2 dmat4x2v = outerProduct(dvec2v, dvec4v);
    dmat3x4 dmat3x4v = outerProduct(dvec4v, dvec3v);
    dmat4x3 dmat4x3v = outerProduct(dvec3v, dvec4v);

    dmat2v *= matrixCompMult(dmat2v, dmat2v);
    dmat3v *= matrixCompMult(dmat3v, dmat3v);
    dmat4v *= matrixCompMult(dmat4v, dmat4v);
    dmat2x3v = matrixCompMult(dmat2x3v, dmat2x3v);
    dmat2x4v = matrixCompMult(dmat2x4v, dmat2x4v);
    dmat3x2v = matrixCompMult(dmat3x2v, dmat3x2v);
    dmat3x4v = matrixCompMult(dmat3x4v, dmat3x4v);
    dmat4x2v = matrixCompMult(dmat4x2v, dmat4x2v);
    dmat4x3v = matrixCompMult(dmat4x3v, dmat4x3v);

    dmat2v   *= transpose(dmat2v);
    dmat3v   *= transpose(dmat3v);
    dmat4v   *= transpose(dmat4v);
    dmat2x3v  = transpose(dmat3x2v);
    dmat3x2v  = transpose(dmat2x3v);
    dmat2x4v  = transpose(dmat4x2v);
    dmat4x2v  = transpose(dmat2x4v);
    dmat3x4v  = transpose(dmat4x3v);
    dmat4x3v  = transpose(dmat3x4v);

    doublev += determinant(dmat2v);
    doublev += determinant(dmat3v);
    doublev += determinant(dmat4v);

    dmat2v *= inverse(dmat2v);
    dmat3v *= inverse(dmat3v);
    dmat4v *= inverse(dmat4v);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[400.tesc]=[
#version 400 core

layout(vertices = 4) out;
int outa[gl_out.length()];

layout(quads) in;                   // ERROR
layout(ccw) out;                    // ERROR
layout(fractional_even_spacing) in; // ERROR

patch in vec4 patchIn;              // ERROR
patch out vec4 patchOut;

void main()
{
    barrier();

    int a = gl_MaxTessControlInputComponents +
            gl_MaxTessControlOutputComponents +
            gl_MaxTessControlTextureImageUnits +
            gl_MaxTessControlUniformComponents +
            gl_MaxTessControlTotalOutputComponents;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;
    gl_out[gl_InvocationID].gl_ClipDistance[1] = cd;

    gl_TessLevelOuter[3] = 3.2;
    gl_TessLevelInner[1] = 1.3;

    if (a > 10)
        barrier();           // ERROR
    else
        barrier();           // ERROR

    barrier();

    do {
        barrier();           // ERROR
    } while (a > 10);

    switch (a) {
    default:
        barrier();           // ERROR
        break;
    }
    a < 12 ? a : (barrier(), a); // ERROR
    {
        barrier();
    }

    return;

    barrier();               // ERROR
}

layout(vertices = 4) in;    // ERROR
layout(vertices = 5) out;   // ERROR

void foo()
{
    gl_out[4].gl_PointSize;  // ERROR

    barrier();                // ERROR
}

in vec2 ina;   // ERROR, not array
in vec2 inb[];
in vec2 inc[18];  // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];

#extension GL_ARB_separate_shader_objects : enable

layout(location = 3) in vec4 ivla[];
layout(location = 4) in vec4 ivlb[];
layout(location = 4) in vec4 ivlc[];  // ERROR, overlapping

layout(location = 3) out vec4 ovla[];
layout(location = 4) out vec4 ovlb[];
layout(location = 4) out vec4 ovlc[];  // ERROR, overlapping

precise vec3 pv3;

void foop()
{
    precise double d;

    pv3 *= pv3;
    pv3 = fma(pv3, pv3, pv3);
    d = fma(d, d, d);
}

patch out pinbn {
    int a;
} pinbi;

invariant precise out vec4 badOrder[]; // ERROR, precise must appear first
void badp(out precise float f);        // ERROR, precise must appear first

void devi()
{
    gl_DeviceIndex; // ERROR, no extension
    gl_ViewIndex;   // ERROR, no extension
}

#ifdef GL_EXT_device_group
#extension GL_EXT_device_group : enable
#endif

#ifdef GL_EXT_multiview
#extension GL_EXT_multiview : enable
#endif

void devie()
{
    gl_DeviceIndex;
    gl_ViewIndex;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[400.tese]=[
#version 400 core

layout(vertices = 4) out; // ERROR
layout(quads, cw) in;
layout(triangles) in;     // ERROR
layout(isolines) in;      // ERROR

layout(ccw) in;           // ERROR
layout(cw) in;

layout(fractional_odd_spacing) in;    
layout(equal_spacing) in;              // ERROR
layout(fractional_even_spacing) in;    // ERROR

layout(point_mode) in;

patch in vec4 patchIn;
patch out vec4 patchOut;  // ERROR

void main()
{
    barrier(); // ERROR

    int a = gl_MaxTessEvaluationInputComponents +
            gl_MaxTessEvaluationOutputComponents +
            gl_MaxTessEvaluationTextureImageUnits +
            gl_MaxTessEvaluationUniformComponents +
            gl_MaxTessPatchComponents +
            gl_MaxPatchVertices +
            gl_MaxTessGenLevel;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    vec3 tc = gl_TessCoord;
    float tlo = gl_TessLevelOuter[3];
    float tli = gl_TessLevelInner[1];

    gl_Position = p;
    gl_PointSize = ps;
    gl_ClipDistance[2] = cd;
}

smooth patch in vec4 badp1;         // ERROR
flat patch in vec4 badp2;           // ERROR
noperspective patch in vec4 badp3;  // ERROR
patch sample in vec3 badp4;         // ERROR

#extension GL_ARB_separate_shader_objects : enable

in gl_PerVertex
{
    float gl_ClipDistance[1];
} gl_in[];

in gl_PerVertex            // ERROR, second redeclaration of gl_in
{
    float gl_ClipDistance[1];
} gl_in[];

layout(quads, cw) out;     // ERROR
layout(triangles) out;     // ERROR
layout(isolines) out;      // ERROR
layout(cw) out;            // ERROR
layout(fractional_odd_spacing) out;    // ERROR
layout(equal_spacing) out;             // ERROR
layout(fractional_even_spacing) out;   // ERROR
layout(point_mode) out;                // ERROR

in vec2 ina;   // ERROR, not array
in vec2 inb[];
in vec2 inc[18];  // ERROR, wrong size
in vec2 ind[gl_MaxPatchVertices];

in testbla {
    int f;
} bla;        // ERROR, not array

in testblb {
    int f;
} blb[];

in testblc {
    int f;
} blc[18]; // ERROR wrong size

in testbld {
    int f;
} bld[gl_MaxPatchVertices];

layout(location = 23) in vec4 ivla[];
layout(location = 24) in vec4 ivlb[];
layout(location = 24) in vec4 ivlc[];  // ERROR

layout(location = 23) out vec4 ovla[2];
layout(location = 24) out vec4 ovlb[2];  // ERROR

in float gl_TessLevelOuter[4];           // ERROR, can't redeclare

patch in pinbn {
    int a;
} pinbi;

void devi()
{
    gl_DeviceIndex; // ERROR, no extension
    gl_ViewIndex;   // ERROR, no extension
}

#ifdef GL_EXT_device_group
#extension GL_EXT_device_group : enable
#endif

#ifdef GL_EXT_multiview
#extension GL_EXT_multiview : enable
#endif

void devie()
{
    gl_DeviceIndex;
    gl_ViewIndex;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[400.vert]=[
#version 400 core

in double d;   // ERROR, no doubles
in dvec3 d3;   // ERROR, no doubles
in dmat4 dm4;  // ERROR, no doubles

// function selection under type conversion
void foo1(double a, uint b)  {}
void foo1(double a, int b)   {}
void foo1(double a, float b) {}
void foo1(double a, double b){}

void foo2(double a, float b) {}
void foo2(double a, double b){}

void foo3(double a, float b) {}
void foo3(float a, double b) {}

void ftd(  int,  float, double) {}
void ftd( uint,  float, double) {}
void ftd(float, double, double) {}

void main()
{
    double d;
	uint u;
	int i;
	float f;

	foo1(d, d);
	foo1(d, u);
	foo1(d, i);
	foo1(d, f);

	foo1(f, d);
	foo1(f, u);
	foo1(f, i);
	foo1(f, f);

	foo1(u, d);
	foo1(u, u);
	foo1(u, i);
	foo1(u, f);

	foo1(i, d);
	foo1(i, u);
	foo1(i, i);
	foo1(i, f);

	foo2(d, d);
	foo2(d, u);
	foo2(d, i);
	foo2(d, f);

	foo2(f, d);
	foo2(f, u);
	foo2(f, i);
	foo2(f, f);

	foo2(u, d);
	foo2(u, u);
	foo2(u, i);
	foo2(u, f);

	foo2(i, d);
	foo2(i, u);
	foo2(i, i);
	foo2(i, f);

	foo3(d, d);  // ERROR, no match
	foo3(d, u);
	foo3(d, i);
	foo3(d, f);

	foo3(f, d);
	foo3(f, u); // ERROR, ambiguous
	foo3(f, i); // ERROR, ambiguous
	foo3(f, f); // ERROR, ambiguous

	foo3(u, d);
	foo3(u, u); // ERROR, ambiguous
	foo3(u, i); // ERROR, ambiguous
	foo3(u, f); // ERROR, ambiguous

	foo3(i, d);
	foo3(i, u); // ERROR, ambiguous
	foo3(i, i); // ERROR, ambiguous
	foo3(i, f); // ERROR, ambiguous

	ftd(i, f, f);
	ftd(u, f, f);
}

void itf(int, float, int);
void itf(int, double, int);

void tf()
{
    double d;
	uint u;
	int i;
	float f;
	
	itf(i, i, i);
	itf(i, u, i);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[410.geom]=[
#version 410 core

void main()
{
    gl_ViewportIndex = 7;
}

in gl_PerVertex {
    float gl_PointSize;
} myIn[];  // ERROR, can't redeclare a different name

in gl_PerVertex {
    float gl_PointSize;
} gl_myIn[];  // ERROR, can't redeclare a different name

in gl_PerVertex {
    float gl_PointSize;
} gl_in[];

in gl_PerVertex {
    float gl_PointSize;
} gl_in[];     // ERROR, can't do it again

out gl_PerVertex {
    float gl_PointSize;
};

void foo()
{
    float p = gl_in[1].gl_PointSize;  // use of redeclared
    gl_PointSize = p;                 // use of redeclared
    vec4 v = gl_in[1].gl_Position;    // ERROR, not included in the redeclaration
    gl_Position = vec4(1.0);          // ERROR, not included in the redeclaration
}

float foo5()
{
    return 4;  // implicit conversion of return type
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[410.tesc]=[
#version 400 core

// no layout(vertices = ...) out;
int outa[gl_out.length()];  // ERROR

patch out vec4 patchOut;

void main()
{

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[410.vert]=[
#version 410 core

in double d;
in dvec3 d3;
in dmat4 dm4;

void main()
{
    int test = gl_MaxFragmentUniformVectors;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.comp]=[
#version 420

layout(local_size_x = 2) in;  // ERROR, no compute

#extension GL_ARB_compute_shader : enable

layout(local_size_x = 2, local_size_y = 4, local_size_z = 6) in;

shared vec3 sfoo;

void main()
{
    sfoo = vec3(gl_WorkGroupSize.x, gl_WorkGroupSize.y, gl_WorkGroupSize.z);
    sfoo += gl_WorkGroupSize + gl_NumWorkGroups + gl_WorkGroupID + gl_LocalInvocationID + gl_GlobalInvocationID;
    sfoo *= gl_LocalInvocationIndex;
    sfoo += gl_MaxComputeWorkGroupCount + gl_MaxComputeWorkGroupSize;
    sfoo *= gl_MaxComputeUniformComponents +
            gl_MaxComputeTextureImageUnits +
            gl_MaxComputeImageUniforms +
            gl_MaxComputeAtomicCounters +
            gl_MaxComputeAtomicCounterBuffers;

    barrier();
    memoryBarrier();
    memoryBarrierAtomicCounter();
    memoryBarrierBuffer();
    memoryBarrierImage();
    memoryBarrierShared();
    groupMemoryBarrier();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.frag]=[
#version 420 core

layout(depth_any) out float gl_FragDepth;
layout(depth_greater) out float gl_FragDepth; // ERROR: redeclaration with different qualifier

void main()
{
    gl_FragDepth = 0.3;
}

layout(depth_less) in float depth; // ERROR: depth_less only applies to gl_FragDepth
layout(depth_any) out float gl_FragDepth;  // ERROR, done after use

layout(binding=0) uniform atomic_uint a[];

uniform writeonly image2D      i2D;
ivec2 iv2dim = imageSize(i2D); // ERROR: imageSize called without enabling GL_ARB_shader_image_size extension
#extension GL_ARB_shader_image_size : enable
ivec2 iv2dim1 = imageSize(i2D);

#extension GL_ARB_shader_storage_buffer_object : enable

layout(binding = 0,std430) buffer Buffer
{
    int atomi;
    uint atomu;
};

void atomicOpPass()
{
    int origi = atomicAdd(atomi, 3);
    uint origu = atomicAnd(atomu, 7u);
    origi = atomicExchange(atomi, 4);
    origu = atomicCompSwap(atomu, 10u, 8u);
}

layout(binding = 2,std430) buffer ssboElem01
{
    int member01;
    int memberArr01[2];
    int memberUnsizedArr01[];
} ssboStd430Arr[2];

// if turns on EShReflectionSharedStd140SSBO, SPIR-V would be different
layout(binding = 3,shared) buffer ssboElem02
{
    int member02;
    int memberArr02[2];
    int memberUnsizedArr02[];
} ssboSharedArr[2];

#extension GL_ARB_shader_storage_buffer_object : disable

layout(binding = 1,std430) buffer BufferFail // Error std430 and "buffer" block support disabled 
{
    int atom1i;
};

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.geom]=[
#version 420 core

// testing input arrays without a gl_in[] block redeclaration, see 400.geom for with

int i;

void foo()
{
    gl_in.length();  // ERROR
    gl_in[1].gl_Position;
    gl_in[i].gl_Position;  // ERROR
}

layout(triangles) in;

in vec4 color3[3];

void foo3()
{
    gl_in.length();
    gl_in[i].gl_Position;
    color3.length();
}

uniform sampler2D s2D;
in vec2 coord[];
uniform vec4 v4;

void foo4()
{
    const ivec2 offsets[5] =
    {
        ivec2(0,1),
        ivec2(1,-2),
        ivec2(0,3),
        ivec2(-3,0),
        ivec2(2,1)
    };

    vec4 v = textureGatherOffset(s2D, coord[0], offsets[i].xy);

    offsets[i].xy = ivec2(3);  // ERROR
    v4.x = 3.2;                // ERROR
    v4.xy;   // should have non-uniform type
}

out gl_PerVertex {
    float gl_PointSize[1];  // ERROR, adding array
    float gl_ClipDistance;  // ERROR, removing array
};

float foo5()
{
    return i;  // implicit conversion of return type
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.tesc]=[
#version 420 core

#extension GL_ARB_separate_shader_objects : enable

layout(vertices = 4) out;

out gl_PerVertex {
    vec4 gl_Position;
} gl_out[3];                 // ERROR, wrong size

out int a[gl_out.length()];
out int outb[5];             // ERROR, wrong size
out int outc[];

void main()
{
    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;        // ERROR
}

out float outf;  // ERROR, no array

layout (location = 0) in dmat2x4 vs_tcs_first[];
layout (location = 12) in dmat2x4 vs_tcs_last[];

void foo()
{
 if ((dmat2x4(dvec4(-0.625, -0.5, -0.375lf, -0.25), dvec4(-0.375, -0.25, -0.125, 0)) != vs_tcs_first[0]) ||
        (dmat2x4(dvec4(0.375, 0.5, 0.625, 0.75), dvec4(0.625, 0.75, 0.875, -0.625)) != vs_tcs_last[0]))
    {
        ;
    }
}

layout(vertices = 0) out;  // ERROR, can't be 0

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.tese]=[
#version 420 core

const mat2x2 a = mat2( vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
mat2x2 b = { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
const mat2x2 c = { { 1.0, 0.0, }, { 0.0, 1.0 } };

float a2[2] = { 3.4, 4.2, 5.0 }; // illegal
vec2 b2 = { 1.0, 2.0, 3.0 }; // illegal
mat3x3 c2 = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
mat2x2 d = { 1.0, 0.0, 0.0, 1.0 }; // illegal, can't flatten nesting

struct {
    float a;
    int b;
} e = { 1.2, 2, };

struct {
    float a;
    int b;
} e2 = { 1, 3 }; // legal, first initializer is converted

struct {
    float a;
    int b;
} e3 = { 1.2, 2, 3 }; // illegal

int a3 = true; // illegal
vec4 b3[2] = { vec4(0.0), 1.0 }; // illegal
vec4 b4[2] = vec4[2](vec4(0.0), mat2x2(1.0)); // illegal
mat4x2 c3 = { vec3(0.0), vec3(1.0) }; // illegal

struct S1 {
    vec4 a;
    vec4 b;
};

struct {
    float s;
    float t;
} d2[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal

float b5[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };

struct S3 {
    float f;
    mat2x3 m23;
};

struct S4 {
    uvec2 uv2;
    S3 s[2];
};

struct Single1 { int f; };
Single1 single1 = { 10 };

struct Single2 { uvec2 v; };
Single2 single2 = { { 1, 2 } };

struct Single3 { Single1 s1; };
Single3 single3 = { { 3 } };

struct Single4 { Single2 s1; };
Single4 single4 = { { { 4u, 5u } } };

const S4 constructed = S4(uvec2(1, 2), 
                          S3[2](S3(3.0, mat2x3(4.0)), 
                                S3(5.0, mat2x3(6.0))));

const S4 curlybad1 = { {1, 2},
                       { {3,   {4.0, 0, 0.0}, {0.0, 4.0, 0.0 } },       // ERROR, the mat2x3 isn't isolated
                         {5.0, {6, 0.0, 0.0}, {0.0, 6.0, 0.0 } } } }; 

const S4 curlyInit = { {1, 2},
                       { {3,   { {4.0, 0, 0.0}, {0.0, 4.0, 0.0 } } },
                         {5.0, { {6, 0.0, 0.0}, {0.0, 6.0, 0.0 } } } } }; 

float vc1, vc2, vc3;
vec3 av3 = vec3(vc1, vc2, vc3);
vec3 bv3 = { vc1, vc2, vc3 };

void main()
{
    memoryBarrier();

    if (constructed == curlybad1)
        ;
    if (constructed == curlyInit)
        ;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[420.vert]=[
#version 420 core
#version 420 core
varying vec2 v2;               // ERROR, varying reserved
in vec4 bad[10];
highp in vec4 badorder;
out invariant vec4 badorder2;
in centroid vec4 badorder4;    // ERROR, no centroid input to vertex stage
out flat vec4 badorder3;
void bar(in const float a);
void bar2(highp in float b);
smooth flat out vec4 rep;      // ERROR, replicating interpolation qualification
centroid sample out vec4 rep2; // ERROR, replicating auxiliary qualification
in uniform vec4 rep3;          // ERROR, replicating storage qualification

int anonconst;
const int aconst = 5;
const int a = aconst;
const int b = anonconst;       // ERROR at global scope

const int foo()                // ERROR, no const functions
{
    const int a = aconst;
    const int b = anonconst;
    const int c = a;          // still compile-time const
    const int d = b;          // not a compile-time const
    float x[c];               // okay
    float y[d];               // ERROR

    return b;
}

void main()
{
    int i;
    if (i == 3)
        int j = i;
    else
        int k = j;              // ERROR, j is undeclared
    int m = k;                  // ERROR, k is undeclared
    int n = j;                  // ERROR, j is undeclared

    while (true)
        int jj;
    int kk = jj;                // ERROR, jj is undeclared
}

const float cx = 4.20;
const float dx = 4.20;

void bar(in highp volatile vec4 v)
{
    int s;
    s.x;       // okay
    s.y;       // ERROR
    if (bad[0].x == cx.x)
        ;
    if (cx.x == dx.x)
        badorder3 = bad[0];

    float f;
    vec3 smeared = f.xxx;
    f.xxxxx;   // ERROR
    f.xxy;     // ERROR
}

layout(binding = 3) uniform;  // ERROR
layout(binding = 3) uniform boundblock { int aoeu; } boundInst;
layout(binding = 7) uniform anonblock { int aoeu; } ;
layout(location = 1) in;      // ERROR
layout(binding = 1) in inblock { int aoeua; };       // ERROR
layout(binding = 100000) uniform anonblock2 { int aooeu; } ;
layout(binding = 4) uniform sampler2D sampb1;
layout(binding = 5) uniform sampler2D sampb2[10];
layout(binding = 80) uniform sampler2D sampb3; // ERROR, binding too big
layout(binding = 31) uniform sampler2D sampb4;
layout(binding = 79) uniform sampler2D sampb5[2]; // ERROR, binding too big

int fgfg(float f, mediump int i);
int fgfg(float f, highp int i);

out gl_PerVertex {
    float gl_ClipDistance[4];
};

patch in vec4 patchIn;              // ERROR
patch out vec4 patchOut;            // ERROR

void bar23444()
{
    mat4x3 m43;  \
    float a1 = m43[3].y;
    vec3 v3;
    int a2 = m43.length();
    a2 += m43[1].length();
    a2 += v3.length();
    const float b = 2 * a1;
    int a = gl_MinProgramTexelOffset + gl_MaxProgramTexelOffset;
}

const int comma0 = (2, 3);  // ERROR
int comma1[(2, 3)];   // ERROR

layout(r32i) uniform iimage2D iimg2D;
layout(rgba32i) uniform iimage2D iimg2Drgba;
layout(rgba32f) uniform image2D img2Drgba;
layout(r32ui) uniform uimage2D uimg2D;
uniform image2DMS img2DMS; // ERROR image variables not declared writeonly must have format layout qualifier
uniform writeonly image2DMS img2DMSWO;
void qux()
{
    int i = aoeu;
    imageAtomicCompSwap(iimg2D, ivec2(i,i), i, i);
    imageAtomicAdd(uimg2D, ivec2(i,i), uint(i));
    imageAtomicMin(iimg2Drgba, ivec2(i,i), i); // ERROR iimg2Drgba does not have r32i layout
    imageAtomicMax(img2Drgba, ivec2(i,i), i);  // ERROR img2Drgba is not integer image
    ivec4 pos = imageLoad(iimg2D, ivec2(i,i));
    vec4 col = imageLoad(img2DMS, ivec2(i,i), i);
    imageStore(img2DMSWO, ivec2(i,i), i, vec4(0));
    imageLoad(img2DMSWO, ivec2(i,i), i);       // ERROR, drops writeonly
}

volatile float vol; // ERROR, not an image
readonly int vol2;  // ERROR, not an image

void passr(coherent readonly iimage2D image)
{
}

layout(r32i) coherent readonly uniform iimage2D qualim1;
layout(r32i) coherent volatile readonly uniform iimage2D qualim2;

void passrc()
{
    passr(qualim1);   // ERROR, changing formats
    passr(qualim2);   // ERROR, drops volatile, ERROR, changing formats
    passr(iimg2D);    // ERROR, changing formats
}

layout(rg8i) uniform uimage2D i1bad;     // ERROR, type mismatch
layout(rgba32i) uniform image2D i2bad;   // ERROR, type mismatch
layout(rgba32f) uniform uimage2D i3bad;  // ERROR, type mismatch
layout(r8_snorm) uniform iimage2D i4bad; // ERROR, type mismatch
layout(rgba32ui) uniform iimage2D i5bad; // ERROR, type mismatch
layout(r8ui) uniform iimage2D i6bad;     // ERROR, type mismatch

uniform offcheck {
    layout(offset = 16) int foo;   // ERROR
} offcheckI;

uniform sampler1D samp1D;
uniform sampler1DShadow samp1Ds;

void qlod()
{
    int levels;

    levels = textureQueryLevels(samp1D);   // ERROR, not until 430
    levels = textureQueryLevels(samp1Ds);  // ERROR, not until 430
}

layout(binding=0) writeonly uniform image1D badArray[];
layout(binding = 74) uniform sampler2D u_sampler0[6];

<><><><><><><><><><><><><><><><><><><><><><><><><>
2:1; [@8,19:25='version',<'version'>,2:1]; no viable alternative at input '#version'; NoViableAltException:null
]


testGlslangErrors[420_size_gl_in.geom]=[
#version 420 core

// testing input arrays without a gl_in[] block redeclaration, see 400.geom for with

int i;

layout(triangles) in;
in vec4 colorun[];
in vec4 color3[3];

void foo()
{
    gl_in.length();
    gl_in[1].gl_Position;
    gl_in.length();
    gl_in[i].gl_Position;   // should be sized to 3 by 'triangles'
}

in gl_PerVertex {  // ERROR, already used
    vec4 gl_Position;
} gl_in[];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[430.comp]=[
#version 430 core

layout(local_size_x = 2) in;
layout(local_size_x = 16) in;     // ERROR, changing
layout(local_size_z = 4096) in;   // ERROR, too large
layout(local_size_x = 2) in;

const int total = gl_MaxComputeWorkGroupCount.y 
                + gl_MaxComputeUniformComponents
                + gl_MaxComputeTextureImageUnits
                + gl_MaxComputeImageUniforms
                + gl_MaxComputeAtomicCounters
                + gl_MaxComputeAtomicCounterBuffers;

buffer ShaderStorageBlock
{
    int value;
    float values[];
};

buffer InvalidShaderStorageBlock
{
    float values[];
    int value;
} invalid;

void main()
{
    barrier();
    memoryBarrier();
    memoryBarrierAtomicCounter();
    memoryBarrierBuffer();
    memoryBarrierShared();
    memoryBarrierImage();
    groupMemoryBarrier();
    value = int(values[gl_LocalInvocationIndex]);

    int a;
    if (a > 10)
        barrier();
}

layout(location = 2) in vec3 v3;      // ERROR
in float f;                           // ERROR
out float fo;                         // ERROR

shared vec4 s;
layout(location = 2) shared vec4 sl;  // ERROR
shared float fs = 4.2;                // ERROR

layout(local_size_y = 1) in;
layout(local_size_y = 2) in;     // ERROR, changing
layout(local_size_y = 1) in;
layout(local_size_x = 2, local_size_y = 3, local_size_z = 4) out;  // ERROR

int arrX[gl_WorkGroupSize.x];
int arrY[gl_WorkGroupSize.y];
int arrZ[gl_WorkGroupSize.z];

readonly buffer roblock
{
    int value;
    float values[];
} ro;

void foo()
{
    ro.values[2] = 4.7;             // ERROR, readonly
    ro.values.length();
    barrier();
}

uniform double roll;
uniform writeonly image2D destTex;
void fooaoeu() {
     ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
     double localCoef = length(vec2(ivec2(gl_LocalInvocationID.xy)-8)/8.0);
     dvec4 aa = dvec4(0.4, 0.2, 0.3, 0.4);
     double globalCoef = 1.0;
     int i = globalCoef;            // ERROR, can't convert from double to int
     double di = i;
}

in inb {     // ERROR
    int a;
} inbi;

out outb {     // ERROR
    int a;
} outbi;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[430.vert]=[
#version 430 core

layout(location = 3) vec4 v4;  // ERROR

layout(location = 4) uniform vec4 uv4;

layout(location = 2) in   inb1 { vec4 v; } b1;  // ERROR
layout(location = 2) out outb1 { vec4 v; } b2;  // ERROR

out gl_PerVertex {
    float gl_ClipDistance[];
};

void foo()
{
    gl_ClipDistance[2] = 3.7;
}

struct sp {
    highp float f;
    in float g;             // ERROR
    uniform float h;        // ERROR
    invariant float i;      // ERROR
    volatile float j;       // ERROR
    layout(row_major) mat3 m3; // ERROR
};

void foo3(invariant vec4 v4,                 // ERROR
          volatile vec3 v3,
          layout(location = 3) vec2 v2,      // ERROR
          centroid vec3 cv3)                 // ERROR
{
}

struct S {
    mat3x2 m[7];  // needs 7*3 locations
    float f;      // needs 1 location
};                // needs 22 locations

layout(location = 10) out S cs[2];     // 10 through 10 + 2 * 22 - 1 = 53
layout(location = 54) out float cf;
layout(location = 53) out float cg; // ERROR, collision at 31

layout(location = 10) in vec4 alias1;
layout(location = 10) in vec4 alias2;  // okay for vertex input on desktop

out float gl_ClipDistance[17];  // ERROR, size too big

// enhanced_layouts (most tests are in 440.*)

layout(location = start*start - 2 - 4) in vec4 v6e;    // ERROR

layout(location = 28) in inblock2e {
    layout(location = 25) float f2;                     // ERROR
} ininst2e;

in ublock4e {
    layout(location = 50) float f1;                      // ERROR
    layout(location = 51) float f2;                      // ERROR
} in4e;

layout(align=16, std140) uniform  ubl4e { int a; } inst4e;// ERROR

layout(align=32) uniform ubl9e {                          // ERROR
    layout(offset=12, align=4) float f;                   // ERROR
    layout(offset=20) float g;                            // ERROR
} inst9e;

layout(std140) uniform blocke {
                        vec4   a;
    layout(offset = 32) vec3   b;                          // ERROR
} spinste;

int aconste[gl_MaxTransformFeedbackBuffers];               // ERROR
int bconste[gl_MaxTransformFeedbackInterleavedComponents]; // ERROR

out bblck2 {
    layout(xfb_offset=64) vec4 bbv;                              // ERROR
} bbinst2;

layout(xfb_buffer = 3, xfb_stride = 64) out;                     // ERROR

layout(xfb_buffer=2, xfb_offset=48, xfb_stride=80) out vec4 bge; // ERROR
layout(              xfb_offset=32, xfb_stride=64) out vec4 bhe; // ERROR

layout(xfb_stride=80, xfb_buffer=2, xfb_offset=16) out bblck4e { // ERROR
    vec4 bbv1;
    vec4 bbv2;
} bbinst4e;

out bblck5e {
    layout(xfb_offset=0) vec4 bbv1;                               // ERROR
    layout(xfb_stride=64, xfb_buffer=3, xfb_offset=48) vec4 bbv2; // ERROR
} bbinst5e;

#extension GL_ARB_enhanced_layouts : enable

layout(align=16, std140) uniform  ubl4 { int a; } inst4;
layout(std430) uniform;

layout(align=32) uniform ubl9 {
    layout(offset=12, align=4) float f;
    layout(offset=20) float g;
} inst9;

layout(std140) uniform block {
                        vec4   a;     // a takes offsets 0-15
    layout(offset = 32) vec3   b;     // b takes offsets 32-43
} spinst;

int aconst[gl_MaxTransformFeedbackBuffers];
int bconst[gl_MaxTransformFeedbackInterleavedComponents];

const int start2 = 5;
layout(location = start2 * start2 - 2 - 4) in vec4 v6;

layout(location = 28) in inblock2 {  // ERROR, input block in vertex shader, other errors are valid checks still...
    bool b1;
    float f1;
    layout(location = 25) float f2;
} ininst2;

in ublock4 {                         // ERROR, input block in vertex shader, other errors are valid checks still...
    layout(location = 50) float f1;
    layout(location = 51) float f2;
} in4;

out bblck2g {
    layout(xfb_offset=64) vec4 bbv;
} bbinst2g;

layout(xfb_buffer = 1, xfb_stride = 80) out;  // default buffer is 3

layout(xfb_buffer=1, xfb_offset=48, xfb_stride=80) out vec4 bg;
layout(              xfb_offset=32, xfb_stride=80) out vec4 bh;

layout(xfb_stride=80, xfb_buffer=1, xfb_offset=16) out bblck4 {
    vec4 bbv1;
} bbinst4;

out bblck5 {
    layout(xfb_offset=0) vec4 bbv1;
    layout(xfb_stride=80, xfb_buffer=1, xfb_offset=64) vec4 bbv2;
} bbinst5;

shared vec4 sharedv;                // ERROR

void fooBarrier()
{
    barrier();                       // ERROR
    memoryBarrier();
    memoryBarrierAtomicCounter();
    memoryBarrierBuffer();
    memoryBarrierShared();           // ERROR
    memoryBarrierImage();
    groupMemoryBarrier();            // ERROR
}

buffer vec4 v;  // ERROR

uniform sampler2DMS s2dms;
uniform usampler2DMSArray us2dmsa;
layout(rgba32i) uniform iimage2DMS ii2dms;
layout(rgba32f) uniform image2DMSArray i2dmsa;

void fooq()
{
    int s = textureSamples(s2dms); // ERROR
    s += textureSamples(us2dmsa);  // ERROR
    s += imageSamples(ii2dms);     // ERROR
    s += imageSamples(i2dmsa);     // ERROR
}

#extension GL_ARB_shader_texture_image_samples : enable

void fooq2()
{
    int s = textureSamples(s2dms);
    s += textureSamples(us2dmsa); 
    s += imageSamples(ii2dms);    
    s += imageSamples(i2dmsa);    
}

uniform sampler1D samp1D;
uniform usampler2D usamp2D;
uniform isampler3D isamp3D;
uniform isamplerCube isampCube; 
uniform isampler1DArray isamp1DA;
uniform sampler2DArray samp2DA;
uniform usamplerCubeArray usampCubeA;

uniform sampler1DShadow samp1Ds;
uniform sampler2DShadow samp2Ds;
uniform samplerCubeShadow sampCubes;
uniform sampler1DArrayShadow samp1DAs;
uniform sampler2DArrayShadow samp2DAs;
uniform samplerCubeArrayShadow sampCubeAs;

uniform samplerBuffer sampBuf;
uniform sampler2DRect sampRect;

void qlod()
{
    int levels;

    levels = textureQueryLevels(samp1D);
    levels = textureQueryLevels(usamp2D);
    levels = textureQueryLevels(isamp3D);
    levels = textureQueryLevels(isampCube);
    levels = textureQueryLevels(isamp1DA);
    levels = textureQueryLevels(samp2DA);
    levels = textureQueryLevels(usampCubeA);

    levels = textureQueryLevels(samp1Ds);
    levels = textureQueryLevels(samp2Ds);
    levels = textureQueryLevels(sampCubes);
    levels = textureQueryLevels(samp1DAs);
    levels = textureQueryLevels(samp2DAs);
    levels = textureQueryLevels(sampCubeAs);

    levels = textureQueryLevels(sampBuf);    // ERROR
    levels = textureQueryLevels(sampRect);   // ERROR
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[430AofA.frag]=[
#version 430

float[4][5][6] many[1][2][3];

float gu[][7];
float gimp[][];    // ERROR, implicit inner
float g4[4][7];
float g5[5][7];

float[4][7] foo(float a[5][7])
{
    float r[7];
    r = a[2];
    float[](a[0], a[1], r, a[3]);              // ERROR, too few dims
    float[4][7][4](a[0], a[1], r, a[3]);       // ERROR, too many dims
    return float[4][7](a[0], a[1], r, a[3]);
    return float[][](a[0], a[1], r, a[3]);
    return float[][7](a[0], a[1], a[2], a[3]);
}

void bar(float[5][7]) {}

void main()
{
    {
        float gu[3][4][2];

        gu[2][4][1] = 4.0;                     // ERROR, overflow
    }
    vec4 ca4[3][2] = vec4[][](vec4[2](vec4(0.0), vec4(1.0)),
                              vec4[2](vec4(0.0), vec4(1.0)),
                              vec4[2](vec4(0.0), vec4(1.0)));
    vec4 caim[][2] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)));
    vec4 caim2[][] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)),
                              vec4[2](vec4(4.0), vec4(2.0)));
    vec4 caim3[3][] = vec4[][](vec4[2](vec4(4.0), vec4(2.0)),
                               vec4[2](vec4(4.0), vec4(2.0)),
                               vec4[2](vec4(4.0), vec4(2.0)));

    vec4 a4[3][2] = {vec4[](vec4(0.0), vec4(1.0)),
                     vec4[2](vec4(0.0), vec4(1.0)),
                     vec4[2](vec4(0.0), vec4(1.0)) };
    vec4 aim[][2] = {vec4[2](vec4(4.0), vec4(2.0)),
                     vec4[](vec4(4.0), vec4(2.0)),
                     vec4[2](vec4(4.0), vec4(2.0)) };
    vec4 aim2[][] = {vec4[2](vec4(4.0), vec4(2.0)),
                     vec4[2](vec4(4.0), vec4(2.0)),
                     vec4[](vec4(4.0), vec4(2.0)) };
    vec4 aim3[3][] = {vec4[2](vec4(4.0), vec4(2.0)),
                      vec4[2](vec4(4.0), vec4(2.0)),
                      vec4[2](vec4(4.0), vec4(2.0)) };

    vec4 bad2[3][] = {vec4[2](vec4(4.0), vec4(2.0)),              // ERROR
                      vec4[3](vec4(4.0), vec4(2.0), vec4(5.0)),
                      vec4[2](vec4(4.0), vec4(2.0)) };

    vec4 bad3[3][] = {vec4[3](vec4(4.0), vec4(2.0), vec4(5.0)),   // ERROR
                      vec4[2](vec4(4.0), vec4(2.0)),
                      vec4[2](vec4(4.0), vec4(2.0)) };

    vec4 bad4[4][] = {vec4[2](vec4(4.0), vec4(2.0)),              // ERROR
                      vec4[2](vec4(4.0), vec4(2.0)),
                      vec4[2](vec4(4.0), vec4(2.0)) };
.
.
    g4 = foo(g5);
    g5 = g4;           // ERROR, wrong types
    gu = g4;           // ERROR, not yet sized

    foo(gu);           // ERROR, not yet sized
    bar(g5);

    if (foo(g5) == g4)
        ;
    if (foo(g5) == g5)  // ERROR, different types
        ;

    float u[][7];
    u[2][2] = 3.0;
    float u[5][7];
    u[5][2] = 5.0;      // ERROR
    foo(u);
}

void foo3()
{
    float resize1[][5][7];
    resize1.length();           // ERROR
    resize1[1][4][5] = 2.0;
    resize1.length();           // ERROR
    float resize1[3][5][7];
    resize1.length();           // 3 in AST
    resize1[1].length();        // 5 in AST
    resize1[1][1].length();     // 7 in AST
    resize1[1][1][1].length();  // ERROR

    float resize2[][5][7];
    float resize2[3][4][7];     // ERROR, inner dim change

    float resize3[][5][7];
    float resize3[3][5][9];     // ERROR, inner dim changed

    float resize4[][5][7];
    int  resize4[3][5][7];      // ERROR, element type
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[430scope.vert]=[
#version 430 core

int f(int a, int b, int c)
{
	int a = b;  // ERROR, redefinition

    {
		float a = float(a) + 1.0; // okay
    }

	return a;
}

int f(int a, int b, int c);  // okay to redeclare

bool b;
float b(int a);      // ERROR: redefinition

float c(int a);
bool c;              // ERROR: redefinition

float f;             // ERROR: redefinition
float tan;           // okay, hides built-in function
float sin(float x);  // okay, can redefine built-in functions
float cos(float x)   // okay, can redefine built-in functions
{
	return 1.0;
}
bool radians(bool x) // okay, can overload built-in functions
{
    return true;
}

invariant gl_Position;

void main()
{
    int g();    // okay
    g();

    float sin; // okay
    sin;
    sin(0.7);  // ERROR, use of hidden function
    f(1,2,3);

    float f;    // hides f()
    f = 3.0;

    gl_Position = vec4(f);

    for (int f = 0; f < 10; ++f)
        ++f;

    int x = 1;
    { 
        float x = 2.0, /* 2nd x visible here */ y = x; // y is initialized to 2
        int z = z; // ERROR: z not previously defined.
    }
    {
        int x = x; // x is initialized to '1'
    }

    struct S 
    { 
        int x; 
    };
    {
        S S = S(0); // 'S' is only visible as a struct and constructor 
        S.x;        // 'S' is now visible as a variable
    }

    int degrees;
    degrees(3.2);  // ERROR, use of hidden built-in function
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[435.vert]=[
#version 435
void main() {}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[440.frag]=[
#version 440

// Note 'location'-only tests for enhanced layouts are in 330.frag
// Generic 'component' tests are in 440.vert

// a consumes components 2 and 3 of location 4
layout(location = 4, component = 2) in vec2 a; 

// b consumes component 1 of location 4
layout(location = 4, component = 1) in float b; 
layout(location = 4, component = 2) in vec2 h;  // ERROR, component overlap not okay for fragment in

layout(location = 3, component = 2) in vec3 c;  // ERROR: c overflows components 2 and 3

// e consumes beginning (components 0, 1 and 2) of each of 6 slots
layout(location = 20, component = 0) in vec3 e[6];

// f consumes last component of the same 6 slots 
layout(location = 20, component = 3) in float f[6];

layout(location = 30, component = 3) out int be;
layout(location = 30, component = 0) out vec3 bf;  // ERROR, not the same basic type

writeonly uniform;          // ERROR
readonly in;                // ERROR
flat out;                   // ERROR
mediump uniform;

layout(offset=12) uniform;  // ERROR
layout(offset=12) in;       // ERROR
layout(offset=12) out;      // ERROR

layout(align=16) uniform;   // ERROR
layout(align=16) in;        // ERROR
layout(align=16) out;       // ERROR

layout(offset=12) uniform  ubl1 { int a; } inst1;  // ERROR
layout(offset=12)      in inbl2 { int a; } inst2;  // ERROR
layout(offset=12)     out inbl3 { int a; } inst3;  // ERROR

layout(align=16, std140) uniform  ubl4 { int a; } inst4;
layout(align=16) uniform  ubl8 { int a; } inst8;  // ERROR, no packing
layout(align=16)      in inbl5 { int a; } inst5;  // ERROR
layout(align=16)     out inbl6 { int a; } inst6;  // ERROR

layout(offset=12) uniform vec4 v1;  // ERROR
layout(offset=12)      in vec4 v2;  // ERROR
layout(offset=12)     out vec4 v3;  // ERROR

layout(align=16) uniform vec4 v4;   // ERROR
layout(align=16)      in vec4 v5;   // ERROR
layout(align=16)     out vec4 v6;   // ERROR

layout(std140) in;                  // ERROR
layout(std140) uniform vec4 v7;     // ERROR

layout(align=48) uniform ubl7 {          // ERROR, not power of 2
    layout(offset=12, align=4) float f;  // ERROR, no packing
} inst7;

in ibl10 {
    layout(offset=12) float f;  // ERROR
    layout(align=4) float g;    // ERROR
} inst10;

layout(std430) uniform;

layout(align=32) uniform ubl9 {
    float e;
    layout(offset=12, align=4) float f;
    layout(offset=20) float g;
    float h;
} inst9;

uniform ubl11 {
    layout(offset=12, align=4) float f;
    float g;
} inst11;

layout(std140) uniform block {
                        vec4   a;     // a takes offsets 0-15
    layout(offset = 32) vec3   b;     // b takes offsets 32-43
    layout(offset = 40) vec2   c;     // ERROR, lies within previous member
    layout(align = 6)   double g;     // ERROR, 6 is not a power of 2
    layout(offset=68)   double h;     // ERROR, offset not aligned
} specExampleErrors;

layout(std140) uniform block2 {
                        vec4   a;     // a takes offsets 0-15
    layout(offset = 32) vec3   b;     // b takes offsets 32-43
    layout(offset = 48) vec2   d;     // d takes offsets 48-55
    layout(align = 16)  float  e;     // e takes offsets 64-67
    layout(align = 2)   double f;     // f takes offsets 72-79
    layout(offset = 80) float  h;     // h takes offsets 80-83
    layout(align = 64)  dvec3  i;     // i takes offsets 128-151
    layout(offset = 164, align = 8) float  j;     // j takes offsets 168-171
} specExample;

layout(std430) buffer block430 {
                        vec4   a;     // a takes offsets 0-15
    layout(offset = 32) vec3   b;     // b takes offsets 32-43
    layout(offset = 40) vec2   c;     // ERROR, lies within previous member
    layout(align = 6)   double g;     // ERROR, 6 is not a power of 2
    layout(offset=68)   double h;     // ERROR, offset not aligned
    layout(align = 0)   double i;     // ERROR, 0 not a power of 2
} specExampleErrors430;

layout(std430) buffer block2430 {
                        vec4   a;     // a takes offsets 0-15
    layout(offset = 32) vec3   b;     // b takes offsets 32-43
    layout(offset = 48) vec2   d;     // d takes offsets 48-55
    layout(align = 16)  float  e;     // e takes offsets 64-67
    layout(align = 2)   double f;     // f takes offsets 72-79
    layout(offset = 80) float  h;     // h takes offsets 80-83
    layout(align = 64)  dvec3  i;     // i takes offsets 128-151
    layout(offset = 164, align = 8) float  j;     // j takes offsets 168-171
} specExample430;

layout(std430, align = 128) buffer block24300 {
    vec4   a;
    vec3   b;
    vec2   d;
    float  e;
    double f;
    float  h;
    dvec3  i;
} specExample4300;

layout(std430, align = 128) buffer block24301 {
    vec4   a;
    vec3   b;
    vec2   d;
    layout(offset=388) float  e;
    layout(align=8) double f;
    float  h;
    dvec3  i;
} specExample4301;

int aconst[gl_MaxTransformFeedbackBuffers];
int bconst[gl_MaxTransformFeedbackInterleavedComponents];

sample in vec3 sampInArray[4];

void interp()
{
    interpolateAtCentroid(sampInArray[2].xy);
    interpolateAtSample(sampInArray[2].x.x, 2);
}

int layer()
{
    return gl_Layer;
}

// The std140 layout qualifier should NOT propagate all the way down to
// the vec3. It is unnecessary and it breaks downstream AST consumers,
// notably LunarGlass.

struct PointLight_t
{
    vec3 vPositionWs ;
} ;

layout( std140, row_major ) uniform PerViewLightData_t
{

    PointLight_t g_pointLightData [ 128 ] ;
} ;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[440.vert]=[
#version 440

// Note 'location' tests for enhanced layouts are in 330.frag

layout(location = 2, component = 2) in vec2 a; 
layout(location = 2, component = 1) in float b; 

layout(location = 3, component = 2) in vec3 c;      // ERROR: c overflows components 2 and 3

layout(location = 0, component = 3) in float d[4]; 

layout(location = 4, component = 0) in vec3 e[5];
layout(location = 4, component = 3) in float f[5];

layout(location = 9, component = 4) in float g[6];   // ERROR, component too big

layout(location = 4, component = 2) in vec2 h;       // component overlap okay for vertex in

layout(location = 3, component = 2) out vec2 i;
layout(location = 3, component = 0) out vec2 j;

layout(location = 4, component = 2) out vec2 k;
layout(location = 4, component = 2) out vec2 m;      // ERROR, component overlap

layout(location = 2, component = 2) out vec2 n;
layout(location = 2, component = 0) out vec3 p;      // ERROR, component overlap

layout(location = 10, component = 3) out float q[6]; 
layout(location = 10, component = 0) out vec3 r[6];

layout(location = 15, component = 3) out float s;    // ERROR, overlap
layout(location = 10, component = 1) out float t;    // ERROR, overlap

layout(location = 20, component = 2) out float u;
layout(location = 20, component = 0) out float v;
layout(location = 20, component = 3) out float w;
layout(location = 20, component = 1) out vec2 x;     // ERROR, overlap

layout(location = 30, component = 3) out vec2 y;     // ERROR, goes to component 4
layout(location = 31, component = 1) out vec4 z;     // ERROR, goes to component 4

layout(location = 32, component = 1) out mat4 ba;               // ERROR
layout(location = 33, component = 1) out struct S {int a;} Ss;  // ERROR
layout(location = 34, component = 1) out bn { int a;} bb;       // ERROR

layout(component = 1) out float bc;    // ERROR, no location

out blockname {
    layout(location = 40, component = 2) out float u;
    layout(location = 40, component = 0) out float v;
    layout(location = 40, component = 3) out float w;
    layout(location = 40, component = 1) out vec2 x;     // ERROR, overlap

    layout(location = 41, component = 3) out vec2 y;     // ERROR, goes to component 4
    layout(location = 42, component = 1) out vec4 z;     // ERROR, goes to component 4

    layout(location = 42, component = 1) out mat4 ba;    // ERROR
    layout(location = 43, component = 1) out S Ss;       // ERROR
} bd;

layout(location = 1, component = 1) out;                 // ERROR, no global setting

layout(location = 50, component = 3) out int be;
layout(location = 50, component = 0) out vec3 bf;

layout(location = 51, component = 1) out double dfo;     // ERROR, odd component
layout(location = 52, component = 2) out dvec2 dvo;      // ERROR, overflow
layout(location = 53) out double dfo2;
layout(location = 53, component = 2) out vec2 ffv2;      // okay, fits
layout(location = 54) out dvec4 dvec4out;                // uses up location 55 too
layout(location = 55) out float overf;                   // ERROR, collides with previous dvec4
layout(location = 56, component = 1) out vec2 df2o;
layout(location = 56, component = 3) out float sf2o;
layout(location = 57, component = 2) out vec2 dv3o;
layout(location = 57, component = 3) out float sf4o;     // ERROR, overlapping component
layout(location=58) out flat dvec3 dv3o2;                // uses part of location 59
layout(location=59, component=2) out flat double dfo3;   // okay, fits
layout(location=59, component=0) out flat double dfo4;   // ERROR, overlaps the dvec3 in starting in 58

out bblck1 {
    vec4 bbv;
} bbinst1;

out bblck2 {
    layout(xfb_offset=64) vec4 bbv;
} bbinst2;

layout(xfb_buffer = 3, xfb_stride = 64) out;  // default buffer is 3

out bblck3 {
    layout(xfb_offset=16) vec4 bbv;  // in xfb_buffer 3
} bbinst3;

uniform ubblck3 {
    layout(xfb_offset=16) vec4 bbv;  // ERROR, not in a uniform
} ubbinst3;

layout(xfb_buffer=2, xfb_offset=48, xfb_stride=80) out vec4 bg;
layout(              xfb_offset=32, xfb_stride=64) out vec4 bh;

layout(xfb_offset=48) out; // ERROR

layout(xfb_stride=80, xfb_buffer=2, xfb_offset=16) out bblck4 {
    vec4 bbv1;
    vec4 bbv2;
} bbinst4;

out bblck5 {
    layout(xfb_offset=0) vec4 bbv1;
    layout(xfb_stride=64, xfb_buffer=3, xfb_offset=48) vec4 bbv2;
    layout(xfb_buffer=2) vec4 bbv3;                               // ERROR, wrong buffer
} bbinst5;

out layout(xfb_buffer=2) bblck6 {
    layout(xfb_offset=0) vec4 bbv1;
    layout(xfb_stride=64, xfb_buffer=3, xfb_offset=32) vec4 bbv2; // ERROR, overlap 32 from bh, and buffer contradiction
    layout(xfb_buffer=2, xfb_offset=0) vec4 bbv3;                 // ERROR, overlap 0 from bbinst5
    layout(xfb_buffer=2) vec4 bbv5;
    layout(xfb_offset=24) float bbf6;                             // ERROR, overlap 24 from bbv1 in bbinst4
} bbinst6;

layout(xfb_stride=48) out;                   // ERROR, stride of buffer 3

layout(xfb_buffer=1) out;  // default buffer is 1
layout(xfb_offset=4) out float bj;
layout(xfb_offset=0) out ivec2 bk;           // ERROR, overlap 4

layout(xfb_buffer=3, xfb_stride=48) out;     // ERROR, stride of buffer 3 (default is now 3)
layout(xfb_stride=48) out float bl;          // ERROR, stride of buffer 3

layout(xfb_stride=48) out bblck7 {           // ERROR, stride of buffer 3
    layout(xfb_stride=64) vec4 bbv1;
    layout(xfb_stride=32) vec4 bbv2;         // ERROR, stride of buffer 3
} bbinst7;

struct S5 {
    int i;    // 4 bytes plus 4 byte hole
    double d; // 8 bytes
    float f;  // 4 bytes
};  // total size = 20

struct T {
    bool b;   // 4 plus 4 byte hole
    S5 s;     // 20 
    vec2 v2;  // 8
};  // total size = 36

out layout(xfb_buffer=0, xfb_offset=0, xfb_stride=92) bblck8 {  // ERROR, stride not multiple of 8
    bool b;    // offset 0
    T t;       // offset 8, size 40
    int i;     // offset 40 + 4 = 48
    mat3x3 m3; // offset 52
    float f;   // offset 52 + 9*4 = 88
    float g;   // ERROR, overflow stride
} bbinst8;

out layout(xfb_buffer=4) bblck9 {
    layout(xfb_offset=1) bool b;     // ERROR
    layout(xfb_offset=12) T t;       // ERROR
    layout(xfb_offset=52) mat3x3 m3; // non-multiple of 8 okay
    layout(xfb_offset=90) int i;     // ERROR
    layout(xfb_offset=98) double d;  // ERROR
    layout(xfb_offset=108) S s;      // non-multiple of 8 okay
} bbinst9;

layout(xfb_buffer=5, xfb_stride=6) out;     // link ERROR, stride not multiple of 4
layout(xfb_offset=0) out float bm;

layout(xfb_buffer=6, xfb_stride=2000) out;  // ERROR, stride too big

out layout(xfb_buffer=7, xfb_offset=0) bblck10 {  // link ERROR, implicit stride too big
    dmat4x4 m1;
    dmat4x4 m2;
    float f;
} bbinst10;

layout(xfb_buffer = 3) out;
layout(xfb_offset = 32) out gl_PerVertex {
    layout(xfb_buffer = 2) float gl_PointSize; // ERROR, change in xfb_buffer
    vec4 gl_Position;
};

int drawParamsBad()
{
    return gl_BaseVertexARB + gl_BaseInstanceARB + gl_DrawIDARB; // ERROR, extension not requested
}

#extension GL_ARB_shader_draw_parameters: enable

int drawParams()
{
    return gl_BaseVertexARB + gl_BaseInstanceARB + gl_DrawIDARB;
    gl_BaseVertexARB = 3;       // ERROR, can't write to shader 'in'
    gl_BaseInstanceARB = 3;     // ERROR, can't write to shader 'in'
    gl_DrawIDARB = 3;           // ERROR, can't write to shader 'in'
    glBaseInstanceARB;          // ERROR, not defined
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.comp]=[
#version 450 core
layout(local_size_x = 0) in; // ERROR, 0 not allowed

layout(binding=10000) uniform atomic_uint;     // ERROR

void main()
{
    shared float f;   // ERROR shared must be global
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.frag]=[
#version 450 core

in float in1;
in vec2 in2;
in vec3 in3;
in vec4 in4;

void main()
{
    vec2 v2 = dFdxFine(in2);
    vec3 v3 = dFdyCoarse(in3);
    vec4 v4 = fwidth(in4);
    v4 = dFdyFine(in4);
    v3 = dFdyFine(in3);
    float f = dFdx(in1) + dFdxFine(in1) + dFdxCoarse(in1);
    v4 = fwidthCoarse(in4) + fwidthFine(in4);

    float cull = gl_CullDistance[2];
    float consts = gl_MaxCullDistances + gl_MaxCombinedClipAndCullDistances + gl_MaxSamples;

    if (gl_HelperInvocation)
        ++v4;

    int sum = gl_MaxVertexImageUniforms +
              gl_MaxFragmentImageUniforms +
              gl_MaxComputeImageUniforms +
              gl_MaxCombinedImageUniforms +
              gl_MaxCombinedShaderOutputResources;

    bool b1, b3, b;
    uint uin;
    bvec2 b2 = mix(bvec2(b1), bvec2(b3), bvec2(b));
    uint um = mix(uin, uin, b);
    ivec3 im3 = mix(ivec3(uin), ivec3(uin), bvec3(b));
}

uniform sampler2DMS s2dms;
uniform usampler2DMSArray us2dmsa;
layout(rgba32i) uniform iimage2DMS ii2dms;
layout(rgba32f) uniform image2DMSArray i2dmsa;

void foo()
{
    int s = textureSamples(s2dms);
    s += textureSamples(us2dmsa);
    s += imageSamples(ii2dms);
    s += imageSamples(i2dmsa);
    float f = imageAtomicExchange(i2dmsa, ivec3(in3), 2, 4.5);
}

#extension GL_ARB_sparse_texture2: enable

uniform sampler2D               s2D;
uniform isampler2DArray         is2DArray;
uniform sampler2DRectShadow     s2DRectShadow;

in flat ivec2 offsets[4];
in vec2 c2;
in vec3 c3;

void testOffsets()
{
    vec4  texel  = vec4(0.0);
    ivec4 itexel = ivec4(0);
    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));
    sparseTextureGatherOffsetsARB(s2D, c2, constOffsets, texel);
    sparseTextureGatherOffsetsARB(is2DArray, c3, constOffsets, itexel, 2);
    sparseTextureGatherOffsetsARB(s2DRectShadow, c2, 2.0, constOffsets, texel);

    sparseTextureGatherOffsetsARB(s2D, c2, offsets, texel); // Error : Non constant offsets
    sparseTextureGatherOffsetsARB(is2DArray, c3, offsets, itexel, 2); // Error : Non constant offsets
    sparseTextureGatherOffsetsARB(s2DRectShadow, c2, 2.0, offsets, texel); // Error : Non constant offsets

}

in float gl_CullDistance[6];

float cull(int i)
{
    return (i >= 6) ? gl_CullDistance[5] : gl_CullDistance[i];
}

layout(location = 6) in bName1 {
    float f;
    layout(location = 7) float g;
    mat4 m;
} bInst1;
layout(location = 12) in bName2 {
    float f;
    layout(location = 13) float g;  // ERROR, location on array
} bInst2[3];

layout(early_fragment_tests) in float f; // ERROR, must be standalone

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.geom]=[
#version 450 core

in gl_PerVertex {
    float gl_CullDistance[3];
} gl_in[];

out gl_PerVertex {
    float gl_CullDistance[3];
};

layout(triangles) in;

void main()
{
    gl_in[3].gl_Position; // ERROR, out of range
    gl_CullDistance[2] = gl_in[1].gl_CullDistance[2];
}

layout(points) in float f[3];  // ERROR, must be standalone

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.tesc]=[
#version 450 core

in gl_PerVertex {
    float gl_CullDistance[3];
} gl_in[gl_MaxPatchVertices];

out gl_PerVertex {
    float gl_CullDistance[3];
} gl_out[4];

void main()
{
    gl_out[gl_InvocationID].gl_CullDistance[2] = gl_in[1].gl_CullDistance[2];
}

layout(location = 4) out bName1 {
    float f;
    layout(location = 5) float g;
} bInst1[2];
layout(location = 6) out bName2 {
    float f;
    layout(location = 7) float g;  // ERROR, location on array
} bInst2[2][3];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.tese]=[
#version 450 core

in gl_PerVertex {
    float gl_CullDistance[3];
} gl_in[gl_MaxPatchVertices];

out gl_PerVertex {
    float gl_CullDistance[3];
};

void main()
{
    gl_CullDistance[2] = gl_in[1].gl_CullDistance[2];
}

layout(equal_spacing)           in float f1[];  // ERROR, must be standalone
layout(fractional_even_spacing) in float f2[];  // ERROR, must be standalone
layout(fractional_odd_spacing)  in float f3[];  // ERROR, must be standalone
layout(cw)                      in float f4[];  // ERROR, must be standalone
layout(ccw)                     in float f5[];  // ERROR, must be standalone
layout(point_mode)              in float f6[];  // ERROR, must be standalone

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[450.vert]=[
#version 450 core

out gl_PerVertex {
    float gl_CullDistance[3];
};

void main()
{
    gl_CullDistance[2] = 4.5;
}

out bool outb;         // ERROR
out sampler2D outo;    // ERROR
out float outa[4];
out float outaa[4][2];
struct S { float f; };
out S outs;
out S[4] outasa;
out S outsa[4];
struct SA { float f[4]; };
out SA outSA;
struct SS { float f; S s; };
out SS outSS;

layout(binding = 0) uniform atomic_uint aui;
uint ui;

void foo()
{
    SS::f;
    atomicCounterAdd(aui, ui);           // ERROR, need 4.6
    atomicCounterSubtract(aui, ui);      // ERROR, need 4.6
    atomicCounterMin(aui, ui);           // ERROR, need 4.6
    atomicCounterMax(aui, ui);           // ERROR, need 4.6
    atomicCounterAnd(aui, ui);           // ERROR, need 4.6
    atomicCounterOr(aui, ui);            // ERROR, need 4.6
    atomicCounterXor(aui, ui);           // ERROR, need 4.6
    atomicCounterExchange(aui, ui);      // ERROR, need 4.6
    atomicCounterCompSwap(aui, ui, ui);  // ERROR, need 4.6

    int a = gl_BaseVertex + gl_BaseInstance + gl_DrawID; // ERROR, need 4.6

    bool b1;
    anyInvocation(b1);        // ERROR, need 4.6
    allInvocations(b1);       // ERROR, need 4.6
    allInvocationsEqual(b1);  // ERROR, need 4.6
}
; // ERROR: no extraneous semicolons

layout(location = 0) uniform locBlock {        // ERROR, no location uniform block
    int a;
};

layout(location = 0) buffer locBuffBlock {     // ERROR, no location on buffer block
    int b;
};

<><><><><><><><><><><><><><><><><><><><><><><><><>
30:6; [@212,481:481=':',<COLON>,30:6]; no viable alternative at input 'SS:'; NoViableAltException:null
]


testGlslangErrors[460.frag]=[
#version 460 core

struct S {
    float f;
    vec4 v;
};

in S s;

void main()
{
    interpolateAtCentroid(s.v);
    bool b1;
    b1 = anyInvocation(b1);
    b1 = allInvocations(b1);
    b1 = allInvocationsEqual(b1);
}

void attExtBad()
{
    // ERRORs, not enabled
    [[dependency_length(1+3)]] for (int i = 0; i < 8; ++i) { }
    [[flatten]]                if (true) { } else { }
}

#extension GL_EXT_control_flow_attributes : enable

void attExt()
{
    [[dependency_length(-3)]] do {  } while(true); // ERROR, not positive
    [[dependency_length(0)]] do {  } while(true);  // ERROR, not positive
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[460.vert]=[
#version 460 core

int i;
; // extraneous semicolon okay
float f;;;

void main()
{
    bool b1;
    float array[int(mod(float (7.1), float (4.0)))];
    b1 = anyInvocation(b1);
    b1 = allInvocations(b1);
    b1 = allInvocationsEqual(b1);
}
;
;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[GL_ARB_gpu_shader5.u2i.vert]=[
#version 150
#extension GL_ARB_gpu_shader5 : require

uniform int u1;
uniform int u2;
out   vec4 result;
void main()
{
    uint v = 0;
    v = uint(u2) - u1;  // implicit conversions
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[GL_EXT_shader_integer_mix.vert]=[
#version 330
#extension GL_EXT_shader_integer_mix: require
.
.
#if !defined GL_EXT_shader_integer_mix
#  error GL_EXT_shader_integer_mix is not defined
#elif GL_EXT_shader_integer_mix != 1
#  error GL_EXT_shader_integer_mix is not equal to 1
#endif

void main(void) { 
    gl_Position = vec4(0); 
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[Operations.frag]=[
#version 130

uniform ivec4 uiv4;
uniform vec4 uv4;
uniform bool ub;
uniform bvec4 ub41, ub42;
uniform float uf;
uniform int ui;
.
.
uniform uvec4 uuv4;
uniform uint uui;
.
.
void main()
{
    vec4 v;
	float f;
	bool b;
	bvec4 bv4;
	int i;

	uint u;
.
.
	// floating point
    v = radians(uv4);
    v += degrees(v);
    v += (i = ui*ui, sin(v));
    v += cos(v);
    v += tan(v);
    v += asin(v);
    v += acos(v);

    v += atan(v);
    v += sinh(v);
    v += cosh(v);
    v += tanh(v);
    v += asinh(v);
    v += acosh(v);
    v += atanh(v);

    v += pow(v, v);
    v += exp(v);
    v += log(v);
    v += exp2(v);
    v += log2(v);
    v += sqrt(v);
    v += inversesqrt(v);
    v += abs(v);
    v += sign(v);
    v += floor(v);
.
.
    v += trunc(v);
    v += round(v);
    v += roundEven(v);
.
.
    v += ceil(v);
    v += fract(v);
    v += mod(v, v);
	v += mod(v, v.x);
.
.
    v += modf(v, v);
.
.
    v += min(v, uv4);
    v += max(v, uv4);
    v += clamp(v, uv4, uv4);
    v += mix(v,v,v);
.
.
    v += mix(v,v,bv4);
    v += intBitsToFloat(ivec4(i));
    v += uintBitsToFloat(uv4);
    v += fma(v,v,v);
    v += frexp(v);
    v += ldexp(v);
    v += unpackUnorm2x16(v);
    v += unpackUnorm4x8(v);
    v += unpackSnorm4x8(v);
.
.
    v += step(v,v);
    v += smoothstep(v,v,v);
    v += step(uf,v);
    v += smoothstep(uf,uf,v);
    v += normalize(v);
    v += faceforward(v, v, v);
    v += reflect(v, v);
    v += refract(v, v, uf);
    v += dFdx(v);
    v += dFdy(v);
    v += fwidth(v);
	//noise*(v);
.
.
	// signed integer
	i += abs(ui);
	i += sign(i);
	i += min(i, ui);
	i += max(i, ui);
	i += clamp(i, ui, ui);

	floatsBitsToInt(v);
	packUnorm2x16(v);
	packUnorm4x8(v);
	packSnorm4x8(v);

	// unsigned integer
    u = abs(uui);
    u += sign(u);
    u += min(u, uui);
    u += max(u, uui);
    u += clamp(u, uui, uui);
    u += floatsBitToInt(v);
    u += packUnorm2x16(v);
    u += packUnorm4x8(v);
    i += uui & i;          // ERRORs, no int/uint conversions before 400
    i += uui ^ i;
    i += i | uui;

	// bool

	b = isnan(uf);
    b = isinf(v.y);

	b = any(lessThan(v, uv4));
	b = (b && any(lessThanEqual(v, uv4)));
    b = (b && any(greaterThan(v, uv4)));
    b = (b && any(greaterThanEqual(v, uv4)));
    b = (b && any(equal(ub41, ub42)));
    b = (b && any(notEqual(ub41, ub42)));
    b = (b && any(ub41));
    b = (b && all(ub41));
    b = (b && any(not(ub41)));
	
	i = ((i + ui) * i - ui) / i;
	i = i % ui;
	if (i == ui || i != ui && i == ui ^^ i != 2)
	    ++i;
	
	f = ((uf + uf) * uf - uf) / uf;

	f += length(v);
    f += distance(v, v);
    f += dot(v, v);
    f += dot(f, uf);
	f += cross(v.xyz, v.xyz).x;

	if (f == uf || f != uf && f != 2.0)
	    ++f;

    i &= ui;
    i |= 0x42;
    i ^= ui;
    i %= 17;
    i >>= 2;
    i <<= ui;
    i = ~i;
    b = !b;

    gl_FragColor = b ? vec4(i) + vec4(f) + v : v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[aggOps.frag]=[
#version 130

uniform sampler2D sampler;
varying mediump vec2 coord;

varying vec4 u, w;

struct s1 {
    int i;
    float f;
};

struct s2 {
    int i;
    float f;
	s1 s1_1;
};

uniform s1 foo1;
uniform s2 foo2a;
uniform s2 foo2b;

void main()
{
    vec4 v;
    s1 a[3], b[3];
    a = s1[3](s1(int(u.x), u.y), s1(int(u.z), u.w), s1(14, 14.0));
    b = s1[3](s1(17, 17.0), s1(int(w.x), w.y), s1(int(w.z), w.w));

    if (foo2a == foo2b)
        v = texture2D(sampler, coord);
    else
        v = texture2D(sampler, 2.0*coord);

    if (u == v)
        v *= 3.0;

    if (u != v)
        v *= 4.0;

    if (coord == v.yw)
        v *= 5.0;

    if (a == b)
        v *= 6.0;

    if (a != b)
        v *= 7.0;

	gl_FragColor =  v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[always-discard.frag]=[
#version 110
varying vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    float radius = sqrt(x*x + y*y);
    if (radius > 1.0) {
        if (radius > 1.1) {
            ++color;
        }

        gl_FragColor = color;

        if (radius > 1.2) {
            ++color;
        }

    }

    discard;

    // If we're near an edge, darken us a tiny bit
    if (radius >= 0.75)
        color -= abs(pow(radius, 16.0)/2.0);

    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[always-discard2.frag]=[
#version 110
varying vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    discard;
.
.
    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[atomicAdd.comp]=[
#version 320 es
layout(local_size_x = 1) in;

struct structType{
    int y[3];
};

layout(std430) buffer t2 {
    structType f;
} t;

buffer coherent Buffer { int x; };
int z;

void main() {
  atomicAdd(x, 1);
  atomicAdd(t.f.y[1], 1);
  atomicAdd(z, 1);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[atomicCounterARBOps.vert]=[
#version 450 core
#extension GL_ARB_shader_atomic_counters: enable
#extension GL_ARB_shader_atomic_counter_ops:enable

layout(binding = 0) uniform atomic_uint counter;

out highp vec4 vsColor;

void main(){
    vec4 outColor = vec4(1.0);
    uint ret;

    ret = atomicCounterAddARB(counter, 4u);
    ret = atomicCounterSubtractARB(counter, 4u);
    ret = atomicCounterMinARB(counter, 4u);
    ret = atomicCounterMaxARB(counter, 4u);
    ret = atomicCounterAndARB(counter, 4u);
    ret = atomicCounterOrARB(counter, 4u);
    ret = atomicCounterXorARB(counter, 4u);
    ret = atomicCounterExchangeARB(counter, 4u);
    ret = atomicCounterCompSwapARB(counter, 4u, 4u);

    uint after = atomicCounter(counter);
    if (after == ret)
        outColor = vec4(0.0);

    vsColor = outColor;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[atomic_uint.frag]=[
#version 420 core

layout(binding = 0) uniform atomic_uint counter;
layout(binding = 0, offset = 9) uniform atomic_uint counter;

uint func(atomic_uint c)
{
    return atomicCounterIncrement(c);
}

uint func2(out atomic_uint c) // ERROR
{
    return counter;           // ERROR, type mismatch
    return atomicCounter(counter);
}

void main()
{
     atomic_uint non_uniform_counter; // ERROR
     uint val = atomicCounter(counter);
     atomicCounterDecrement(counter);
}

layout(binding = 1, offset = 3) uniform atomic_uint countArr[4];
uniform int i;

void opac()
{
    counter + counter;  // ERROR
    -counter;           // ERROR
    int a[3];
    a[counter];         // ERROR
    countArr[2];
    countArr[i];
    counter = 4;        // ERROR
}

in atomic_uint acin;    // ERROR
atomic_uint acg;        // ERROR
uniform atomic_uint;
uniform atomic_uint aNoBind;                          // ERROR, no binding
layout(binding=0, offset=32) uniform atomic_uint aOffset;
layout(binding=0, offset=4) uniform atomic_uint;
layout(binding=0) uniform atomic_uint bar3;           // offset is 4
layout(binding=0) uniform atomic_uint ac[2];          // offset = 8
layout(binding=0) uniform atomic_uint ad;             // offset = 20
layout(offset=8) uniform atomic_uint bar4;            // ERROR, no binding
layout(binding = 0, offset = 12) uniform atomic_uint overlap;  // ERROR, overlapping offsets
layout(binding = 20) uniform atomic_uint bigBind;     // ERROR, binding too big

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[badChars.frag]=[
<invalid content>
]


testGlslangErrors[badMacroArgs.frag]=[
#version 400

#define m(a) a
m()
<><><><><><><><><><><><><><><><><><><><><><><><><>
4:1; [@10,33:33='(',<LPAREN>,4:1]; no viable alternative at input 'm('; NoViableAltException:null
]


testGlslangErrors[comment.frag]=[
	 
	  //
/* anotehn t* ontuh * / tnoahnt /* oo */
/* multi line...

ao */
/*  no escape \
oanot */
// escape nothing \o oeu
// escape newline \
still in a comment
// escape newline \

// a different comment
#version 430 core
in vec4 v;
void main() {}
.
.

<><><><><><><><><><><><><><><><><><><><><><><><><>
11:6; [@14,150:151='in',<'in'>,11:6]; no viable alternative at input 'still in'; NoViableAltException:null
]


testGlslangErrors[compoundsuffix.vert.glsl]=[
void main()
{
    gl_Position = vec4(1.0);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[conditionalDiscard.frag]=[
#version 110

uniform sampler2D tex;
varying vec2 coord;

void main (void)
{
    vec4 v = texture2D(tex, coord);

    if (v == vec4(0.1,0.2,0.3,0.4))
        discard;

    gl_FragColor = v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[constErrors.frag]=[
#version 330

in vec4 inVar;
out vec4 outVar;

const int constInt = 3;

uniform int uniformInt;

void main()
{
    const int a1 = 2;          // okay
    const int a2 = constInt;   // okay
    const int a3 = uniformInt; // error

    vec4 c[constInt];              // okay
    vec4 d[uniformInt];            // error
    vec4 e[constInt + uniformInt]; // error
    vec4 f[uniformInt + constInt]; // error

    vec4 g[int(sin(0.3)) + 1];     // okay
}

const struct S {
    vec3 v3;
    ivec2 iv2;
} s = S(vec3(3.0), ivec2(3, constInt + uniformInt));  // ERROR, non-const y componenent

const struct S2 {
    vec3 v3;
    ivec2 iv2;
    mat2x4 m;
} s2 = S2(vec3(3.0), ivec2(3, constInt), mat2x4(1.0, 2.0, 3.0, inVar.x, 5.0, 6.0, 7.0, 8.0));  // ERROR, non-constant matrix

const float f = 3; // okay, type conversion

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[constFold.frag]=[
#version 430

const int a = 1;
const int b = 2;
const int c = a + b; // 3
const int d = c - a; // 2
const float e = float(d); // 2.0
const float f = e * float(c); // 6.0
const float g = f / float(d); // 3.0

const vec2 pytho = vec2(3.0, 4.0);

in vec4 inv;
out vec4 FragColor;
out vec2 out2;
out vec4 out3;
out vec4 out4;
out ivec4 out5;
out vec3 out6;
out vec4 out7;
out vec4 out8;
out vec4 out9;
out vec4 out10;
out vec4 out11; 
out ivec2 out12;
out uvec3 out13;

void main()
{
    vec4 dx = dFdx(inv);
    const ivec4 v = ivec4(a, b, c, d);
    vec4 array2[v.y];                  // 2
    const ivec4 u = ~v;

    const float h = degrees(g); // 171.88

    FragColor = vec4(e, f, g, h);  // 2, 6, 3, 171.88

    vec4 array3[c];               // 3
    vec4 arrayMax[int(max(float(array2.length()), float(array3.length())))];
    vec4 arrayMin[int(min(float(array2.length()), float(array3.length())))];
    FragColor = vec4(arrayMax.length(), arrayMin.length(), sin(3.14), cos(3.14));  // 3, 2, .00159, -.999
    out2 = length(pytho) + normalize(pytho) + dFdx(pytho) + dFdy(pytho) + fwidth(pytho); // 5+3/5, 5+4/5
    out3 = vec4(exp(3.0), log(10.0), exp2(4.0), log2(256.0));  //  20.08, 2.3, 16, 8
    out4 = vec4(sqrt(100.0), inversesqrt(100.0), abs(-4.7), abs(10.9)); // 10, .1, 4.7, 10.9
    out5 = ivec4(abs(-8) + sign(0), abs(17), sign(-12), sign(9));  // 8, 17, -1, 1
    out6 = vec3(sign(-8.8), sign(18.0), sign(0.0)); // -1.0, 1.0, 0.0
    out7 = vec4(floor(4.2), ceil(-4.1), trunc(5.9), trunc(-5.9)); // 4, -4, 5, -5
    out8 = vec4(round(4.4), round(4.6), roundEven(4.5), roundEven(-5.5)); // 4, 5, 4, -6
    out9 = vec4(roundEven(7.5), roundEven(-4.5), fract(2.345), fract(-2.6)); // 8, -4, .345, 0.4
    out10 = vec4(isinf(4.0/0.0), isinf(-3.0/0.0), isinf(0.0/0.0), isinf(-93048593405938405938405.0));  // true, true, false, false -> 1.0, 1.0, 0.0, 0.0
    out11 = vec4(isnan(4.0/0.0), isnan(-3.0/0.0), isnan(0.0/0.0), isnan(-93048593405938405938405.0));  // false, false, true, false -> 0.0, 1.0, 0.0, 0.0
    out11 = vec4(tan(0.8), atan(1.029), atan(8.0, 10.0), atan(10000.0));                               // 1.029, 0.8, 0.6747, 1.57
    out11 = vec4(asin(0.0), asin(0.5), acos(0.0), acos(0.5));                                          // 0.0, .523599, 1.57, 1.047

    const vec4 v1 = vec4(1.0, 0.0, 0.5, -0.2);
    const vec4 v2 = vec4(0.2, 0.3, 0.4, 0.5);
    out11 = atan(v1, v2);                      // 1.373401, 0.0, 0.896055, -0.380506

    const ivec2 v3 = ivec2(15.0, 17.0);
    const ivec2 v4 = ivec2(17.0, 15.0);
    out12 = min(v3, 16);                      // 15, 16
    out12 = max(v3, v4);                      // 17, 17
    out2 = pow(vec2(v3), vec2(2.5, 3.0));     // 871.4, 4913
    out13 = clamp(uvec3(1, 20, 50), 10u, 30u);  // 10, 20, 30
    out2 = mix(vec2(3.0, 4.0), vec2(5.0, 6.0), bvec2(false, true));  // 3.0, 6.0
    out2 = mix(vec2(3.0, 4.0), vec2(5.0, 6.0), 0.25);  // 3.5, 4.5
    out2 = step(0.5, vec2(0.2, 0.6));                  // 0.0, 1.0
    out11 = smoothstep(50.0, 60.0, vec4(40.0, 51.0, 55.0, 70.0)); // 0.0, 0.028, 0.5, 1.0
}

const struct S {
    vec3 v3;
    ivec2 iv2;
    mat2x4 m;
} s = S(vec3(3.0), ivec2(3, a + b), mat2x4(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0));

void foo()
{
    float a[s.iv2.y];  // 3 element array
    a[0] = s.m[1].z;     // 7.0
    b % 0;  // int
    b / 0;
    e / 0;  -e / 0;  0.0 / 0.0;
    const uint ua = 5;
    const uvec2 ub = uvec2(6, 7);
    const uint uc = 8;
    ub % 4u;
    0u % uc;
    ub % 0u;
}

const mat2 m2 = mat2(2, 3, 4, 5);
const mat3 m3 = mat3(m2);
const int mc = int(m3[2][2]);
float a1[mc];
float a2[int(m3[2][1]) + 2];  // size 2
float a3[int(m3[1][0])];  // size 4
const vec2 v2 = vec2(1, 2);
const vec3 v3 = vec3(3, 4, 5);
float a4[uint(mat3(v2, v3, v2, v2)[2][2])];  // size 2

void foo2()
{
    a1[0]; // array size 1
    a2[0]; // array size 2
    a3[0]; // array size 4
    a4[0]; // array size 2
    v2[-1]; // ERROR
    v3[4];  // ERROR
    m3[0][-2];  // ERROR
    m2[-1][1];  // ERROR
    m3[1][3];   // ERROR
    m3[3][1];   // ERROR
    int p;
    p = -2147483647 / -1;
    p = -2147483648 / -1;
    p =  2147483647 / -1;
    float f = vec4(7.8 < 2.4 ? -1.333 : 1.444).a;
    f = vec4(inv.x < 2.4 ? -1.0 : 1.0).a;  // not folded, ensuring no propagation
}

const mat2 mm2 = mat2(1.0, 2.0, 3.0, 4.0);
const mat3x2 mm32 = mat3x2(10.0, 11.0, 12.0, 13.0, 14.0, 15.0);
const mat2 m22 = mat2(vec4(1.0, 2.0, 3.0, 4.0));
const mat3x4 mm34 = mat3x4(7.0);
const vec4 mv4 = vec4(m22);

void foo3()
{
    mat3x2 r32 = mm2 * mm32;
}

struct cag {
    int   i;
    float f;
    bool  b;
};
const cag a0[3] = cag[3](cag(3, 2.0, true), cag(1, 5.0, true), cag(1, 9.0, false));

void foo4()
{
    int a = int(a0[2].f);
}

const bool cval1 = all(bvec4(true, true, true, true));
const bool cval2 = all(bvec4(false, false, false, false));
const bool cval3 = all(bvec4(true, true, false, true));
const bool cval4 = any(bvec4(true, true, true, true));
const bool cval5 = any(bvec4(false, false, false, false));
const bool cval6 = any(bvec4(false, true, false, false));

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[constFoldIntMin.frag]=[
#version 460 core
#extension GL_AMD_gpu_shader_int16 : enable
#extension GL_ARB_gpu_shader_int64 : enable

void a(){
    int16_t u = -32768S / -1S; // SHRT_MIN
    int v = -2147483648 / -1; // INT_MIN
    int64_t w = -9223372036854775808L / -1L; // LLONG_MIN
    int16_t x = -32768S % -1S; // SHRT_MIN
    int y = -2147483648 % -1; // INT_MIN
    int64_t z = -9223372036854775808L % -1L; // LLONG_MIN
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[constantUnaryConversion.comp]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types : require

const bool bool_init = true;
const int8_t int8_t_init = int8_t(-1);
const int16_t int16_t_init = int16_t(-2);
const int32_t int32_t_init = int32_t(-3);
const int64_t int64_t_init = int64_t(-4);
const uint8_t uint8_t_init = uint8_t(1);
const uint16_t uint16_t_init = uint16_t(2);
const uint32_t uint32_t_init = uint32_t(3);
const uint64_t uint64_t_init = uint64_t(4);
const float16_t float16_t_init = float16_t(42.0);
const float32_t float32_t_init = float32_t(13.0);
const float64_t float64_t_init = float64_t(4.0);

const float16_t neg_float16_t_init = float16_t(-42.0);
const float32_t neg_float32_t_init = float32_t(-13.0);
const float64_t neg_float64_t_init = float64_t(-4.0);

#define TYPE_TO_TYPE(x, y) \
    const x y##_to_##x = x(y##_init)

#define TYPE_TO_TYPE_PREFIX(prefix, x, y) \
    const x prefix##_##y##_to_##x = x(prefix##_##y##_init)

#define TYPE_TO(x)              \
    TYPE_TO_TYPE(x, bool);      \
    TYPE_TO_TYPE(x, int8_t);    \
    TYPE_TO_TYPE(x, int16_t);   \
    TYPE_TO_TYPE(x, int32_t);   \
    TYPE_TO_TYPE(x, int64_t);   \
    TYPE_TO_TYPE(x, uint8_t);   \
    TYPE_TO_TYPE(x, uint16_t);  \
    TYPE_TO_TYPE(x, uint32_t);  \
    TYPE_TO_TYPE(x, uint64_t);  \
    TYPE_TO_TYPE(x, float16_t); \
    TYPE_TO_TYPE(x, float32_t); \
    TYPE_TO_TYPE(x, float64_t)

TYPE_TO(bool);
TYPE_TO(int8_t);
TYPE_TO(int16_t);
TYPE_TO(int32_t);
TYPE_TO(int64_t);
TYPE_TO(uint8_t);
TYPE_TO(uint16_t);
TYPE_TO(uint32_t);
TYPE_TO(uint64_t);
TYPE_TO(float16_t);
TYPE_TO(float32_t);
TYPE_TO(float64_t);

#define NEG_FLOAT_TO(x) \
    TYPE_TO_TYPE_PREFIX(neg, x, float16_t); \
    TYPE_TO_TYPE_PREFIX(neg, x, float32_t); \
    TYPE_TO_TYPE_PREFIX(neg, x, float64_t)

NEG_FLOAT_TO(bool);
NEG_FLOAT_TO(int8_t);
NEG_FLOAT_TO(int16_t);
NEG_FLOAT_TO(int32_t);
NEG_FLOAT_TO(int64_t);
NEG_FLOAT_TO(float16_t);
NEG_FLOAT_TO(float32_t);
NEG_FLOAT_TO(float64_t);

void main() {}

<><><><><><><><><><><><><><><><><><><><><><><><><>
42:7; [@273,1417:1417='(',<LPAREN>,42:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
43:7; [@279,1433:1433='(',<LPAREN>,43:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
44:7; [@285,1451:1451='(',<LPAREN>,44:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
45:7; [@291,1470:1470='(',<LPAREN>,45:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
46:7; [@297,1489:1489='(',<LPAREN>,46:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
47:7; [@303,1508:1508='(',<LPAREN>,47:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
48:7; [@309,1527:1527='(',<LPAREN>,48:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
49:7; [@315,1547:1547='(',<LPAREN>,49:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
50:7; [@321,1567:1567='(',<LPAREN>,50:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
51:7; [@327,1587:1587='(',<LPAREN>,51:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
52:7; [@333,1608:1608='(',<LPAREN>,52:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
53:7; [@339,1629:1629='(',<LPAREN>,53:7]; no viable alternative at input 'TYPE_TO('; NoViableAltException:null
60:12; [@356,1824:1824='(',<LPAREN>,60:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
61:12; [@362,1845:1845='(',<LPAREN>,61:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
62:12; [@368,1868:1868='(',<LPAREN>,62:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
63:12; [@374,1892:1892='(',<LPAREN>,63:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
64:12; [@380,1916:1916='(',<LPAREN>,64:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
65:12; [@386,1940:1940='(',<LPAREN>,65:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
66:12; [@392,1966:1966='(',<LPAREN>,66:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
67:12; [@398,1992:1992='(',<LPAREN>,67:12]; no viable alternative at input 'NEG_FLOAT_TO('; NoViableAltException:null
]


testGlslangErrors[contradict_0.geom]=[
#version 330

layout(points) in;
layout(triangle_strip, max_vertices = 4) out;

float getV();

void main (void)
{
    float v = getV();
    EndPrimitive();
    EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[contradict_1.geom]=[
#version 330

layout(lines) in;
layout(line_strip, max_vertices = 6) out;

float getV()
{
    return 1.0;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[conversion.frag]=[
#version 130

uniform bool  u_b;
uniform bvec2 u_b2;
uniform bvec3 u_b3;
uniform bvec4 u_b4;

uniform int   u_i;
uniform ivec2 u_i2;
uniform ivec3 u_i3;
uniform ivec4 u_i4;
 
uniform float u_f;
uniform vec2 u_f2;
uniform vec3 u_f3;
uniform vec4 u_f4;

uniform bool  i_b;
uniform bvec2 i_b2;
uniform bvec3 i_b3;
uniform bvec4 i_b4;

flat in int   i_i;
flat in ivec2 i_i2;
flat in ivec3 i_i3;
flat in ivec4 i_i4;

in float i_f;
in vec2 i_f2;
in vec3 i_f3;
in vec4 i_f4;

void main()
{
    bool   b = bool(u_i) ^^ bool(u_f);
    bvec2 b2 = bvec2(u_i, u_f);
    bvec3 b3 = bvec3(u_i, u_f, i_i);
    bvec4 b4 = bvec4(u_i, u_f, i_i, i_f);

    int    i = int(u_f)    + int(b);
    ivec2 i2 = ivec2(u_f2) + ivec2(b2);
    ivec3 i3 = ivec3(u_f3) + ivec3(b3);
    ivec4 i4 = ivec4(u_f4) + ivec4(b4);

    float f = i;
    vec2 f2 = i2;
    vec3 f3 = i3;
    vec4 f4 = i4;

    f  += (float(i) + float(b));
    f2 -= vec2(i2) + vec2(b2);
    f3 /= vec3(i3) + vec3(b3);
    f4 += vec4(i4) + vec4(b4);

    f4 += vec4(bvec4(i_i4));
    f4 += vec4(bvec4(u_f4));
    
    f  += f                 - i;
    f2 += vec2(f, i)       + i2;
    f3 += i3 + vec3(f, i, f);
    f4 += vec4(b, i, f, i) + i4;
    
    f2 += vec2(f, i)       * i;
    f3 += vec3(f, i, f)    + i;
    f4 += i - vec4(b, i, f, i);

    i2 += ivec2(f, i);
    i3 += ivec3(f, i, f);
    i4 += ivec4(b, i, f, i);

    if (f < i || i < f ||
        f2 == i2 ||
        i3 != f3)
        f = (b ? i : f2.x) + (b2.x ? f3.x : i2.y);

    gl_FragColor = 
        b || 
        b2.x ||
        b2.y ||
        b3.x ||
        b3.y ||
        b3.z ||
        b4.x ||
        b4.y ||
        b4.z ||
        b4.w ? vec4(
        i  +
        i2.x +
        i2.y +
        i3.x +
        i3.y +
        i3.z +
        i4.x +
        i4.y +
        i4.z +
        i4.w +
        f  +
        f2.x +
        f2.y +
        f3.x +
        f3.y +
        f3.z +
        f4.x +
        f4.y +
        f4.z +
        f4.w) : vec4(1.0);

    // with constants...
    ivec4 cv2 = ivec4(1.0);
    bvec4 cv5 = bvec4(cv2);
    gl_FragColor += float(cv5);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[dataOut.frag]=[
#version 130 

varying vec4 Color;

void main()
{
    gl_FragData[1] = Color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[dataOutIndirect.frag]=[
#version 130 

varying vec4 Color;

uniform int i;

void main()
{
    gl_FragData[i] = Color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[dce.frag]=[
#version 400

const bool flag = false;

int c = 0;

void bar()
{
    if (flag)
        ++c;  // should still show up in AST
    else
        ++c;

    flag ? ++c : ++c;  // both should still show up in AST

    switch (c) {
    case 1:
        ++c;
        break;
        ++c;  // should still show up in AST
    case 2:
        break;
        ++c;  // should still show up in AST
    default:
        break;
    }

    for (int i = 0; i < 0; ++i)
        ++c;  // should still show up in AST

    for (int i = 0; i < 10; ++i) {
        if (c < 3) {
            break; 
            ++c;    // should still show up in AST
        } else {
            continue;
            ++c;    // should still show up in AST
        }
    }

    return;

    ++c;      // should still show up in AST
}

int foo()     // not called, but should still show up in AST
{
    if (c > 4) {
        return 4;
        ++c;   // should still show up in AST
    }

    return 5;

    ++c;       // should still show up in AST
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[decls.frag]=[
#version 120

int a;
int b, c;
int d1 = 1;
int e2 = 2, f;
int g, h3 = 3;

int i4[4];
int j, k5[5];
int m6[6], m7[7];
int n8[8], p;

int ii4[4] = int[](1, 2, 3, 4);
int ij, ik5[5] = int[](5, 6, 7, 8, 9);
int im2[2] = int[](10, 11), im3[3] = int[](12, 13, 14);
int in8[4] = int[](21, 22, 23, 24), ip;

void vi4[4] = int[](1, 2, 3, 4);
void vj, vk5[5] = int[](5, 6, 7, 8, 9);
void vm2[2] = int[](10, 11), vm3[3] = int[](12, 13, 14);
void vn8[4] = int[](21, 22, 23, 24), vp;

const int cii4[4] = int[](1, 2, 3, 4);
const int cij, cik5[5] = int[](5, 6, 7, 8, 9);
const int cim2[2] = int[](10, 11), cim3[3] = int[](12, 13, 14);
const int cin8[4] = int[](21, 22, 23, 24), cip;

uniform int uii4[4] = int[](1, 2, 3, 4);
uniform int uij, uik5[5] = int[](5, 6, 7, 8, 9);
uniform int uim2[2] = int[](10, 11), uim3[3] = int[](12, 13, 14);
uniform int uin8[4] = int[](21, 22, 23, 24), uip;

int gl_vi4[4] = int[](1, 2, 3, 4);
int gl_vj, gl_vk5[5] = int[](5, 6, 7, 8, 9);
int gl_vm2[2] = int[](10, 11), gl_vm3[3] = int[](12, 13, 14);
int gl_vn8[4] = int[](21, 22, 23, 24), gl_vp;

void main()
{
    while (bool cond = b < c);
    while (int icond = b);
    while (bool gl_cond = b < c);
}

int foob__vi4[4] = int[](1, 2, 3, 4);
int foob__vj, foob__vk5[5] = int[](5, 6, 7, 8, 9);
int __foobvm2[2] = int[](10, 11), __foobvm3[3] = int[](12, 13, 14);
int foob__vn8[4] = int[](21, 22, 23, 24), foob__vp;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[deepRvalue.frag]=[
#version 120

uniform sampler2D sampler;

vec4 v1 = vec4(2.0, 3.0, 5.0, 7.0);
vec4 v2 = vec4(11.0, 13.0, 17.0, 19.0);
vec4 v3 = vec4(23.0, 29.0, 31.0, 37.0);
vec4 v4 = vec4(41.0, 43.0, 47.0, 53.0);

struct str {
    int a;
    vec2 b[3];
    bool c;
};

void main()
{
    mat4 m = mat4(v1, v2, v3, v4);

    mat4 mm  = matrixCompMult(m, m);
    float f = mm[1].w; // should be 19 * 19 = 361

    // do a deep access to a spontaneous r-value
    float g = matrixCompMult(m, m)[2].y;  // should be 29 * 29 = 841

    float h = str(1, vec2[3](vec2(2.0, 3.0), vec2(4.0, 5.0), vec2(6.0, 7.0)), true).b[1][1];  // should be 5.0

    float i = texture2D(sampler, vec2(0.5,0.5)).y;

    i += (i > 0.1 ? v1 : v2)[3];

    str t;
    i += (t = str(1, vec2[3](vec2(2.0, 3.0), vec2(4.0, 5.0), vec2(6.0, 7.0)), true)).b[2].y;  // should be 7.0

    gl_FragColor = vec4(f, g, h, i);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[depthOut.frag]=[
#version 130

varying vec4 Color;
varying float Depth;

void main()
{
    gl_FragDepth = Depth;
    gl_FragColor = Color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[discard-dce.frag]=[
#version 110
varying vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    float radius = sqrt(x*x + y*y);
    if (radius > 1.0) {
        if (radius > 1.1) {
            ++color;
        }

        gl_FragColor = color;

        if (radius > 1.2) {
            ++color;
        }

        discard;
    }

    // If we're near an edge, darken us a tiny bit
    if (radius >= 0.75)
        color -= abs(pow(radius, 16.0)/2.0);

    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[doWhileLoop.frag]=[
#version 110

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

void main()
{
    vec4 color = BaseColor;

    do {
        color += bigColor;
    } while (color.x < d);

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[earlyReturnDiscard.frag]=[
#version 110

uniform float d;
uniform vec4 bigColor, smallColor;
uniform vec4 otherColor;

varying float c;

uniform float threshhold;
uniform float threshhold2;
uniform float threshhold3;

uniform float minimum;

varying vec4 BaseColor;

uniform bool b;

void main()
{
    vec4 color = BaseColor;
    vec4 color2;

    color2 = otherColor;

    if (c > d)
        color += bigColor;
    else
        color += smallColor;

    if (color.z < minimum)
        return;

    color.z++;

    if (color.z > threshhold)
        discard;

    color++;

    // Two path, different rest
    if (color.w > threshhold2) {
        if (color.z > threshhold2)
            return;
        else if (b)
            color.z++;
        else {
            if (color.x < minimum) {
                discard;
            } else {
                color++;
            }
        }
    } else {
        if (b)
            discard;
        else
            return;
    }
.
.
    // // Two path, shared rest
    // if (color.w > threshhold2) {
    //     if (color.z > threshhold2)
    //         return;
    //     else if (b)
    //         color++;
    //     else {
    //         if (color.x < minimum) {
    //             discard;
    //         } else {
    //             color++;
    //         }
    //     }
    // } else {
    //     if (b)
    //         discard;
    //     else
    //         return;
    // }
.
.
    // // One path
    // if (color.w > threshhold2) {
    //     if (color.z > threshhold2)
    //         return;
    //     else {
    //         if (color.x < minimum) {
    //             discard;
    //         } else {
    //             color++;
    //         }
    //     }
    // } else {
    //     if (b)
    //         discard;
    //     else
    //         return;
    // }

    gl_FragColor = color * color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[empty.frag]=[

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[empty2.frag]=[
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[empty3.frag]=[
#version 110

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[errors.frag]=[
int main(int foo)
{
    return 1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[es-link1.frag]=[
#version 100

mediump vec4 calculateColor();

void main()
{
    gl_FragColor = calculateColor();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[es-link2.frag]=[
#version 100

varying mediump vec4 varyingColor;

mediump vec4 calculateColor()
{
    return varyingColor * 0.5;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[findFunction.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable

int64_t func(int8_t a, int16_t b, int16_t c)
{
    return int64_t(a | b + c);
}

int64_t func(int8_t a, int16_t b, int32_t c)
{
    return int64_t(a | b - c);
}

int64_t func(int32_t a, int32_t b, int32_t c)
{
    return int64_t(a / b + c);
}

int64_t func(float16_t a, float16_t b, float32_t c)
{
    return int64_t(a - b * c);
}

int64_t func(float16_t a, int16_t b, float32_t c)
{
    return int64_t(a - b * c);
}

void main()
{
    int8_t  x;
    int16_t y;
    int32_t z;
    int64_t w;
    float16_t f16;
    float64_t f64;
    int64_t b1 = func(x, y, z);
    int64_t b2 = func(y, y, z); // tie
    int64_t b3 = func(y, y, w); // No match
    int64_t b4 = func(y, z, f16); // No match
    int64_t b5 = func(y, y, f16);
    int64_t b7 = func(f16, f16, y);
    int64_t b8 = func(f16, f16, f64); // No match
    int64_t b9 = func(f16, x, f16); // tie
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[flowControl.frag]=[
#version 120

uniform float d;
uniform vec4 bigColor, smallColor;
uniform vec4 otherColor;

varying float c;
varying vec4 BaseColor;

void main()
{
    vec4 color = BaseColor;
    vec4 color2;

    color2 = otherColor;

    if (c > d)
        color += bigColor;
    else
        color += smallColor;

    gl_FragColor = color * color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[forLoop.frag]=[
#version 130

uniform vec4 bigColor;
in vec4 BaseColor;
in float f;

uniform int Count;
uniform uvec4 v4;

void main()
{
    vec4 color = BaseColor;

    for (int i = 0; i < Count; ++i) {
        color += bigColor;
    }

    gl_FragColor = color;

    float sum = 0.0;
    for (int i = 0; i < 4; ++i)
        sum += v4[i];

    vec4 tv4;

    for (int i = 0; i < 4; ++i)
        tv4[i] = v4[i] * 4u;

    gl_FragColor += vec4(sum) + tv4;

    vec4 r;
    r.xyz = BaseColor.xyz;

    for (int i = 0; i < Count; ++i)
        r.w = f;

    gl_FragColor.xyz += r.xyz;

    for (int i = 0; i < 16; i += 4)
        gl_FragColor *= f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[forwardRef.frag]=[
#version 110

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

void bar();
float foo(vec4);
float unreachableReturn();

void main()
{
    vec4 color = vec4(foo(BaseColor));

    bar();
    float f = unreachableReturn();
    
    gl_FragColor = color * f;
}

void bar()
{
}

float unreachableReturn()
{
    bar();
    if (d < 4.2)
        return 1.2;
    else
        return 4.5;
}

float foo(vec4 bar)
{
    return bar.x + bar.y;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[functionCall.frag]=[
#version 130

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

float h = 0.0;

float foo(vec4 bar)
{
    return bar.x + bar.y;
}

void bar()
{
}

float unreachableReturn()
{
    if (d < 4.2)
        return 1.2;
    else
        return 4.5;
    // might be another return inserted here by builders, has to be correct type
}

float missingReturn()
{
    if (d < 4.5) {
        h = d;
        return 3.9;
    }
}

void main()
{
    vec4 color = vec4(foo(BaseColor));

    bar();
    float f = unreachableReturn();
    float g = missingReturn();
    
    gl_FragColor = color * f * h;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[functionSemantics.frag]=[
#version 400

uniform float u;

int foo(int a, const int b, in int c, const in int d, out int e, inout int f)
{
    int sum = a + b + c + d + f; // no e, it is out only
	// sum should be 47 now

	a *= 64;
	// no b, it is read only
	c *= 64;
	// no d, it is read only
	e = 64 * 16; // e starts undefined
	f *= 64;

	sum += a + 64 * b + c + 64 * d + e + f; // everything has a value now, totaling of 64(1+2+4+8+16+32) = 64*63 = 4032
	// sum should be 4032 + 47  = 4079
	
	return sum;
}

int foo2(float a, vec3 b, out int r)
{
    r = int(3.0 * a);
    return int(5.0 * b.y);
}

int foo3()
{
    if (u > 3.2) {
        discard;
        return 1000000;
    }

    return 2000000;
}

void main()
{
    int e;
	int t = 2;
	struct s {
	    ivec4 t;
	} f;
	f.t.y = 32;

    // test the different qualifers
    int color = foo(1, 2, t+t, 8, e, f.t.y);

	color += 128 * (e + f.t.y); // right side should be 128(64(16 + 32)) = 393216
	// sum should be 4079 + 393216 = 397295
    
    // test conversions
    float arg;
    float ret;
    ret = foo2(4, ivec3(1,2,3), arg);  // ret = 10, param = 12.0
    color += int(ret + arg); // adds 22, for total of 397317

    color += foo3();         // theoretically, add 2000000, for total of 2397317

    gl_FragColor = vec4(color);
}

vec3 m(vec2);
void aggCall()
{
    float F;
    m(ivec2(F));  // test input conversion of single argument that's an aggregate; other function tests in 120.vert
}

vec4 badConv()
{
    return u;     // ERROR, can change scalar to vector
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.-D-U.frag]=[
#version 450

#define IN_SHADER

layout(location=0) out vec4 color;

void main()
{
#if FOO==200
    color = vec4(1.0);
#else
    #error expected FOO 200
#endif

#ifdef IN_SHADER
    color++;
#else
    #error IN_SHADER was undef
#endif

#ifdef UNDEFED
    #error UNDEFED defined
#else
    color *= 3.0;
#endif

#if MUL == 400
    color *= MUL;
#else
    #error bad MUL
#endif
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.140.layoutOffset.error.vert]=[
#version 140

layout (std140) uniform UBO // offset can't use under version 140
{
    layout(offset = 0) vec4 a;
};

in  vec4 in_vs;
out vec4 out_vs;

void main()
{
    out_vs = in_vs + a;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.430.layoutOffset.error.vert]=[
#version 430 core

layout (std140) uniform UBO // offset can't use on 430 core with out extension require
{
    layout(offset = 0) vec4 a;
};

in  vec4 in_vs;
out vec4 out_vs;

void main()
{
    out_vs = in_vs + a;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroup.frag]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)         
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, only defined in compute
  gl_SubgroupID;                 // ERROR, only defined in compute
  subgroupMemoryBarrierShared(); // ERROR, only defined in compute

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable
layout(location = 0) out uvec4 data;
void main (void)
{
  data = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  int i;
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcast(f4, i);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  int i;
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadBroadcast(f4, i);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroup.geom]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, only defined in compute
  gl_SubgroupID;                 // ERROR, only defined in compute
  subgroupMemoryBarrierShared(); // ERROR, only defined in compute

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable
layout(points) in;
layout(points, max_vertices = 1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveIDIn] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroup.tesc]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, only defined in compute
  gl_SubgroupID;                 // ERROR, only defined in compute
  subgroupMemoryBarrierShared(); // ERROR, only defined in compute

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable
layout(vertices=1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroup.tese]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, only defined in compute
  gl_SubgroupID;                 // ERROR, only defined in compute
  subgroupMemoryBarrierShared(); // ERROR, only defined in compute

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable
layout(isolines) in;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroup.vert]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, only defined in compute
  gl_SubgroupID;                 // ERROR, only defined in compute
  subgroupMemoryBarrierShared(); // ERROR, only defined in compute

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_VertexID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupArithmetic.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_arithmetic: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupAdd(data[3].f4);

    data[invocation].i4.x   = subgroupAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAdd(data[3].i4);

    data[invocation].u4.x   = subgroupAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAdd(data[3].u4);

    data[invocation].d4.x   = subgroupAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupAdd(data[3].d4);

    data[invocation].f4.x   = subgroupMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupMul(data[3].f4);

    data[invocation].i4.x   = subgroupMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupMul(data[3].i4);

    data[invocation].u4.x   = subgroupMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupMul(data[3].u4);

    data[invocation].d4.x   = subgroupMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupMul(data[3].d4);

    data[invocation].f4.x   = subgroupMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupMin(data[3].f4);

    data[invocation].i4.x   = subgroupMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupMin(data[3].i4);

    data[invocation].u4.x   = subgroupMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupMin(data[3].u4);

    data[invocation].d4.x   = subgroupMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupMin(data[3].d4);

    data[invocation].f4.x   = subgroupMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupMax(data[3].f4);

    data[invocation].i4.x   = subgroupMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupMax(data[3].i4);

    data[invocation].u4.x   = subgroupMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupMax(data[3].u4);

    data[invocation].d4.x   = subgroupMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupMax(data[3].d4);

    data[invocation].i4.x   = subgroupAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAnd(data[3].i4);

    data[invocation].u4.x   = subgroupAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupOr(data[3].i4);

    data[invocation].u4.x   = subgroupOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupXor(data[3].i4);

    data[invocation].u4.x   = subgroupXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupInclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupInclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupExclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupExclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveXor(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupBallot.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[invocation].u4.x = subgroupBallotBitCount(result);
    data[invocation].u4.y = subgroupBallotBitExtract(result, 0) ? 1 : 0;
    data[invocation].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[invocation].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    if ((relMask == result) && subgroupInverseBallot(data[0].u4))
    {
        data[invocation].f4.x   = subgroupBroadcast(data[0].f4.x,    3);
        data[invocation].f4.xy  = subgroupBroadcast(data[1].f4.xy,   3);
        data[invocation].f4.xyz = subgroupBroadcast(data[2].f4.xyz,  3);
        data[invocation].f4     = subgroupBroadcast(data[3].f4,      3);

        data[invocation].i4.x   = subgroupBroadcast(data[0].i4.x,    2);
        data[invocation].i4.xy  = subgroupBroadcast(data[1].i4.xy,   2);
        data[invocation].i4.xyz = subgroupBroadcast(data[2].i4.xyz,  2);
        data[invocation].i4     = subgroupBroadcast(data[3].i4,      2);

        data[invocation].u4.x   = subgroupBroadcast(data[0].u4.x,    1);
        data[invocation].u4.xy  = subgroupBroadcast(data[1].u4.xy,   1);
        data[invocation].u4.xyz = subgroupBroadcast(data[2].u4.xyz,  1);
        data[invocation].u4     = subgroupBroadcast(data[3].u4,      1);

        data[invocation].d4.x   = subgroupBroadcast(data[0].d4.x,    0);
        data[invocation].d4.xy  = subgroupBroadcast(data[1].d4.xy,   0);
        data[invocation].d4.xyz = subgroupBroadcast(data[2].d4.xyz,  0);
        data[invocation].d4     = subgroupBroadcast(data[3].d4,      0);

        data[invocation].i4.x   = int(subgroupBroadcast(data[0].i4.x < 0,            1));
        data[invocation].i4.xy  = ivec2(subgroupBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1));
        data[invocation].i4.xyz = ivec3(subgroupBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1));
        data[invocation].i4     = ivec4(subgroupBroadcast(lessThan(data[1].i4, ivec4(0)), 1));
    }
    else
    {
        data[invocation].f4.x   = subgroupBroadcastFirst(data[0].f4.x);
        data[invocation].f4.xy  = subgroupBroadcastFirst(data[1].f4.xy);
        data[invocation].f4.xyz = subgroupBroadcastFirst(data[2].f4.xyz);
        data[invocation].f4     = subgroupBroadcastFirst(data[3].f4);

        data[invocation].i4.x   = subgroupBroadcastFirst(data[0].i4.x);
        data[invocation].i4.xy  = subgroupBroadcastFirst(data[1].i4.xy);
        data[invocation].i4.xyz = subgroupBroadcastFirst(data[2].i4.xyz);
        data[invocation].i4     = subgroupBroadcastFirst(data[3].i4);

        data[invocation].u4.x   = subgroupBroadcastFirst(data[0].u4.x);
        data[invocation].u4.xy  = subgroupBroadcastFirst(data[1].u4.xy);
        data[invocation].u4.xyz = subgroupBroadcastFirst(data[2].u4.xyz);
        data[invocation].u4     = subgroupBroadcastFirst(data[3].u4);

        data[invocation].d4.x   = subgroupBroadcastFirst(data[0].d4.x);
        data[invocation].d4.xy  = subgroupBroadcastFirst(data[1].d4.xy);
        data[invocation].d4.xyz = subgroupBroadcastFirst(data[2].d4.xyz);
        data[invocation].d4     = subgroupBroadcastFirst(data[3].d4);

        data[invocation].i4.x   = int(subgroupBroadcastFirst(data[0].i4.x < 0));
        data[invocation].i4.xy  = ivec2(subgroupBroadcastFirst(lessThan(data[1].i4.xy, ivec2(0))));
        data[invocation].i4.xyz = ivec3(subgroupBroadcastFirst(lessThan(data[1].i4.xyz, ivec3(0))));
        data[invocation].i4     = ivec4(subgroupBroadcastFirst(lessThan(data[1].i4, ivec4(0))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupBallotNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[invocation].u4.x = subgroupBallotBitCount(result);
    data[invocation].u4.y = subgroupBallotBitExtract(result, 0) ? 1 : 0;
    data[invocation].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[invocation].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    data[invocation].f4.x   = subgroupBroadcast(data[0].f4.x,    invocation);  // ERROR: not constant
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupBasic.comp]=[
#version 450

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, extension not enabled (basic)
  gl_SubgroupID;                 // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierShared(); // ERROR, extension not enabled (basic)

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#extension GL_KHR_shader_subgroup_basic: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffer
{
    int a[];
} data;

void main()
{
    data.a[gl_SubgroupSize] = 1;
    data.a[gl_SubgroupInvocationID] = 1;
    data.a[gl_NumSubgroups] = 1;
    data.a[gl_SubgroupID] = (subgroupElect()) ? 1 : 0;
    subgroupBarrier();
    subgroupMemoryBarrier();
    subgroupMemoryBarrierBuffer();
    subgroupMemoryBarrierShared();
    subgroupMemoryBarrierImage();
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupClustered.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupClusteredAdd(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredAdd(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredAdd(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredAdd(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredAdd(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredAdd(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredAdd(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredAdd(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredAdd(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredAdd(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredAdd(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredAdd(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredAdd(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredAdd(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredAdd(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMul(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMul(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMul(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMul(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMul(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMul(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMul(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMul(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMul(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMul(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMul(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMul(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMul(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMul(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMul(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMul(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMin(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMin(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMin(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMin(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMin(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMin(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMin(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMin(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMin(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMin(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMin(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMin(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMin(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMin(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMax(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMax(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMax(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMax(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMax(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMax(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMax(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMax(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMax(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMax(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMax(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMax(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMax(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMax(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMax(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMax(data[3].d4, 1);

    data[invocation].i4.x   = subgroupClusteredAnd(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredAnd(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredAnd(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredAnd(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredAnd(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredAnd(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredAnd(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredAnd(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredAnd(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredAnd(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredAnd(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredAnd(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].i4.x   = subgroupClusteredOr(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredOr(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredOr(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredOr(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredOr(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredOr(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredOr(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredOr(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredOr(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredOr(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredOr(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredOr(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].i4.x   = subgroupClusteredXor(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredXor(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredXor(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredXor(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredXor(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredXor(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredXor(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredXor(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredXor(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredXor(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredXor(lessThan(data[1].i4, ivec4(0)), 1));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupClusteredNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    int a = 1;
    const int aConst = 1;

    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 0);          // ERROR, less than 1

    data[invocation].f4.x   = subgroupClusteredMul(data[0].f4.x, 3);           // ERROR, not a power of 2

    data[invocation].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 8);
    data[invocation].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 6);         // ERROR, not a power of 2

    data[invocation].f4.x   = subgroupClusteredMax(data[0].f4.x, -1);          // ERROR, less than 1

    data[invocation].i4     = subgroupClusteredAnd(data[3].i4, -3);            // ERROR, less than 1

    data[invocation].i4.x   = subgroupClusteredOr(data[0].i4.x, a);            // ERROR, not constant
    data[invocation].i4.xy  = subgroupClusteredOr(data[1].i4.xy, aConst);

    data[invocation].i4.x   = subgroupClusteredXor(data[0].i4.x, 1 + a);       // ERROR, not constant
    data[invocation].i4.xy  = subgroupClusteredXor(data[1].i4.xy, aConst + a); // ERROR, not constant
    data[invocation].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, 1 + aConst);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupPartitioned.comp]=[
#version 450

#extension GL_NV_shader_subgroup_partitioned: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 ballot = subgroupPartitionNV(invocation);

    data[invocation].u4 = subgroupPartitionNV(data[0].f4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4);

    data[invocation].u4 = subgroupPartitionNV(data[0].i4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4);

    data[invocation].u4 = subgroupPartitionNV(data[0].u4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4);

    data[invocation].u4 = subgroupPartitionNV(data[0].d4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4);

    data[invocation].u4 = subgroupPartitionNV(bool(data[0].i4.x));
    data[invocation].u4 = subgroupPartitionNV(bvec2(data[0].i4.xy));
    data[invocation].u4 = subgroupPartitionNV(bvec3(data[0].i4.xyz));
    data[invocation].u4 = subgroupPartitionNV(bvec4(data[0].i4));

    data[invocation].f4.x   = subgroupPartitionedAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedInclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedExclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupQuad.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_quad: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupQuadBroadcast(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupQuadBroadcast(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupQuadBroadcast(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupQuadBroadcast(data[3].f4, 1);

    data[invocation].i4.x   = subgroupQuadBroadcast(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupQuadBroadcast(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupQuadBroadcast(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupQuadBroadcast(data[3].i4, 1);

    data[invocation].u4.x   = subgroupQuadBroadcast(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupQuadBroadcast(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupQuadBroadcast(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupQuadBroadcast(data[3].u4, 1);

    data[invocation].d4.x   = subgroupQuadBroadcast(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupQuadBroadcast(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupQuadBroadcast(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupQuadBroadcast(data[3].d4, 1);

    data[invocation].i4.x   =   int(subgroupQuadBroadcast(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupQuadBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupQuadBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupQuadBroadcast(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].f4.x   = subgroupQuadSwapHorizontal(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapHorizontal(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapHorizontal(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapHorizontal(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapHorizontal(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapHorizontal(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapHorizontal(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapHorizontal(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapHorizontal(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapHorizontal(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapHorizontal(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapHorizontal(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapHorizontal(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapHorizontal(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapHorizontal(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapHorizontal(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapHorizontal(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapHorizontal(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupQuadSwapVertical(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapVertical(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapVertical(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapVertical(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapVertical(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapVertical(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapVertical(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapVertical(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapVertical(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapVertical(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapVertical(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapVertical(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapVertical(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapVertical(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapVertical(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapVertical(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapVertical(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapVertical(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapVertical(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapVertical(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupQuadSwapDiagonal(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapDiagonal(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapDiagonal(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapDiagonal(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapDiagonal(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapDiagonal(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapDiagonal(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapDiagonal(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapDiagonal(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapDiagonal(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapDiagonal(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapDiagonal(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapDiagonal(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapDiagonal(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapDiagonal(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapDiagonal(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapDiagonal(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapDiagonal(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupShuffle.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupShuffle(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffle(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffle(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffle(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffle(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffle(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffle(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffle(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffle(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffle(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffle(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffle(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffle(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffle(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffle(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffle(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffle(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffle(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffle(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffle(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[invocation].f4.x   = subgroupShuffleXor(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleXor(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleXor(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleXor(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleXor(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleXor(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleXor(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleXor(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleXor(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleXor(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleXor(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleXor(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleXor(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleXor(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleXor(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleXor(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleXor(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleXor(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleXor(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleXor(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupShuffleRelative.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle_relative: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupShuffleUp(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleUp(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleUp(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleUp(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleUp(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleUp(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleUp(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleUp(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleUp(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleUp(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleUp(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleUp(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleUp(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleUp(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleUp(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleUp(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleUp(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleUp(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleUp(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleUp(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[invocation].f4.x   = subgroupShuffleDown(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleDown(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleDown(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleDown(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleDown(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleDown(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleDown(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleDown(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleDown(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleDown(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleDown(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleDown(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleDown(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleDown(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleDown(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleDown(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleDown(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleDown(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleDown(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleDown(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.450.subgroupVote.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_vote: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
    int r;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    if (subgroupAll(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].f4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].f4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].f4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].f4));

        data[invocation].r = int(subgroupAllEqual(data[0].i4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i4));

        data[invocation].r = int(subgroupAllEqual(data[0].u4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u4));
    }
    else if (subgroupAny(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].d4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].d4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].d4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].d4));

        data[invocation].r = int(int(subgroupAllEqual(data[0].i4.x < 0)));
        data[invocation].r = int(ivec2(subgroupAllEqual(lessThan(data[1].i4.xy, ivec2(0)))));
        data[invocation].r = int(ivec3(subgroupAllEqual(lessThan(data[1].i4.xyz, ivec3(0)))));
        data[invocation].r = int(ivec4(subgroupAllEqual(lessThan(data[1].i4, ivec4(0)))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.460.subgroup.mesh]=[
#version 460

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, extension not enabled (basic)
  gl_SubgroupID;                 // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierShared(); // ERROR, extension not enabled (basic)

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#define MAX_VER  81
#define MAX_PRIM 32

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test use of builtins in mesh shaders:

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;

    gl_MeshVerticesNV[iid].gl_Position = vec4(1.0);
    gl_MeshVerticesNV[iid].gl_PointSize = 2.0;
    gl_MeshVerticesNV[iid].gl_ClipDistance[3] = 3.0;
    gl_MeshVerticesNV[iid].gl_CullDistance[2] = 4.0;

    BARRIER();

    gl_MeshVerticesNV[iid+1].gl_Position = gl_MeshVerticesNV[iid].gl_Position;
    gl_MeshVerticesNV[iid+1].gl_PointSize = gl_MeshVerticesNV[iid].gl_PointSize;
    gl_MeshVerticesNV[iid+1].gl_ClipDistance[3] = gl_MeshVerticesNV[iid].gl_ClipDistance[3];
    gl_MeshVerticesNV[iid+1].gl_CullDistance[2] = gl_MeshVerticesNV[iid].gl_CullDistance[2];

    BARRIER();

    gl_MeshPrimitivesNV[iid].gl_PrimitiveID = 6;
    gl_MeshPrimitivesNV[iid].gl_Layer = 7;
    gl_MeshPrimitivesNV[iid].gl_ViewportIndex = 8;
    gl_MeshPrimitivesNV[iid].gl_ViewportMask[0] = 9;

    BARRIER();

    gl_MeshPrimitivesNV[iid+1].gl_PrimitiveID = gl_MeshPrimitivesNV[iid].gl_PrimitiveID;
    gl_MeshPrimitivesNV[iid+1].gl_Layer = gl_MeshPrimitivesNV[iid].gl_Layer;
    gl_MeshPrimitivesNV[iid+1].gl_ViewportIndex = gl_MeshPrimitivesNV[iid].gl_ViewportIndex;
    gl_MeshPrimitivesNV[iid+1].gl_ViewportMask[0] = gl_MeshPrimitivesNV[iid].gl_ViewportMask[0];

    BARRIER();

    // check bound limits
    gl_PrimitiveIndicesNV[0] = 257; // should truncate 257 -> 1
    gl_PrimitiveIndicesNV[(MAX_PRIM * 3) - 1] = 2;
    gl_PrimitiveIndicesNV[gid] = gl_PrimitiveIndicesNV[gid-1];

    // writes 4 indices at offset gl_DrawID
    writePackedPrimitiveIndices4x8NV(gl_DrawID, 0x01020304);

    gl_PrimitiveCountNV = MAX_PRIM * 3;

    BARRIER();
}

#extension GL_KHR_shader_subgroup_basic: enable
void basic_works (void)
{
  gl_SubgroupSize;
  gl_SubgroupInvocationID;
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
  gl_NumSubgroups;                  // allowed in mesh
  gl_SubgroupID;                    // allowed in mesh
  subgroupMemoryBarrierShared();    // allowed in mesh
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.460.subgroup.task]=[
#version 460

vec4 undeclared_errors(vec4 f4)
{
  vec4 result;
  gl_SubgroupSize;               // ERROR, extension not enabled (basic)
  gl_SubgroupInvocationID;       // ERROR, extension not enabled (basic)
  subgroupBarrier();             // ERROR, extension not enabled (basic)
  subgroupMemoryBarrier();       // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierBuffer(); // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierImage();  // ERROR, extension not enabled (basic)
  subgroupElect();               // ERROR, extension not enabled (basic)
  gl_NumSubgroups;               // ERROR, extension not enabled (basic)
  gl_SubgroupID;                 // ERROR, extension not enabled (basic)
  subgroupMemoryBarrierShared(); // ERROR, extension not enabled (basic)

  subgroupAll(true);        // ERROR extension not enabled (vote)
  subgroupAny(false);       // ERROR extension not enabled (vote)
  subgroupAllEqual(f4);     // ERROR extension not enabled (vote)

  gl_SubgroupEqMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupGtMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLeMask;                        // ERROR extension not enabled (ballot)
  gl_SubgroupLtMask;                        // ERROR extension not enabled (ballot)
  subgroupBroadcast(f4, 0);                 // ERROR extension not enabled (ballot)
  subgroupBroadcastFirst(f4);               // ERROR extension not enabled (ballot)
  uvec4 ballot = subgroupBallot(false);     // ERROR extension not enabled (ballot)
  subgroupInverseBallot(uvec4(0x1));        // ERROR extension not enabled (ballot)
  subgroupBallotBitExtract(ballot, 0);      // ERROR extension not enabled (ballot)
  subgroupBallotBitCount(ballot);           // ERROR extension not enabled (ballot)
  subgroupBallotInclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotExclusiveBitCount(ballot);  // ERROR extension not enabled (ballot)
  subgroupBallotFindLSB(ballot);            // ERROR extension not enabled (ballot)
  subgroupBallotFindMSB(ballot);            // ERROR extension not enabled (ballot)

  subgroupShuffle(f4, 0);           // ERROR extension not enabled (shuffle)
  subgroupShuffleXor(f4, 0x1);      // ERROR extension not enabled (shuffle)
  subgroupShuffleUp(f4, 1);         // ERROR extension not enabled (shuffle_relative)
  subgroupShuffleDown(f4, 1);       // ERROR extension not enabled (shuffle_relative)

  result = subgroupAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupMul(f4);                  // ERROR, extension not enabled (arith)
  subgroupMin(f4);                  // ERROR, extension not enabled (arith)
  subgroupMax(f4);                  // ERROR, extension not enabled (arith)
  subgroupAnd(ballot);              // ERROR, extension not enabled (arith)
  subgroupOr(ballot);               // ERROR, extension not enabled (arith)
  subgroupXor(ballot);              // ERROR, extension not enabled (arith)
  subgroupInclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupInclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupInclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupInclusiveXor(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveAdd(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMul(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMin(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveMax(f4);         // ERROR, extension not enabled (arith)
  subgroupExclusiveAnd(ballot);     // ERROR, extension not enabled (arith)
  subgroupExclusiveOr(ballot);      // ERROR, extension not enabled (arith)
  subgroupExclusiveXor(ballot);     // ERROR, extension not enabled (arith)

  subgroupClusteredAdd(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMul(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMin(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredMax(f4, 2);      // ERROR, extension not enabled (clustered)
  subgroupClusteredAnd(ballot, 2);  // ERROR, extension not enabled (clustered)
  subgroupClusteredOr(ballot, 2);   // ERROR, extension not enabled (clustered)
  subgroupClusteredXor(ballot, 2);  // ERROR, extension not enabled (clustered)

  subgroupQuadBroadcast(f4, 0);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapHorizontal(f4);   // ERROR, extension not enabled (quad)
  subgroupQuadSwapVertical(f4);     // ERROR, extension not enabled (quad)
  subgroupQuadSwapDiagonal(f4);     // ERROR, extension not enabled (quad)

  uvec4 parti = subgroupPartitionNV(f4);                // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAddNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMulNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMinNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedMaxNV(f4, parti);                  // ERROR, extension not enabled (partitioned)
  subgroupPartitionedAndNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedOrNV(ballot, parti);               // ERROR, extension not enabled (partitioned)
  subgroupPartitionedXorNV(ballot, parti);              // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedInclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAddNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMulNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMinNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveMaxNV(f4, parti);         // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveAndNV(ballot, parti);     // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveOrNV(ballot, parti);      // ERROR, extension not enabled (partitioned)
  subgroupPartitionedExclusiveXorNV(ballot, parti);     // ERROR, extension not enabled (partitioned)

  return result;
}

#define MAX_VIEWS gl_MaxMeshViewCountNV

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

// test use of shared memory in task shaders:
layout(binding=0) writeonly uniform image2D uni_image;
uniform block0 {
    uint uni_value;
};
shared vec4 mem[10];

// test use of task memory in task shaders:
taskNV out Task {
    vec2 dummy;
    vec2 submesh[3];
    uint viewID;
} mytask;

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;
    uint viewID = gl_MeshViewIndicesNV[gl_MeshViewCountNV%MAX_VIEWS];

    // 1. shared memory load and stores
    for (uint i = 0; i < 10; ++i) {
        mem[i] = vec4(i + uni_value);
    }
    imageStore(uni_image, ivec2(iid), mem[gid]);
    imageStore(uni_image, ivec2(iid), mem[gid+1]);

    BARRIER();

    // 2. task memory stores

    mytask.dummy      = vec2(30.0, 31.0);
    mytask.submesh[0] = vec2(32.0, 33.0);
    mytask.submesh[1] = vec2(34.0, 35.0);
    mytask.submesh[2] = mytask.submesh[gid%2];
    mytask.viewID     = viewID;

    BARRIER();

    // 3. set task count
    gl_TaskCountNV = 3;
}

#extension GL_KHR_shader_subgroup_basic: enable
void basic_works (void)
{
  gl_SubgroupSize;
  gl_SubgroupInvocationID;
  subgroupBarrier();
  subgroupMemoryBarrier();
  subgroupMemoryBarrierBuffer();
  subgroupMemoryBarrierImage();
  subgroupElect();
  gl_NumSubgroups;                  // allowed in task
  gl_SubgroupID;                    // allowed in task
  subgroupMemoryBarrierShared();    // allowed in task
}

#extension GL_KHR_shader_subgroup_ballot: enable
void ballot_works(vec4 f4) {
  gl_SubgroupEqMask;
  gl_SubgroupGeMask;
  gl_SubgroupGtMask;
  gl_SubgroupLeMask;
  gl_SubgroupLtMask;
  subgroupBroadcast(f4, 0);
  subgroupBroadcastFirst(f4);
  uvec4 ballot = subgroupBallot(false);
  subgroupInverseBallot(uvec4(0x1));
  subgroupBallotBitExtract(ballot, 0);
  subgroupBallotBitCount(ballot);
  subgroupBallotInclusiveBitCount(ballot);
  subgroupBallotExclusiveBitCount(ballot);
  subgroupBallotFindLSB(ballot);
  subgroupBallotFindMSB(ballot);
}

#extension GL_KHR_shader_subgroup_vote: enable
void vote_works(vec4 f4)
{
  subgroupAll(true);
  subgroupAny(false);
  subgroupAllEqual(f4);
}

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
void shuffle_works(vec4 f4)
{
  subgroupShuffle(f4, 0);
  subgroupShuffleXor(f4, 0x1);
  subgroupShuffleUp(f4, 1);
  subgroupShuffleDown(f4, 1);
}

#extension GL_KHR_shader_subgroup_arithmetic: enable
void arith_works(vec4 f4)
{
  uvec4 ballot;
  subgroupAdd(f4);
  subgroupMul(f4);
  subgroupMin(f4);
  subgroupMax(f4);
  subgroupAnd(ballot);
  subgroupOr(ballot);
  subgroupXor(ballot);
  subgroupInclusiveAdd(f4);
  subgroupInclusiveMul(f4);
  subgroupInclusiveMin(f4);
  subgroupInclusiveMax(f4);
  subgroupInclusiveAnd(ballot);
  subgroupInclusiveOr(ballot);
  subgroupInclusiveXor(ballot);
  subgroupExclusiveAdd(f4);
  subgroupExclusiveMul(f4);
  subgroupExclusiveMin(f4);
  subgroupExclusiveMax(f4);
  subgroupExclusiveAnd(ballot);
  subgroupExclusiveOr(ballot);
  subgroupExclusiveXor(ballot);
}

#extension GL_KHR_shader_subgroup_clustered: enable
void clustered_works(vec4 f4)
{
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupClusteredAdd(f4, 2);
  subgroupClusteredMul(f4, 2);
  subgroupClusteredMin(f4, 2);
  subgroupClusteredMax(f4, 2);
  subgroupClusteredAnd(ballot, 2);
  subgroupClusteredOr(ballot, 2);
  subgroupClusteredXor(ballot, 2);
}

#extension GL_KHR_shader_subgroup_quad: enable
void quad_works(vec4 f4)
{
  subgroupQuadBroadcast(f4, 0);
  subgroupQuadSwapHorizontal(f4);
  subgroupQuadSwapVertical(f4);
  subgroupQuadSwapDiagonal(f4);
}

#extension GL_NV_shader_subgroup_partitioned: enable
void partitioned_works(vec4 f4)
{
  uvec4 parti = subgroupPartitionNV(f4);
  uvec4 ballot = uvec4(0x55,0,0,0);
  subgroupPartitionedAddNV(f4, parti);
  subgroupPartitionedMulNV(f4, parti);
  subgroupPartitionedMinNV(f4, parti);
  subgroupPartitionedMaxNV(f4, parti);
  subgroupPartitionedAndNV(ballot, parti);
  subgroupPartitionedOrNV(ballot, parti);
  subgroupPartitionedXorNV(ballot, parti);
  subgroupPartitionedInclusiveAddNV(f4, parti);
  subgroupPartitionedInclusiveMulNV(f4, parti);
  subgroupPartitionedInclusiveMinNV(f4, parti);
  subgroupPartitionedInclusiveMaxNV(f4, parti);
  subgroupPartitionedInclusiveAndNV(ballot, parti);
  subgroupPartitionedInclusiveOrNV(ballot, parti);
  subgroupPartitionedInclusiveXorNV(ballot, parti);
  subgroupPartitionedExclusiveAddNV(f4, parti);
  subgroupPartitionedExclusiveMulNV(f4, parti);
  subgroupPartitionedExclusiveMinNV(f4, parti);
  subgroupPartitionedExclusiveMaxNV(f4, parti);
  subgroupPartitionedExclusiveAndNV(ballot, parti);
  subgroupPartitionedExclusiveOrNV(ballot, parti);
  subgroupPartitionedExclusiveXorNV(ballot, parti);
}

// tests for NV_shader_sm_builtins
void sm_builtins_err()
{
    gl_WarpsPerSMNV;    // ERROR, no extension
    gl_SMCountNV;       // ERROR, no extension
    gl_WarpIDNV;        // ERROR, no extension
    gl_SMIDNV;          // ERROR, no extension
}

#ifdef GL_NV_shader_sm_builtins
#extension GL_NV_shader_sm_builtins : enable
#endif

void sm_builtins()
{
    gl_WarpsPerSMNV;
    gl_SMCountNV;
    gl_WarpIDNV;
    gl_SMIDNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
121:7; [@900,7695:7697='out',<'out'>,121:7]; no viable alternative at input 'taskNV out'; NoViableAltException:null
]


testGlslangErrors[glsl.autosampledtextures.frag]=[
#version 460

layout (location = 0) in vec2 in_UV;

layout (set=0, binding=0) uniform texture2D u_Tex;
layout (set=0, binding=0) uniform sampler u_Sampler;

layout (location = 0) out vec4 out_Color;

void main() {
    vec4 color = texture(sampler2D(u_Tex, u_Sampler), in_UV);
    out_Color = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.entryPointRename.vert]=[
#version 460

void bar()
{
    gl_Position = vec4(1);
}

void main()
{
    gl_Position = vec4(1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.entryPointRename2.vert]=[
#version 460

void bar()
{
    gl_Position = vec4(1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es300.layoutOffset.error.vert]=[
#version 300 es

layout (binding = 0, offset = 0) uniform UBO // offset can't use on under version es 300
{
    vec4 a;
};

in  vec4 in_vs;
out vec4 out_vs;

void main()
{
    out_vs = in_vs + a;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroup.frag]=[
#version 320 es
#extension GL_KHR_shader_subgroup_basic: enable
layout(location = 0) out uvec4 data;
void main (void)
{
  data = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroup.geom]=[
#version 320 es
#extension GL_KHR_shader_subgroup_basic: enable
layout(points) in;
layout(points, max_vertices = 1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveIDIn] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroup.tesc]=[
#version 320 es
#extension GL_KHR_shader_subgroup_basic: enable
layout(vertices=1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroup.tese]=[
#version 320 es
#extension GL_KHR_shader_subgroup_basic: enable
layout(isolines) in;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroup.vert]=[
#version 320 es
#extension GL_KHR_shader_subgroup_basic: enable
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_VertexID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupArithmetic.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_arithmetic: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.x   = subgroupAdd(data[0].f4.x);
    data[0].f4.xy  = subgroupAdd(data[1].f4.xy);
    data[0].f4.xyz = subgroupAdd(data[2].f4.xyz);
    data[0].f4     = subgroupAdd(data[3].f4);

    data[1].i4.x   = subgroupAdd(data[0].i4.x);
    data[1].i4.xy  = subgroupAdd(data[1].i4.xy);
    data[1].i4.xyz = subgroupAdd(data[2].i4.xyz);
    data[1].i4     = subgroupAdd(data[3].i4);

    data[2].u4.x   = subgroupAdd(data[0].u4.x);
    data[2].u4.xy  = subgroupAdd(data[1].u4.xy);
    data[2].u4.xyz = subgroupAdd(data[2].u4.xyz);
    data[2].u4     = subgroupAdd(data[3].u4);

    data[3].f4.x   = subgroupMul(data[0].f4.x);
    data[3].f4.xy  = subgroupMul(data[1].f4.xy);
    data[3].f4.xyz = subgroupMul(data[2].f4.xyz);
    data[3].f4     = subgroupMul(data[3].f4);

    data[0].i4.x   = subgroupMul(data[0].i4.x);
    data[0].i4.xy  = subgroupMul(data[1].i4.xy);
    data[0].i4.xyz = subgroupMul(data[2].i4.xyz);
    data[0].i4     = subgroupMul(data[3].i4);

    data[1].u4.x   = subgroupMul(data[0].u4.x);
    data[1].u4.xy  = subgroupMul(data[1].u4.xy);
    data[1].u4.xyz = subgroupMul(data[2].u4.xyz);
    data[1].u4     = subgroupMul(data[3].u4);

    data[2].f4.x   = subgroupMin(data[0].f4.x);
    data[2].f4.xy  = subgroupMin(data[1].f4.xy);
    data[2].f4.xyz = subgroupMin(data[2].f4.xyz);
    data[2].f4     = subgroupMin(data[3].f4);

    data[3].i4.x   = subgroupMin(data[0].i4.x);
    data[3].i4.xy  = subgroupMin(data[1].i4.xy);
    data[3].i4.xyz = subgroupMin(data[2].i4.xyz);
    data[3].i4     = subgroupMin(data[3].i4);

    data[0].u4.x   = subgroupMin(data[0].u4.x);
    data[0].u4.xy  = subgroupMin(data[1].u4.xy);
    data[0].u4.xyz = subgroupMin(data[2].u4.xyz);
    data[0].u4     = subgroupMin(data[3].u4);

    data[1].f4.x   = subgroupMax(data[0].f4.x);
    data[1].f4.xy  = subgroupMax(data[1].f4.xy);
    data[1].f4.xyz = subgroupMax(data[2].f4.xyz);
    data[1].f4     = subgroupMax(data[3].f4);

    data[2].i4.x   = subgroupMax(data[0].i4.x);
    data[2].i4.xy  = subgroupMax(data[1].i4.xy);
    data[2].i4.xyz = subgroupMax(data[2].i4.xyz);
    data[2].i4     = subgroupMax(data[3].i4);

    data[3].u4.x   = subgroupMax(data[0].u4.x);
    data[3].u4.xy  = subgroupMax(data[1].u4.xy);
    data[3].u4.xyz = subgroupMax(data[2].u4.xyz);
    data[3].u4     = subgroupMax(data[3].u4);

    data[0].i4.x   = subgroupAnd(data[0].i4.x);
    data[0].i4.xy  = subgroupAnd(data[1].i4.xy);
    data[0].i4.xyz = subgroupAnd(data[2].i4.xyz);
    data[0].i4     = subgroupAnd(data[3].i4);

    data[1].u4.x   = subgroupAnd(data[0].u4.x);
    data[1].u4.xy  = subgroupAnd(data[1].u4.xy);
    data[1].u4.xyz = subgroupAnd(data[2].u4.xyz);
    data[1].u4     = subgroupAnd(data[3].u4);

    data[2].i4.x   =   int(subgroupAnd(data[0].i4.x < 0));
    data[2].i4.xy  = ivec2(subgroupAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[2].i4.xyz = ivec3(subgroupAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[2].i4     = ivec4(subgroupAnd(lessThan(data[1].i4, ivec4(0))));

    data[3].i4.x   = subgroupOr(data[0].i4.x);
    data[3].i4.xy  = subgroupOr(data[1].i4.xy);
    data[3].i4.xyz = subgroupOr(data[2].i4.xyz);
    data[3].i4     = subgroupOr(data[3].i4);

    data[0].u4.x   = subgroupOr(data[0].u4.x);
    data[0].u4.xy  = subgroupOr(data[1].u4.xy);
    data[0].u4.xyz = subgroupOr(data[2].u4.xyz);
    data[0].u4     = subgroupOr(data[3].u4);

    data[1].i4.x   =   int(subgroupOr(data[0].i4.x < 0));
    data[1].i4.xy  = ivec2(subgroupOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[1].i4.xyz = ivec3(subgroupOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[1].i4     = ivec4(subgroupOr(lessThan(data[1].i4, ivec4(0))));

    data[2].i4.x   = subgroupXor(data[0].i4.x);
    data[2].i4.xy  = subgroupXor(data[1].i4.xy);
    data[2].i4.xyz = subgroupXor(data[2].i4.xyz);
    data[2].i4     = subgroupXor(data[3].i4);

    data[3].u4.x   = subgroupXor(data[0].u4.x);
    data[3].u4.xy  = subgroupXor(data[1].u4.xy);
    data[3].u4.xyz = subgroupXor(data[2].u4.xyz);
    data[3].u4     = subgroupXor(data[3].u4);

    data[0].i4.x   =   int(subgroupXor(data[0].i4.x < 0));
    data[0].i4.xy  = ivec2(subgroupXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[0].i4.xyz = ivec3(subgroupXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[0].i4     = ivec4(subgroupXor(lessThan(data[1].i4, ivec4(0))));

    data[1].f4.x   = subgroupInclusiveAdd(data[0].f4.x);
    data[1].f4.xy  = subgroupInclusiveAdd(data[1].f4.xy);
    data[1].f4.xyz = subgroupInclusiveAdd(data[2].f4.xyz);
    data[1].f4     = subgroupInclusiveAdd(data[3].f4);

    data[2].i4.x   = subgroupInclusiveAdd(data[0].i4.x);
    data[2].i4.xy  = subgroupInclusiveAdd(data[1].i4.xy);
    data[2].i4.xyz = subgroupInclusiveAdd(data[2].i4.xyz);
    data[2].i4     = subgroupInclusiveAdd(data[3].i4);

    data[3].u4.x   = subgroupInclusiveAdd(data[0].u4.x);
    data[3].u4.xy  = subgroupInclusiveAdd(data[1].u4.xy);
    data[3].u4.xyz = subgroupInclusiveAdd(data[2].u4.xyz);
    data[3].u4     = subgroupInclusiveAdd(data[3].u4);

    data[0].f4.x   = subgroupInclusiveMul(data[0].f4.x);
    data[0].f4.xy  = subgroupInclusiveMul(data[1].f4.xy);
    data[0].f4.xyz = subgroupInclusiveMul(data[2].f4.xyz);
    data[0].f4     = subgroupInclusiveMul(data[3].f4);

    data[1].i4.x   = subgroupInclusiveMul(data[0].i4.x);
    data[1].i4.xy  = subgroupInclusiveMul(data[1].i4.xy);
    data[1].i4.xyz = subgroupInclusiveMul(data[2].i4.xyz);
    data[1].i4     = subgroupInclusiveMul(data[3].i4);

    data[2].u4.x   = subgroupInclusiveMul(data[0].u4.x);
    data[2].u4.xy  = subgroupInclusiveMul(data[1].u4.xy);
    data[2].u4.xyz = subgroupInclusiveMul(data[2].u4.xyz);
    data[2].u4     = subgroupInclusiveMul(data[3].u4);

    data[3].f4.x   = subgroupInclusiveMin(data[0].f4.x);
    data[3].f4.xy  = subgroupInclusiveMin(data[1].f4.xy);
    data[3].f4.xyz = subgroupInclusiveMin(data[2].f4.xyz);
    data[3].f4     = subgroupInclusiveMin(data[3].f4);

    data[0].i4.x   = subgroupInclusiveMin(data[0].i4.x);
    data[0].i4.xy  = subgroupInclusiveMin(data[1].i4.xy);
    data[0].i4.xyz = subgroupInclusiveMin(data[2].i4.xyz);
    data[0].i4     = subgroupInclusiveMin(data[3].i4);

    data[1].u4.x   = subgroupInclusiveMin(data[0].u4.x);
    data[1].u4.xy  = subgroupInclusiveMin(data[1].u4.xy);
    data[1].u4.xyz = subgroupInclusiveMin(data[2].u4.xyz);
    data[1].u4     = subgroupInclusiveMin(data[3].u4);

    data[2].f4.x   = subgroupInclusiveMax(data[0].f4.x);
    data[2].f4.xy  = subgroupInclusiveMax(data[1].f4.xy);
    data[2].f4.xyz = subgroupInclusiveMax(data[2].f4.xyz);
    data[2].f4     = subgroupInclusiveMax(data[3].f4);

    data[3].i4.x   = subgroupInclusiveMax(data[0].i4.x);
    data[3].i4.xy  = subgroupInclusiveMax(data[1].i4.xy);
    data[3].i4.xyz = subgroupInclusiveMax(data[2].i4.xyz);
    data[3].i4     = subgroupInclusiveMax(data[3].i4);

    data[0].u4.x   = subgroupInclusiveMax(data[0].u4.x);
    data[0].u4.xy  = subgroupInclusiveMax(data[1].u4.xy);
    data[0].u4.xyz = subgroupInclusiveMax(data[2].u4.xyz);
    data[0].u4     = subgroupInclusiveMax(data[3].u4);

    data[1].i4.x   = subgroupInclusiveAnd(data[0].i4.x);
    data[1].i4.xy  = subgroupInclusiveAnd(data[1].i4.xy);
    data[1].i4.xyz = subgroupInclusiveAnd(data[2].i4.xyz);
    data[1].i4     = subgroupInclusiveAnd(data[3].i4);

    data[2].u4.x   = subgroupInclusiveAnd(data[0].u4.x);
    data[2].u4.xy  = subgroupInclusiveAnd(data[1].u4.xy);
    data[2].u4.xyz = subgroupInclusiveAnd(data[2].u4.xyz);
    data[2].u4     = subgroupInclusiveAnd(data[3].u4);

    data[3].i4.x   =   int(subgroupInclusiveAnd(data[0].i4.x < 0));
    data[3].i4.xy  = ivec2(subgroupInclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[3].i4.xyz = ivec3(subgroupInclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[3].i4     = ivec4(subgroupInclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[0].i4.x   = subgroupInclusiveOr(data[0].i4.x);
    data[0].i4.xy  = subgroupInclusiveOr(data[1].i4.xy);
    data[0].i4.xyz = subgroupInclusiveOr(data[2].i4.xyz);
    data[0].i4     = subgroupInclusiveOr(data[3].i4);

    data[1].u4.x   = subgroupInclusiveOr(data[0].u4.x);
    data[1].u4.xy  = subgroupInclusiveOr(data[1].u4.xy);
    data[1].u4.xyz = subgroupInclusiveOr(data[2].u4.xyz);
    data[1].u4     = subgroupInclusiveOr(data[3].u4);

    data[2].i4.x   =   int(subgroupInclusiveOr(data[0].i4.x < 0));
    data[2].i4.xy  = ivec2(subgroupInclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[2].i4.xyz = ivec3(subgroupInclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[2].i4     = ivec4(subgroupInclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[3].i4.x   = subgroupInclusiveXor(data[0].i4.x);
    data[3].i4.xy  = subgroupInclusiveXor(data[1].i4.xy);
    data[3].i4.xyz = subgroupInclusiveXor(data[2].i4.xyz);
    data[3].i4     = subgroupInclusiveXor(data[3].i4);

    data[0].u4.x   = subgroupInclusiveXor(data[0].u4.x);
    data[0].u4.xy  = subgroupInclusiveXor(data[1].u4.xy);
    data[0].u4.xyz = subgroupInclusiveXor(data[2].u4.xyz);
    data[0].u4     = subgroupInclusiveXor(data[3].u4);

    data[1].i4.x   =   int(subgroupInclusiveXor(data[0].i4.x < 0));
    data[1].i4.xy  = ivec2(subgroupInclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[1].i4.xyz = ivec3(subgroupInclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[1].i4     = ivec4(subgroupInclusiveXor(lessThan(data[1].i4, ivec4(0))));

    data[2].f4.x   = subgroupExclusiveAdd(data[0].f4.x);
    data[2].f4.xy  = subgroupExclusiveAdd(data[1].f4.xy);
    data[2].f4.xyz = subgroupExclusiveAdd(data[2].f4.xyz);
    data[2].f4     = subgroupExclusiveAdd(data[3].f4);

    data[3].i4.x   = subgroupExclusiveAdd(data[0].i4.x);
    data[3].i4.xy  = subgroupExclusiveAdd(data[1].i4.xy);
    data[3].i4.xyz = subgroupExclusiveAdd(data[2].i4.xyz);
    data[3].i4     = subgroupExclusiveAdd(data[3].i4);

    data[0].u4.x   = subgroupExclusiveAdd(data[0].u4.x);
    data[0].u4.xy  = subgroupExclusiveAdd(data[1].u4.xy);
    data[0].u4.xyz = subgroupExclusiveAdd(data[2].u4.xyz);
    data[0].u4     = subgroupExclusiveAdd(data[3].u4);

    data[1].f4.x   = subgroupExclusiveMul(data[0].f4.x);
    data[1].f4.xy  = subgroupExclusiveMul(data[1].f4.xy);
    data[1].f4.xyz = subgroupExclusiveMul(data[2].f4.xyz);
    data[1].f4     = subgroupExclusiveMul(data[3].f4);

    data[2].i4.x   = subgroupExclusiveMul(data[0].i4.x);
    data[2].i4.xy  = subgroupExclusiveMul(data[1].i4.xy);
    data[2].i4.xyz = subgroupExclusiveMul(data[2].i4.xyz);
    data[2].i4     = subgroupExclusiveMul(data[3].i4);

    data[3].u4.x   = subgroupExclusiveMul(data[0].u4.x);
    data[3].u4.xy  = subgroupExclusiveMul(data[1].u4.xy);
    data[3].u4.xyz = subgroupExclusiveMul(data[2].u4.xyz);
    data[3].u4     = subgroupExclusiveMul(data[3].u4);

    data[0].f4.x   = subgroupExclusiveMin(data[0].f4.x);
    data[0].f4.xy  = subgroupExclusiveMin(data[1].f4.xy);
    data[0].f4.xyz = subgroupExclusiveMin(data[2].f4.xyz);
    data[0].f4     = subgroupExclusiveMin(data[3].f4);

    data[1].i4.x   = subgroupExclusiveMin(data[0].i4.x);
    data[1].i4.xy  = subgroupExclusiveMin(data[1].i4.xy);
    data[1].i4.xyz = subgroupExclusiveMin(data[2].i4.xyz);
    data[1].i4     = subgroupExclusiveMin(data[3].i4);

    data[2].u4.x   = subgroupExclusiveMin(data[0].u4.x);
    data[2].u4.xy  = subgroupExclusiveMin(data[1].u4.xy);
    data[2].u4.xyz = subgroupExclusiveMin(data[2].u4.xyz);
    data[2].u4     = subgroupExclusiveMin(data[3].u4);

    data[3].f4.x   = subgroupExclusiveMax(data[0].f4.x);
    data[3].f4.xy  = subgroupExclusiveMax(data[1].f4.xy);
    data[3].f4.xyz = subgroupExclusiveMax(data[2].f4.xyz);
    data[3].f4     = subgroupExclusiveMax(data[3].f4);

    data[0].i4.x   = subgroupExclusiveMax(data[0].i4.x);
    data[0].i4.xy  = subgroupExclusiveMax(data[1].i4.xy);
    data[0].i4.xyz = subgroupExclusiveMax(data[2].i4.xyz);
    data[0].i4     = subgroupExclusiveMax(data[3].i4);

    data[1].u4.x   = subgroupExclusiveMax(data[0].u4.x);
    data[1].u4.xy  = subgroupExclusiveMax(data[1].u4.xy);
    data[1].u4.xyz = subgroupExclusiveMax(data[2].u4.xyz);
    data[1].u4     = subgroupExclusiveMax(data[3].u4);

    data[2].i4.x   = subgroupExclusiveAnd(data[0].i4.x);
    data[2].i4.xy  = subgroupExclusiveAnd(data[1].i4.xy);
    data[2].i4.xyz = subgroupExclusiveAnd(data[2].i4.xyz);
    data[2].i4     = subgroupExclusiveAnd(data[3].i4);

    data[3].u4.x   = subgroupExclusiveAnd(data[0].u4.x);
    data[3].u4.xy  = subgroupExclusiveAnd(data[1].u4.xy);
    data[3].u4.xyz = subgroupExclusiveAnd(data[2].u4.xyz);
    data[3].u4     = subgroupExclusiveAnd(data[3].u4);

    data[0].i4.x   =   int(subgroupExclusiveAnd(data[0].i4.x < 0));
    data[0].i4.xy  = ivec2(subgroupExclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[0].i4.xyz = ivec3(subgroupExclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[0].i4     = ivec4(subgroupExclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[1].i4.x   = subgroupExclusiveOr(data[0].i4.x);
    data[1].i4.xy  = subgroupExclusiveOr(data[1].i4.xy);
    data[1].i4.xyz = subgroupExclusiveOr(data[2].i4.xyz);
    data[1].i4     = subgroupExclusiveOr(data[3].i4);

    data[2].u4.x   = subgroupExclusiveOr(data[0].u4.x);
    data[2].u4.xy  = subgroupExclusiveOr(data[1].u4.xy);
    data[2].u4.xyz = subgroupExclusiveOr(data[2].u4.xyz);
    data[2].u4     = subgroupExclusiveOr(data[3].u4);

    data[3].i4.x   =   int(subgroupExclusiveOr(data[0].i4.x < 0));
    data[3].i4.xy  = ivec2(subgroupExclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[3].i4.xyz = ivec3(subgroupExclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[3].i4     = ivec4(subgroupExclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[0].i4.x   = subgroupExclusiveXor(data[0].i4.x);
    data[0].i4.xy  = subgroupExclusiveXor(data[1].i4.xy);
    data[0].i4.xyz = subgroupExclusiveXor(data[2].i4.xyz);
    data[0].i4     = subgroupExclusiveXor(data[3].i4);

    data[1].u4.x   = subgroupExclusiveXor(data[0].u4.x);
    data[1].u4.xy  = subgroupExclusiveXor(data[1].u4.xy);
    data[1].u4.xyz = subgroupExclusiveXor(data[2].u4.xyz);
    data[1].u4     = subgroupExclusiveXor(data[3].u4);

    data[2].i4.x   =   int(subgroupExclusiveXor(data[0].i4.x < 0));
    data[2].i4.xy  = ivec2(subgroupExclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[2].i4.xyz = ivec3(subgroupExclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[2].i4     = ivec4(subgroupExclusiveXor(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupBallot.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[0].u4.x = subgroupBallotBitCount(result);
    data[0].u4.y = subgroupBallotBitExtract(result, 0u) ? 1u : 0u;
    data[0].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[0].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    if ((relMask == result) && subgroupInverseBallot(data[0].u4))
    {
        data[1].f4.x   = subgroupBroadcast(data[0].f4.x,    3u);
        data[1].f4.xy  = subgroupBroadcast(data[1].f4.xy,   3u);
        data[1].f4.xyz = subgroupBroadcast(data[2].f4.xyz,  3u);
        data[1].f4     = subgroupBroadcast(data[3].f4,      3u);

        data[2].i4.x   = subgroupBroadcast(data[0].i4.x,    2u);
        data[2].i4.xy  = subgroupBroadcast(data[1].i4.xy,   2u);
        data[2].i4.xyz = subgroupBroadcast(data[2].i4.xyz,  2u);
        data[2].i4     = subgroupBroadcast(data[3].i4,      2u);

        data[3].u4.x   = subgroupBroadcast(data[0].u4.x,    1u);
        data[3].u4.xy  = subgroupBroadcast(data[1].u4.xy,   1u);
        data[3].u4.xyz = subgroupBroadcast(data[2].u4.xyz,  1u);
        data[3].u4     = subgroupBroadcast(data[3].u4,      1u);

        data[0].i4.x   = int(subgroupBroadcast(data[0].i4.x < 0,            1u));
        data[0].i4.xy  = ivec2(subgroupBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1u));
        data[0].i4.xyz = ivec3(subgroupBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1u));
        data[0].i4     = ivec4(subgroupBroadcast(lessThan(data[1].i4, ivec4(0)), 1u));
    }
    else
    {
        data[1].f4.x   = subgroupBroadcastFirst(data[0].f4.x);
        data[1].f4.xy  = subgroupBroadcastFirst(data[1].f4.xy);
        data[1].f4.xyz = subgroupBroadcastFirst(data[2].f4.xyz);
        data[1].f4     = subgroupBroadcastFirst(data[3].f4);

        data[2].i4.x   = subgroupBroadcastFirst(data[0].i4.x);
        data[2].i4.xy  = subgroupBroadcastFirst(data[1].i4.xy);
        data[2].i4.xyz = subgroupBroadcastFirst(data[2].i4.xyz);
        data[2].i4     = subgroupBroadcastFirst(data[3].i4);

        data[3].u4.x   = subgroupBroadcastFirst(data[0].u4.x);
        data[3].u4.xy  = subgroupBroadcastFirst(data[1].u4.xy);
        data[3].u4.xyz = subgroupBroadcastFirst(data[2].u4.xyz);
        data[3].u4     = subgroupBroadcastFirst(data[3].u4);

        data[0].i4.x   = int(subgroupBroadcastFirst(data[0].i4.x < 0));
        data[0].i4.xy  = ivec2(subgroupBroadcastFirst(lessThan(data[1].i4.xy, ivec2(0))));
        data[0].i4.xyz = ivec3(subgroupBroadcastFirst(lessThan(data[1].i4.xyz, ivec3(0))));
        data[0].i4     = ivec4(subgroupBroadcastFirst(lessThan(data[1].i4, ivec4(0))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupBallotNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[0].u4.x = subgroupBallotBitCount(result);
    data[0].u4.y = subgroupBallotBitExtract(result, 0) ? 1u : 0u;
    data[0].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[0].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    data[1].f4.x   = subgroupBroadcast(data[0].f4.x,    invocation);  // ERROR: not constant
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupBasic.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_basic: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffer
{
    int a[];
} data;

void main()
{
    data.a[gl_SubgroupSize] = 1;
    data.a[gl_SubgroupInvocationID] = 1;
    data.a[gl_NumSubgroups] = 1;
    data.a[gl_SubgroupID] = (subgroupElect()) ? 1 : 0;
    subgroupBarrier();
    subgroupMemoryBarrier();
    subgroupMemoryBarrierBuffer();
    subgroupMemoryBarrierShared();
    subgroupMemoryBarrierImage();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupClustered.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.x   = subgroupClusteredAdd(data[0].f4.x, 1u);
    data[0].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 1u);
    data[0].f4.xyz = subgroupClusteredAdd(data[2].f4.xyz, 1u);
    data[0].f4     = subgroupClusteredAdd(data[3].f4, 1u);

    data[1].i4.x   = subgroupClusteredAdd(data[0].i4.x, 1u);
    data[1].i4.xy  = subgroupClusteredAdd(data[1].i4.xy, 1u);
    data[1].i4.xyz = subgroupClusteredAdd(data[2].i4.xyz, 1u);
    data[1].i4     = subgroupClusteredAdd(data[3].i4, 1u);

    data[2].u4.x   = subgroupClusteredAdd(data[0].u4.x, 1u);
    data[2].u4.xy  = subgroupClusteredAdd(data[1].u4.xy, 1u);
    data[2].u4.xyz = subgroupClusteredAdd(data[2].u4.xyz, 1u);
    data[2].u4     = subgroupClusteredAdd(data[3].u4, 1u);

    data[3].f4.x   = subgroupClusteredMul(data[0].f4.x, 1u);
    data[3].f4.xy  = subgroupClusteredMul(data[1].f4.xy, 1u);
    data[3].f4.xyz = subgroupClusteredMul(data[2].f4.xyz, 1u);
    data[3].f4     = subgroupClusteredMul(data[3].f4, 1u);

    data[0].i4.x   = subgroupClusteredMul(data[0].i4.x, 1u);
    data[0].i4.xy  = subgroupClusteredMul(data[1].i4.xy, 1u);
    data[0].i4.xyz = subgroupClusteredMul(data[2].i4.xyz, 1u);
    data[0].i4     = subgroupClusteredMul(data[3].i4, 1u);

    data[1].u4.x   = subgroupClusteredMul(data[0].u4.x, 1u);
    data[1].u4.xy  = subgroupClusteredMul(data[1].u4.xy, 1u);
    data[1].u4.xyz = subgroupClusteredMul(data[2].u4.xyz, 1u);
    data[1].u4     = subgroupClusteredMul(data[3].u4, 1u);

    data[2].f4.x   = subgroupClusteredMin(data[0].f4.x, 1u);
    data[2].f4.xy  = subgroupClusteredMin(data[1].f4.xy, 1u);
    data[2].f4.xyz = subgroupClusteredMin(data[2].f4.xyz, 1u);
    data[2].f4     = subgroupClusteredMin(data[3].f4, 1u);

    data[3].i4.x   = subgroupClusteredMin(data[0].i4.x, 1u);
    data[3].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 1u);
    data[3].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 1u);
    data[3].i4     = subgroupClusteredMin(data[3].i4, 1u);

    data[0].u4.x   = subgroupClusteredMin(data[0].u4.x, 1u);
    data[0].u4.xy  = subgroupClusteredMin(data[1].u4.xy, 1u);
    data[0].u4.xyz = subgroupClusteredMin(data[2].u4.xyz, 1u);
    data[0].u4     = subgroupClusteredMin(data[3].u4, 1u);

    data[1].f4.x   = subgroupClusteredMax(data[0].f4.x, 1u);
    data[1].f4.xy  = subgroupClusteredMax(data[1].f4.xy, 1u);
    data[1].f4.xyz = subgroupClusteredMax(data[2].f4.xyz, 1u);
    data[1].f4     = subgroupClusteredMax(data[3].f4, 1u);

    data[2].i4.x   = subgroupClusteredMax(data[0].i4.x, 1u);
    data[2].i4.xy  = subgroupClusteredMax(data[1].i4.xy, 1u);
    data[2].i4.xyz = subgroupClusteredMax(data[2].i4.xyz, 1u);
    data[2].i4     = subgroupClusteredMax(data[3].i4, 1u);

    data[3].u4.x   = subgroupClusteredMax(data[0].u4.x, 1u);
    data[3].u4.xy  = subgroupClusteredMax(data[1].u4.xy, 1u);
    data[3].u4.xyz = subgroupClusteredMax(data[2].u4.xyz, 1u);
    data[3].u4     = subgroupClusteredMax(data[3].u4, 1u);

    data[0].i4.x   = subgroupClusteredAnd(data[0].i4.x, 1u);
    data[0].i4.xy  = subgroupClusteredAnd(data[1].i4.xy, 1u);
    data[0].i4.xyz = subgroupClusteredAnd(data[2].i4.xyz, 1u);
    data[0].i4     = subgroupClusteredAnd(data[3].i4, 1u);

    data[1].u4.x   = subgroupClusteredAnd(data[0].u4.x, 1u);
    data[1].u4.xy  = subgroupClusteredAnd(data[1].u4.xy, 1u);
    data[1].u4.xyz = subgroupClusteredAnd(data[2].u4.xyz, 1u);
    data[1].u4     = subgroupClusteredAnd(data[3].u4, 1u);

    data[2].i4.x   =   int(subgroupClusteredAnd(data[0].i4.x < 0, 1u));
    data[2].i4.xy  = ivec2(subgroupClusteredAnd(lessThan(data[1].i4.xy, ivec2(0)), 1u));
    data[2].i4.xyz = ivec3(subgroupClusteredAnd(lessThan(data[1].i4.xyz, ivec3(0)), 1u));
    data[2].i4     = ivec4(subgroupClusteredAnd(lessThan(data[1].i4, ivec4(0)), 1u));

    data[3].i4.x   = subgroupClusteredOr(data[0].i4.x, 1u);
    data[3].i4.xy  = subgroupClusteredOr(data[1].i4.xy, 1u);
    data[3].i4.xyz = subgroupClusteredOr(data[2].i4.xyz, 1u);
    data[3].i4     = subgroupClusteredOr(data[3].i4, 1u);

    data[0].u4.x   = subgroupClusteredOr(data[0].u4.x, 1u);
    data[0].u4.xy  = subgroupClusteredOr(data[1].u4.xy, 1u);
    data[0].u4.xyz = subgroupClusteredOr(data[2].u4.xyz, 1u);
    data[0].u4     = subgroupClusteredOr(data[3].u4, 1u);

    data[1].i4.x   =   int(subgroupClusteredOr(data[0].i4.x < 0, 1u));
    data[1].i4.xy  = ivec2(subgroupClusteredOr(lessThan(data[1].i4.xy, ivec2(0)), 1u));
    data[1].i4.xyz = ivec3(subgroupClusteredOr(lessThan(data[1].i4.xyz, ivec3(0)), 1u));
    data[1].i4     = ivec4(subgroupClusteredOr(lessThan(data[1].i4, ivec4(0)), 1u));

    data[2].i4.x   = subgroupClusteredXor(data[0].i4.x, 1u);
    data[2].i4.xy  = subgroupClusteredXor(data[1].i4.xy, 1u);
    data[2].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, 1u);
    data[2].i4     = subgroupClusteredXor(data[3].i4, 1u);

    data[3].u4.x   = subgroupClusteredXor(data[0].u4.x, 1u);
    data[3].u4.xy  = subgroupClusteredXor(data[1].u4.xy, 1u);
    data[3].u4.xyz = subgroupClusteredXor(data[2].u4.xyz, 1u);
    data[3].u4     = subgroupClusteredXor(data[3].u4, 1u);

    data[0].i4.x   =   int(subgroupClusteredXor(data[0].i4.x < 0, 1u));
    data[0].i4.xy  = ivec2(subgroupClusteredXor(lessThan(data[1].i4.xy, ivec2(0)), 1u));
    data[0].i4.xyz = ivec3(subgroupClusteredXor(lessThan(data[1].i4.xyz, ivec3(0)), 1u));
    data[0].i4     = ivec4(subgroupClusteredXor(lessThan(data[1].i4, ivec4(0)), 1u));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupClusteredNeg.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    int a = 1;
    const int aConst = 1;

    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 0u);          // ERROR, less than 1

    data[0].f4.x   = subgroupClusteredMul(data[0].f4.x, 3u);           // ERROR, not a power of 2

    data[1].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 8u);
    data[1].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 6u);         // ERROR, not a power of 2

    data[3].i4.x   = subgroupClusteredOr(data[0].i4.x, uint(a));            // ERROR, not constant
    data[3].i4.xy  = subgroupClusteredOr(data[1].i4.xy, uint(aConst));

    data[0].i4.x   = subgroupClusteredXor(data[0].i4.x, uint(1 + a));       // ERROR, not constant
    data[0].i4.xy  = subgroupClusteredXor(data[1].i4.xy, uint(aConst + a)); // ERROR, not constant
    data[0].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, uint(1 + aConst));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupPartitioned.comp]=[
#version 320 es

#extension GL_NV_shader_subgroup_partitioned: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    uvec4 ballot = subgroupPartitionNV(invocation);

    data[0].u4 = subgroupPartitionNV(data[0].f4.x);
    data[0].u4 = subgroupPartitionNV(data[0].f4.xy);
    data[0].u4 = subgroupPartitionNV(data[0].f4.xyz);
    data[0].u4 = subgroupPartitionNV(data[0].f4);

    data[0].u4 = subgroupPartitionNV(data[0].i4.x);
    data[0].u4 = subgroupPartitionNV(data[0].i4.xy);
    data[0].u4 = subgroupPartitionNV(data[0].i4.xyz);
    data[0].u4 = subgroupPartitionNV(data[0].i4);

    data[0].u4 = subgroupPartitionNV(data[0].u4.x);
    data[0].u4 = subgroupPartitionNV(data[0].u4.xy);
    data[0].u4 = subgroupPartitionNV(data[0].u4.xyz);
    data[0].u4 = subgroupPartitionNV(data[0].u4);

    data[1].u4 = subgroupPartitionNV(bool(data[0].i4.x));
    data[1].u4 = subgroupPartitionNV(bvec2(data[0].i4.xy));
    data[1].u4 = subgroupPartitionNV(bvec3(data[0].i4.xyz));
    data[1].u4 = subgroupPartitionNV(bvec4(data[0].i4));

    data[1].f4.x   = subgroupPartitionedAddNV(data[0].f4.x, ballot);
    data[1].f4.xy  = subgroupPartitionedAddNV(data[1].f4.xy, ballot);
    data[1].f4.xyz = subgroupPartitionedAddNV(data[2].f4.xyz, ballot);
    data[1].f4     = subgroupPartitionedAddNV(data[3].f4, ballot);

    data[1].i4.x   = subgroupPartitionedAddNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedAddNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedAddNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedAddNV(data[3].i4, ballot);

    data[1].u4.x   = subgroupPartitionedAddNV(data[0].u4.x, ballot);
    data[1].u4.xy  = subgroupPartitionedAddNV(data[1].u4.xy, ballot);
    data[1].u4.xyz = subgroupPartitionedAddNV(data[2].u4.xyz, ballot);
    data[1].u4     = subgroupPartitionedAddNV(data[3].u4, ballot);

    data[2].f4.x   = subgroupPartitionedMulNV(data[0].f4.x, ballot);
    data[2].f4.xy  = subgroupPartitionedMulNV(data[1].f4.xy, ballot);
    data[2].f4.xyz = subgroupPartitionedMulNV(data[2].f4.xyz, ballot);
    data[2].f4     = subgroupPartitionedMulNV(data[3].f4, ballot);

    data[2].i4.x   = subgroupPartitionedMulNV(data[0].i4.x, ballot);
    data[2].i4.xy  = subgroupPartitionedMulNV(data[1].i4.xy, ballot);
    data[2].i4.xyz = subgroupPartitionedMulNV(data[2].i4.xyz, ballot);
    data[2].i4     = subgroupPartitionedMulNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedMulNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedMulNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedMulNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedMulNV(data[3].u4, ballot);

    data[2].f4.x   = subgroupPartitionedMinNV(data[0].f4.x, ballot);
    data[2].f4.xy  = subgroupPartitionedMinNV(data[1].f4.xy, ballot);
    data[2].f4.xyz = subgroupPartitionedMinNV(data[2].f4.xyz, ballot);
    data[2].f4     = subgroupPartitionedMinNV(data[3].f4, ballot);

    data[3].i4.x   = subgroupPartitionedMinNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedMinNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedMinNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedMinNV(data[3].i4, ballot);

    data[3].u4.x   = subgroupPartitionedMinNV(data[0].u4.x, ballot);
    data[3].u4.xy  = subgroupPartitionedMinNV(data[1].u4.xy, ballot);
    data[3].u4.xyz = subgroupPartitionedMinNV(data[2].u4.xyz, ballot);
    data[3].u4     = subgroupPartitionedMinNV(data[3].u4, ballot);

    data[3].f4.x   = subgroupPartitionedMaxNV(data[0].f4.x, ballot);
    data[3].f4.xy  = subgroupPartitionedMaxNV(data[1].f4.xy, ballot);
    data[3].f4.xyz = subgroupPartitionedMaxNV(data[2].f4.xyz, ballot);
    data[3].f4     = subgroupPartitionedMaxNV(data[3].f4, ballot);

    data[0].i4.x   = subgroupPartitionedMaxNV(data[0].i4.x, ballot);
    data[0].i4.xy  = subgroupPartitionedMaxNV(data[1].i4.xy, ballot);
    data[0].i4.xyz = subgroupPartitionedMaxNV(data[2].i4.xyz, ballot);
    data[0].i4     = subgroupPartitionedMaxNV(data[3].i4, ballot);

    data[0].u4.x   = subgroupPartitionedMaxNV(data[0].u4.x, ballot);
    data[0].u4.xy  = subgroupPartitionedMaxNV(data[1].u4.xy, ballot);
    data[0].u4.xyz = subgroupPartitionedMaxNV(data[2].u4.xyz, ballot);
    data[0].u4     = subgroupPartitionedMaxNV(data[3].u4, ballot);

    data[0].i4.x   = subgroupPartitionedAndNV(data[0].i4.x, ballot);
    data[0].i4.xy  = subgroupPartitionedAndNV(data[1].i4.xy, ballot);
    data[0].i4.xyz = subgroupPartitionedAndNV(data[2].i4.xyz, ballot);
    data[0].i4     = subgroupPartitionedAndNV(data[3].i4, ballot);

    data[1].u4.x   = subgroupPartitionedAndNV(data[0].u4.x, ballot);
    data[1].u4.xy  = subgroupPartitionedAndNV(data[1].u4.xy, ballot);
    data[1].u4.xyz = subgroupPartitionedAndNV(data[2].u4.xyz, ballot);
    data[1].u4     = subgroupPartitionedAndNV(data[3].u4, ballot);

    data[1].i4.x   =   int(subgroupPartitionedAndNV(data[0].i4.x < 0, ballot));
    data[1].i4.xy  = ivec2(subgroupPartitionedAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[1].i4.xyz = ivec3(subgroupPartitionedAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[1].i4     = ivec4(subgroupPartitionedAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[1].i4.x   = subgroupPartitionedOrNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedOrNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedOrNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedOrNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedOrNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedOrNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedOrNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedOrNV(data[3].u4, ballot);

    data[2].i4.x   =   int(subgroupPartitionedOrNV(data[0].i4.x < 0, ballot));
    data[2].i4.xy  = ivec2(subgroupPartitionedOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[2].i4.xyz = ivec3(subgroupPartitionedOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[2].i4     = ivec4(subgroupPartitionedOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[2].i4.x   = subgroupPartitionedXorNV(data[0].i4.x, ballot);
    data[2].i4.xy  = subgroupPartitionedXorNV(data[1].i4.xy, ballot);
    data[2].i4.xyz = subgroupPartitionedXorNV(data[2].i4.xyz, ballot);
    data[2].i4     = subgroupPartitionedXorNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedXorNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedXorNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedXorNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedXorNV(data[3].u4, ballot);

    data[3].i4.x   =   int(subgroupPartitionedXorNV(data[0].i4.x < 0, ballot));
    data[3].i4.xy  = ivec2(subgroupPartitionedXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[3].i4.xyz = ivec3(subgroupPartitionedXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[3].i4     = ivec4(subgroupPartitionedXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[3].f4.x   = subgroupPartitionedInclusiveAddNV(data[0].f4.x, ballot);
    data[3].f4.xy  = subgroupPartitionedInclusiveAddNV(data[1].f4.xy, ballot);
    data[3].f4.xyz = subgroupPartitionedInclusiveAddNV(data[2].f4.xyz, ballot);
    data[3].f4     = subgroupPartitionedInclusiveAddNV(data[3].f4, ballot);

    data[3].i4.x   = subgroupPartitionedInclusiveAddNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedInclusiveAddNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedInclusiveAddNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedInclusiveAddNV(data[3].i4, ballot);

    data[3].u4.x   = subgroupPartitionedInclusiveAddNV(data[0].u4.x, ballot);
    data[3].u4.xy  = subgroupPartitionedInclusiveAddNV(data[1].u4.xy, ballot);
    data[3].u4.xyz = subgroupPartitionedInclusiveAddNV(data[2].u4.xyz, ballot);
    data[3].u4     = subgroupPartitionedInclusiveAddNV(data[3].u4, ballot);

    data[3].f4.x   = subgroupPartitionedInclusiveMulNV(data[0].f4.x, ballot);
    data[3].f4.xy  = subgroupPartitionedInclusiveMulNV(data[1].f4.xy, ballot);
    data[3].f4.xyz = subgroupPartitionedInclusiveMulNV(data[2].f4.xyz, ballot);
    data[3].f4     = subgroupPartitionedInclusiveMulNV(data[3].f4, ballot);

    data[3].i4.x   = subgroupPartitionedInclusiveMulNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedInclusiveMulNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedInclusiveMulNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedInclusiveMulNV(data[3].i4, ballot);

    data[0].u4.x   = subgroupPartitionedInclusiveMulNV(data[0].u4.x, ballot);
    data[0].u4.xy  = subgroupPartitionedInclusiveMulNV(data[1].u4.xy, ballot);
    data[0].u4.xyz = subgroupPartitionedInclusiveMulNV(data[2].u4.xyz, ballot);
    data[0].u4     = subgroupPartitionedInclusiveMulNV(data[3].u4, ballot);

    data[0].f4.x   = subgroupPartitionedInclusiveMinNV(data[0].f4.x, ballot);
    data[0].f4.xy  = subgroupPartitionedInclusiveMinNV(data[1].f4.xy, ballot);
    data[0].f4.xyz = subgroupPartitionedInclusiveMinNV(data[2].f4.xyz, ballot);
    data[0].f4     = subgroupPartitionedInclusiveMinNV(data[3].f4, ballot);

    data[0].i4.x   = subgroupPartitionedInclusiveMinNV(data[0].i4.x, ballot);
    data[0].i4.xy  = subgroupPartitionedInclusiveMinNV(data[1].i4.xy, ballot);
    data[0].i4.xyz = subgroupPartitionedInclusiveMinNV(data[2].i4.xyz, ballot);
    data[0].i4     = subgroupPartitionedInclusiveMinNV(data[3].i4, ballot);

    data[0].u4.x   = subgroupPartitionedInclusiveMinNV(data[0].u4.x, ballot);
    data[0].u4.xy  = subgroupPartitionedInclusiveMinNV(data[1].u4.xy, ballot);
    data[0].u4.xyz = subgroupPartitionedInclusiveMinNV(data[2].u4.xyz, ballot);
    data[0].u4     = subgroupPartitionedInclusiveMinNV(data[3].u4, ballot);

    data[1].f4.x   = subgroupPartitionedInclusiveMaxNV(data[0].f4.x, ballot);
    data[1].f4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].f4.xy, ballot);
    data[1].f4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].f4.xyz, ballot);
    data[1].f4     = subgroupPartitionedInclusiveMaxNV(data[3].f4, ballot);

    data[1].i4.x   = subgroupPartitionedInclusiveMaxNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedInclusiveMaxNV(data[3].i4, ballot);

    data[1].u4.x   = subgroupPartitionedInclusiveMaxNV(data[0].u4.x, ballot);
    data[1].u4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].u4.xy, ballot);
    data[1].u4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].u4.xyz, ballot);
    data[1].u4     = subgroupPartitionedInclusiveMaxNV(data[3].u4, ballot);

    data[1].i4.x   = subgroupPartitionedInclusiveAndNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedInclusiveAndNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedInclusiveAndNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedInclusiveAndNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedInclusiveAndNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedInclusiveAndNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedInclusiveAndNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedInclusiveAndNV(data[3].u4, ballot);

    data[2].i4.x   =   int(subgroupPartitionedInclusiveAndNV(data[0].i4.x < 0, ballot));
    data[2].i4.xy  = ivec2(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[2].i4.xyz = ivec3(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[2].i4     = ivec4(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[2].i4.x   = subgroupPartitionedInclusiveOrNV(data[0].i4.x, ballot);
    data[2].i4.xy  = subgroupPartitionedInclusiveOrNV(data[1].i4.xy, ballot);
    data[2].i4.xyz = subgroupPartitionedInclusiveOrNV(data[2].i4.xyz, ballot);
    data[2].i4     = subgroupPartitionedInclusiveOrNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedInclusiveOrNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedInclusiveOrNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedInclusiveOrNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedInclusiveOrNV(data[3].u4, ballot);

    data[3].i4.x   =   int(subgroupPartitionedInclusiveOrNV(data[0].i4.x < 0, ballot));
    data[3].i4.xy  = ivec2(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[3].i4.xyz = ivec3(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[3].i4     = ivec4(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[3].i4.x   = subgroupPartitionedInclusiveXorNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedInclusiveXorNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedInclusiveXorNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedInclusiveXorNV(data[3].i4, ballot);

    data[3].u4.x   = subgroupPartitionedInclusiveXorNV(data[0].u4.x, ballot);
    data[3].u4.xy  = subgroupPartitionedInclusiveXorNV(data[1].u4.xy, ballot);
    data[3].u4.xyz = subgroupPartitionedInclusiveXorNV(data[2].u4.xyz, ballot);
    data[3].u4     = subgroupPartitionedInclusiveXorNV(data[3].u4, ballot);

    data[3].i4.x   =   int(subgroupPartitionedInclusiveXorNV(data[0].i4.x < 0, ballot));
    data[3].i4.xy  = ivec2(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[3].i4.xyz = ivec3(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[3].i4     = ivec4(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[0].f4.x   = subgroupPartitionedExclusiveAddNV(data[0].f4.x, ballot);
    data[0].f4.xy  = subgroupPartitionedExclusiveAddNV(data[1].f4.xy, ballot);
    data[0].f4.xyz = subgroupPartitionedExclusiveAddNV(data[2].f4.xyz, ballot);
    data[0].f4     = subgroupPartitionedExclusiveAddNV(data[3].f4, ballot);

    data[0].i4.x   = subgroupPartitionedExclusiveAddNV(data[0].i4.x, ballot);
    data[0].i4.xy  = subgroupPartitionedExclusiveAddNV(data[1].i4.xy, ballot);
    data[0].i4.xyz = subgroupPartitionedExclusiveAddNV(data[2].i4.xyz, ballot);
    data[0].i4     = subgroupPartitionedExclusiveAddNV(data[3].i4, ballot);

    data[0].u4.x   = subgroupPartitionedExclusiveAddNV(data[0].u4.x, ballot);
    data[0].u4.xy  = subgroupPartitionedExclusiveAddNV(data[1].u4.xy, ballot);
    data[0].u4.xyz = subgroupPartitionedExclusiveAddNV(data[2].u4.xyz, ballot);
    data[0].u4     = subgroupPartitionedExclusiveAddNV(data[3].u4, ballot);

    data[0].f4.x   = subgroupPartitionedExclusiveMulNV(data[0].f4.x, ballot);
    data[0].f4.xy  = subgroupPartitionedExclusiveMulNV(data[1].f4.xy, ballot);
    data[0].f4.xyz = subgroupPartitionedExclusiveMulNV(data[2].f4.xyz, ballot);
    data[0].f4     = subgroupPartitionedExclusiveMulNV(data[3].f4, ballot);

    data[1].i4.x   = subgroupPartitionedExclusiveMulNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedExclusiveMulNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedExclusiveMulNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedExclusiveMulNV(data[3].i4, ballot);

    data[1].u4.x   = subgroupPartitionedExclusiveMulNV(data[0].u4.x, ballot);
    data[1].u4.xy  = subgroupPartitionedExclusiveMulNV(data[1].u4.xy, ballot);
    data[1].u4.xyz = subgroupPartitionedExclusiveMulNV(data[2].u4.xyz, ballot);
    data[1].u4     = subgroupPartitionedExclusiveMulNV(data[3].u4, ballot);

    data[1].f4.x   = subgroupPartitionedExclusiveMinNV(data[0].f4.x, ballot);
    data[1].f4.xy  = subgroupPartitionedExclusiveMinNV(data[1].f4.xy, ballot);
    data[1].f4.xyz = subgroupPartitionedExclusiveMinNV(data[2].f4.xyz, ballot);
    data[1].f4     = subgroupPartitionedExclusiveMinNV(data[3].f4, ballot);

    data[1].i4.x   = subgroupPartitionedExclusiveMinNV(data[0].i4.x, ballot);
    data[1].i4.xy  = subgroupPartitionedExclusiveMinNV(data[1].i4.xy, ballot);
    data[1].i4.xyz = subgroupPartitionedExclusiveMinNV(data[2].i4.xyz, ballot);
    data[1].i4     = subgroupPartitionedExclusiveMinNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedExclusiveMinNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedExclusiveMinNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedExclusiveMinNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedExclusiveMinNV(data[3].u4, ballot);

    data[2].f4.x   = subgroupPartitionedExclusiveMaxNV(data[0].f4.x, ballot);
    data[2].f4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].f4.xy, ballot);
    data[2].f4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].f4.xyz, ballot);
    data[2].f4     = subgroupPartitionedExclusiveMaxNV(data[3].f4, ballot);

    data[2].i4.x   = subgroupPartitionedExclusiveMaxNV(data[0].i4.x, ballot);
    data[2].i4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].i4.xy, ballot);
    data[2].i4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].i4.xyz, ballot);
    data[2].i4     = subgroupPartitionedExclusiveMaxNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedExclusiveMaxNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedExclusiveMaxNV(data[3].u4, ballot);

    data[2].i4.x   = subgroupPartitionedExclusiveAndNV(data[0].i4.x, ballot);
    data[2].i4.xy  = subgroupPartitionedExclusiveAndNV(data[1].i4.xy, ballot);
    data[2].i4.xyz = subgroupPartitionedExclusiveAndNV(data[2].i4.xyz, ballot);
    data[2].i4     = subgroupPartitionedExclusiveAndNV(data[3].i4, ballot);

    data[2].u4.x   = subgroupPartitionedExclusiveAndNV(data[0].u4.x, ballot);
    data[2].u4.xy  = subgroupPartitionedExclusiveAndNV(data[1].u4.xy, ballot);
    data[2].u4.xyz = subgroupPartitionedExclusiveAndNV(data[2].u4.xyz, ballot);
    data[2].u4     = subgroupPartitionedExclusiveAndNV(data[3].u4, ballot);

    data[3].i4.x   =   int(subgroupPartitionedExclusiveAndNV(data[0].i4.x < 0, ballot));
    data[3].i4.xy  = ivec2(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[3].i4.xyz = ivec3(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[3].i4     = ivec4(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[3].i4.x   = subgroupPartitionedExclusiveOrNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedExclusiveOrNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedExclusiveOrNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedExclusiveOrNV(data[3].i4, ballot);

    data[3].u4.x   = subgroupPartitionedExclusiveOrNV(data[0].u4.x, ballot);
    data[3].u4.xy  = subgroupPartitionedExclusiveOrNV(data[1].u4.xy, ballot);
    data[3].u4.xyz = subgroupPartitionedExclusiveOrNV(data[2].u4.xyz, ballot);
    data[3].u4     = subgroupPartitionedExclusiveOrNV(data[3].u4, ballot);

    data[3].i4.x   =   int(subgroupPartitionedExclusiveOrNV(data[0].i4.x < 0, ballot));
    data[3].i4.xy  = ivec2(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[3].i4.xyz = ivec3(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[3].i4     = ivec4(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[3].i4.x   = subgroupPartitionedExclusiveXorNV(data[0].i4.x, ballot);
    data[3].i4.xy  = subgroupPartitionedExclusiveXorNV(data[1].i4.xy, ballot);
    data[3].i4.xyz = subgroupPartitionedExclusiveXorNV(data[2].i4.xyz, ballot);
    data[3].i4     = subgroupPartitionedExclusiveXorNV(data[3].i4, ballot);

    data[0].u4.x   = subgroupPartitionedExclusiveXorNV(data[0].u4.x, ballot);
    data[0].u4.xy  = subgroupPartitionedExclusiveXorNV(data[1].u4.xy, ballot);
    data[0].u4.xyz = subgroupPartitionedExclusiveXorNV(data[2].u4.xyz, ballot);
    data[0].u4     = subgroupPartitionedExclusiveXorNV(data[3].u4, ballot);

    data[0].i4.x   =   int(subgroupPartitionedExclusiveXorNV(data[0].i4.x < 0, ballot));
    data[0].i4.xy  = ivec2(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[0].i4.xyz = ivec3(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[0].i4     = ivec4(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupQuad.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_quad: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.x   = subgroupQuadBroadcast(data[0].f4.x, 1u);
    data[0].f4.xy  = subgroupQuadBroadcast(data[1].f4.xy, 1u);
    data[0].f4.xyz = subgroupQuadBroadcast(data[2].f4.xyz, 1u);
    data[0].f4     = subgroupQuadBroadcast(data[3].f4, 1u);

    data[0].i4.x   = subgroupQuadBroadcast(data[0].i4.x, 1u);
    data[0].i4.xy  = subgroupQuadBroadcast(data[1].i4.xy, 1u);
    data[0].i4.xyz = subgroupQuadBroadcast(data[2].i4.xyz, 1u);
    data[0].i4     = subgroupQuadBroadcast(data[3].i4, 1u);

    data[0].u4.x   = subgroupQuadBroadcast(data[0].u4.x, 1u);
    data[0].u4.xy  = subgroupQuadBroadcast(data[1].u4.xy, 1u);
    data[0].u4.xyz = subgroupQuadBroadcast(data[2].u4.xyz, 1u);
    data[0].u4     = subgroupQuadBroadcast(data[3].u4, 1u);

    data[1].i4.x   =   int(subgroupQuadBroadcast(data[0].i4.x < 0, 1u));
    data[1].i4.xy  = ivec2(subgroupQuadBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1u));
    data[1].i4.xyz = ivec3(subgroupQuadBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1u));
    data[1].i4     = ivec4(subgroupQuadBroadcast(lessThan(data[1].i4, ivec4(0)), 1u));

    data[1].f4.x   = subgroupQuadSwapHorizontal(data[0].f4.x);
    data[1].f4.xy  = subgroupQuadSwapHorizontal(data[1].f4.xy);
    data[1].f4.xyz = subgroupQuadSwapHorizontal(data[2].f4.xyz);
    data[1].f4     = subgroupQuadSwapHorizontal(data[3].f4);

    data[1].i4.x   = subgroupQuadSwapHorizontal(data[0].i4.x);
    data[1].i4.xy  = subgroupQuadSwapHorizontal(data[1].i4.xy);
    data[1].i4.xyz = subgroupQuadSwapHorizontal(data[2].i4.xyz);
    data[1].i4     = subgroupQuadSwapHorizontal(data[3].i4);

    data[1].u4.x   = subgroupQuadSwapHorizontal(data[0].u4.x);
    data[1].u4.xy  = subgroupQuadSwapHorizontal(data[1].u4.xy);
    data[1].u4.xyz = subgroupQuadSwapHorizontal(data[2].u4.xyz);
    data[1].u4     = subgroupQuadSwapHorizontal(data[3].u4);

    data[2].i4.x   =   int(subgroupQuadSwapHorizontal(data[0].i4.x < 0));
    data[2].i4.xy  = ivec2(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xy, ivec2(0))));
    data[2].i4.xyz = ivec3(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[2].i4     = ivec4(subgroupQuadSwapHorizontal(lessThan(data[1].i4, ivec4(0))));

    data[2].f4.x   = subgroupQuadSwapVertical(data[0].f4.x);
    data[2].f4.xy  = subgroupQuadSwapVertical(data[1].f4.xy);
    data[2].f4.xyz = subgroupQuadSwapVertical(data[2].f4.xyz);
    data[2].f4     = subgroupQuadSwapVertical(data[3].f4);

    data[2].i4.x   = subgroupQuadSwapVertical(data[0].i4.x);
    data[2].i4.xy  = subgroupQuadSwapVertical(data[1].i4.xy);
    data[2].i4.xyz = subgroupQuadSwapVertical(data[2].i4.xyz);
    data[2].i4     = subgroupQuadSwapVertical(data[3].i4);

    data[2].u4.x   = subgroupQuadSwapVertical(data[0].u4.x);
    data[2].u4.xy  = subgroupQuadSwapVertical(data[1].u4.xy);
    data[2].u4.xyz = subgroupQuadSwapVertical(data[2].u4.xyz);
    data[2].u4     = subgroupQuadSwapVertical(data[3].u4);

    data[3].i4.x   =   int(subgroupQuadSwapVertical(data[0].i4.x < 0));
    data[3].i4.xy  = ivec2(subgroupQuadSwapVertical(lessThan(data[1].i4.xy, ivec2(0))));
    data[3].i4.xyz = ivec3(subgroupQuadSwapVertical(lessThan(data[1].i4.xyz, ivec3(0))));
    data[3].i4     = ivec4(subgroupQuadSwapVertical(lessThan(data[1].i4, ivec4(0))));

    data[3].f4.x   = subgroupQuadSwapDiagonal(data[0].f4.x);
    data[3].f4.xy  = subgroupQuadSwapDiagonal(data[1].f4.xy);
    data[3].f4.xyz = subgroupQuadSwapDiagonal(data[2].f4.xyz);
    data[3].f4     = subgroupQuadSwapDiagonal(data[3].f4);

    data[3].i4.x   = subgroupQuadSwapDiagonal(data[0].i4.x);
    data[3].i4.xy  = subgroupQuadSwapDiagonal(data[1].i4.xy);
    data[3].i4.xyz = subgroupQuadSwapDiagonal(data[2].i4.xyz);
    data[3].i4     = subgroupQuadSwapDiagonal(data[3].i4);

    data[3].u4.x   = subgroupQuadSwapDiagonal(data[0].u4.x);
    data[3].u4.xy  = subgroupQuadSwapDiagonal(data[1].u4.xy);
    data[3].u4.xyz = subgroupQuadSwapDiagonal(data[2].u4.xyz);
    data[3].u4     = subgroupQuadSwapDiagonal(data[3].u4);

    data[3].i4.x   =   int(subgroupQuadSwapDiagonal(data[0].i4.x < 0));
    data[3].i4.xy  = ivec2(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xy, ivec2(0))));
    data[3].i4.xyz = ivec3(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[3].i4     = ivec4(subgroupQuadSwapDiagonal(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupShuffle.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_shuffle: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.x   = subgroupShuffle(data[0].f4.x,    invocation);
    data[0].f4.xy  = subgroupShuffle(data[1].f4.xy,   invocation);
    data[0].f4.xyz = subgroupShuffle(data[2].f4.xyz,  invocation);
    data[0].f4     = subgroupShuffle(data[3].f4,      invocation);

    data[0].i4.x   = subgroupShuffle(data[0].i4.x,    invocation);
    data[0].i4.xy  = subgroupShuffle(data[1].i4.xy,   invocation);
    data[0].i4.xyz = subgroupShuffle(data[2].i4.xyz,  invocation);
    data[0].i4     = subgroupShuffle(data[3].i4,      invocation);

    data[1].u4.x   = subgroupShuffle(data[0].u4.x,    invocation);
    data[1].u4.xy  = subgroupShuffle(data[1].u4.xy,   invocation);
    data[1].u4.xyz = subgroupShuffle(data[2].u4.xyz,  invocation);
    data[1].u4     = subgroupShuffle(data[3].u4,      invocation);

    data[1].i4.x   =   int(subgroupShuffle(data[0].i4.x < 0,                   invocation));
    data[1].i4.xy  = ivec2(subgroupShuffle(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[1].i4.xyz = ivec3(subgroupShuffle(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[1].i4     = ivec4(subgroupShuffle(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[2].f4.x   = subgroupShuffleXor(data[0].f4.x,    invocation);
    data[2].f4.xy  = subgroupShuffleXor(data[1].f4.xy,   invocation);
    data[2].f4.xyz = subgroupShuffleXor(data[2].f4.xyz,  invocation);
    data[2].f4     = subgroupShuffleXor(data[3].f4,      invocation);

    data[2].i4.x   = subgroupShuffleXor(data[0].i4.x,    invocation);
    data[2].i4.xy  = subgroupShuffleXor(data[1].i4.xy,   invocation);
    data[2].i4.xyz = subgroupShuffleXor(data[2].i4.xyz,  invocation);
    data[2].i4     = subgroupShuffleXor(data[3].i4,      invocation);

    data[3].u4.x   = subgroupShuffleXor(data[0].u4.x,    invocation);
    data[3].u4.xy  = subgroupShuffleXor(data[1].u4.xy,   invocation);
    data[3].u4.xyz = subgroupShuffleXor(data[2].u4.xyz,  invocation);
    data[3].u4     = subgroupShuffleXor(data[3].u4,      invocation);

    data[3].i4.x   =   int(subgroupShuffleXor(data[0].i4.x < 0,                   invocation));
    data[3].i4.xy  = ivec2(subgroupShuffleXor(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[3].i4.xyz = ivec3(subgroupShuffleXor(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[3].i4     = ivec4(subgroupShuffleXor(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupShuffleRelative.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_shuffle_relative: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    data[0].f4.x   = subgroupShuffleUp(data[0].f4.x,    invocation);
    data[0].f4.xy  = subgroupShuffleUp(data[1].f4.xy,   invocation);
    data[0].f4.xyz = subgroupShuffleUp(data[2].f4.xyz,  invocation);
    data[0].f4     = subgroupShuffleUp(data[3].f4,      invocation);

    data[0].i4.x   = subgroupShuffleUp(data[0].i4.x,    invocation);
    data[0].i4.xy  = subgroupShuffleUp(data[1].i4.xy,   invocation);
    data[0].i4.xyz = subgroupShuffleUp(data[2].i4.xyz,  invocation);
    data[0].i4     = subgroupShuffleUp(data[3].i4,      invocation);

    data[1].u4.x   = subgroupShuffleUp(data[0].u4.x,    invocation);
    data[1].u4.xy  = subgroupShuffleUp(data[1].u4.xy,   invocation);
    data[1].u4.xyz = subgroupShuffleUp(data[2].u4.xyz,  invocation);
    data[1].u4     = subgroupShuffleUp(data[3].u4,      invocation);

    data[1].i4.x   =   int(subgroupShuffleUp(data[0].i4.x < 0,                   invocation));
    data[1].i4.xy  = ivec2(subgroupShuffleUp(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[1].i4.xyz = ivec3(subgroupShuffleUp(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[1].i4     = ivec4(subgroupShuffleUp(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[2].f4.x   = subgroupShuffleDown(data[0].f4.x,    invocation);
    data[2].f4.xy  = subgroupShuffleDown(data[1].f4.xy,   invocation);
    data[2].f4.xyz = subgroupShuffleDown(data[2].f4.xyz,  invocation);
    data[2].f4     = subgroupShuffleDown(data[3].f4,      invocation);

    data[2].i4.x   = subgroupShuffleDown(data[0].i4.x,    invocation);
    data[2].i4.xy  = subgroupShuffleDown(data[1].i4.xy,   invocation);
    data[2].i4.xyz = subgroupShuffleDown(data[2].i4.xyz,  invocation);
    data[2].i4     = subgroupShuffleDown(data[3].i4,      invocation);

    data[3].u4.x   = subgroupShuffleDown(data[0].u4.x,    invocation);
    data[3].u4.xy  = subgroupShuffleDown(data[1].u4.xy,   invocation);
    data[3].u4.xyz = subgroupShuffleDown(data[2].u4.xyz,  invocation);
    data[3].u4     = subgroupShuffleDown(data[3].u4,      invocation);

    data[3].i4.x   =   int(subgroupShuffleDown(data[0].i4.x < 0,                   invocation));
    data[3].i4.xy  = ivec2(subgroupShuffleDown(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[3].i4.xyz = ivec3(subgroupShuffleDown(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[3].i4     = ivec4(subgroupShuffleDown(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glsl.es320.subgroupVote.comp]=[
#version 320 es

#extension GL_KHR_shader_subgroup_vote: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    int r;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4u;

    if (subgroupAll(data[0].r < 0))
    {
        data[0].r = int(subgroupAllEqual(data[0].f4.x));
        data[0].r = int(subgroupAllEqual(data[1].f4.xy));
        data[0].r = int(subgroupAllEqual(data[2].f4.xyz));
        data[0].r = int(subgroupAllEqual(data[3].f4));

        data[0].r = int(subgroupAllEqual(data[0].i4.x));
        data[0].r = int(subgroupAllEqual(data[1].i4.xy));
        data[0].r = int(subgroupAllEqual(data[2].i4.xyz));
        data[0].r = int(subgroupAllEqual(data[3].i4));

        data[0].r = int(subgroupAllEqual(data[0].u4.x));
        data[0].r = int(subgroupAllEqual(data[1].u4.xy));
        data[0].r = int(subgroupAllEqual(data[2].u4.xyz));
        data[0].r = int(subgroupAllEqual(data[3].u4));
    }
    else if (subgroupAny(data[1].r < 0))
    {
        data[1].r = int(int(subgroupAllEqual(data[0].i4.x < 0)));
        data[1].r = int(ivec2(subgroupAllEqual(lessThan(data[1].i4.xy, ivec2(0)))));
        data[1].r = int(ivec3(subgroupAllEqual(lessThan(data[1].i4.xyz, ivec3(0)))));
        data[1].r = int(ivec4(subgroupAllEqual(lessThan(data[1].i4, ivec4(0)))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glspv.esversion.vert]=[
#version 310 es

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glspv.frag]=[
#version 450

#ifdef GL_SPIRV
#error GL_SPIRV is set ( correct, not an error )
#if GL_SPIRV == 100
#error GL_SPIR is 100
#endif
#endif

void main()
{
}

uniform float f;                           // ERROR, no location
layout(location = 2) uniform float g;
uniform sampler2D s1;                      // ERROR, no binding
layout(location = 3) uniform sampler2D s2; // ERROR, no binding

void noise()
{
    noise1(vec4(1));
    noise2(4.0);
    noise3(vec2(3));
    noise4(1);
}

uniform atomic_uint atomic;                // ERROR, no binding
layout(input_attachment_index = 1) uniform subpassInput sub; // ERROR, no inputs

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glspv.version.frag]=[
#version 330 compatibility

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glspv.version.vert]=[
#version 150

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[glspv.vert]=[
#version 450

layout(push_constant) uniform Material { int a; } mat;            // ERROR, can't use push_constant

layout(set = 0, binding = 0, std140) uniform Bt1 { int a; } bt1;
layout(set = 1, binding = 0, std140) uniform Bt2 { int a; } bt2;  // ERROR, set has to be 0

layout(shared) uniform Bt3 { int a; } bt3;                        // ERROR, no shared, no binding
layout(packed) uniform Bt4 { int a; } bt4;                        // ERROR, no shared, no binding

void main()
{
    gl_VertexIndex;   // ERROR, not preset
    gl_InstanceIndex; // ERROR, not present
    gl_VertexID;
    gl_InstanceID;
    gl_DepthRangeParameters; // ERROR, not present
}

uniform sampler s; // ERROR, no sampler

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[implicitInnerAtomicUint.frag]=[
#version 460
layout(binding = 0) uniform atomic_uint c[1][];
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[include.vert]=[
#version 450

#extension GL_GOOGLE_include_directive : enable

#define float4 vec4

#include "bar.h"
#include "./inc1/bar.h"
#include "inc2\bar.h"

out vec4 color;

void main()
{
    color = i1 + i2 + i3 + i4 + i5 + i6;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[invalidSwizzle.vert]=[
#version 420

void f();
uniform sampler2D s;

void main() {
    vec2 v = s.rr; // Swizzles do not apply to samplers
    f().xx; // Scalar swizzle does not apply to void
    f().xy; // Vector swizzle does not apply either
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.2.frag]=[
#version 460
.
.
layout(location = 5) in outBlock {
    vec4 o3;
};
.
.
in vec4 gfo1;
in vec2 gfo2;

out vec4 outColor;

uniform vec2 u1;
uniform vec3 u2;           // initializer present in vertex stage
uniform vec4 u3 = vec4(0); // initializer matches initializer in vertex stage

uniform mat2 um2 = mat2(4.0);

layout (location = 0, binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

buffer fragOnlyBlock {
    vec2 fb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName2 [2]; // instance name different from vert
.
.
void main()
{
    vec4 color = gfo1 * u1.rgrg * u2.rgbr * u3.rgba;        // o1 is statically used
    outColor = color;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.2.geom]=[
#version 460

layout(points) in;
layout(triangle_strip, max_vertices=3) out;

in vec4 vgo1[];
in vec2 vgo2[];

layout(location = 5) in outBlock {
    vec4 o3;
} inBlock[];

out vec4 gfo1;
out vec2 gfo2;

layout(location = 5) out outBlock {
    vec4 o3;
} gf_out;

uniform vec2 u1;
uniform vec3 u2 = vec3(0); // initializer not present in fragment stage
uniform vec4 u3 = vec4(0); // initializer matches initializer in fragment stage

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName1 [2]; // instance name different from frag

void main()
{
    for (int i = 0; i < 3; i++) {
        gfo1 = vec4(0);
        gfo2 = vec2(0);
        gf_out.o3 = inBlock[i].o3;
        EmitVertex();
    }
    EndPrimitive();
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.2.vert]=[
#version 460

out vec4 vgo1; // declaration order different than fragment shader
out vec2 vgo2; // declaration order different than fragment shader

layout(location = 5) out outBlock {
    vec4 o3;
};

uniform vec2 u1;
uniform vec3 u2 = vec3(0); // initializer not present in fragment stage
uniform vec4 u3 = vec4(0); // initializer matches initializer in fragment stage

uniform mat2 um2 = mat2(4.0);

layout (location = 0, binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

buffer vertOnlyBlock {
    vec2 vb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName1 [2]; // instance name different from frag

void main()
{
    vgo1 = vec4(0);
    vgo2 = vec2(0);
    o3 = vec4(0);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.frag]=[
#version 460
.
.
layout(location = 5) in outBlock {
    vec4 o3;
};

in vec2 o2; // declaration order different than vertex shader
in vec4 o1; // declaration order different than vertex shader

out vec4 outColor;

uniform vec2 u1;
uniform vec3 u2;    // initializer present in vertex stage
uniform vec4 u3 = vec4(0); // initializer matches initializer in vertex stage

uniform mat2 um2 = mat2(4.0);

layout (location = 0, binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

buffer fragOnlyBlock {
    vec2 fb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName2 [2]; // instance name different from vert
.
.
void main()
{
    vec4 color = o1 * u1.rgrg * u2.rgbr * u3.rgba;        // o1 is statically used
    outColor = color;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.vert]=[
#version 460

out vec4 o1; // declaration order different than fragment shader
out vec2 o2; // declaration order different than fragment shader

layout(location = 5) out outBlock {
    vec4 o3;
};

uniform vec2 u1;
uniform vec3 u2 = vec3(0); // initializer not present in fragment stage
uniform vec4 u3 = vec4(0); // initializer matches initializer in fragment stage

uniform mat2 um2 = mat2(4.0);

layout (location = 0, binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

buffer vertOnlyBlock {
    vec2 vb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName1 [2]; // instance name different from frag

void main()
{
    o1 = vec4(0);
    o2 = vec2(0);
    o3 = vec4(0);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.vk.frag]=[
#version 460
.
.
layout(location = 5) in outBlock {
    vec4 o3;
};
.
.
in vec4 gfo1;
in vec2 gfo2;

out vec4 outColor;

layout (binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

readonly buffer fragOnlyBlock {
    vec2 fb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName2 [2]; // instance name different from vert

vec2 Bar() {
    return  fb1 + 
            blockName2[0].b +
            blockName2[1].b;
}

vec4 Foo() {
    return  a + 
            b + 
            blockName2[0].a +
            blockName2[1].a +
            vec4(Bar(), 0.0, 0.0);
}

void main()
{
    vec4 color = gfo1; // o1 is statically used
    color = color + Foo();
    outColor = color;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.vk.geom]=[
#version 460

layout(points) in;
layout(triangle_strip, max_vertices=3) out;

in vec4 vgo1[];
in vec2 vgo2[];

layout(location = 5) in outBlock {
    vec4 o3;
} inBlock[];

out vec4 gfo1;
out vec2 gfo2;

layout(location = 5) out outBlock {
    vec4 o3;
} gf_out;

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName1 [2]; // instance name different from frag

void main()
{
    for (int i = 0; i < 3; i++) {
        gfo1 = vec4(0);
        gfo2 = vec2(0);
        gf_out.o3 = inBlock[i].o3;
        EmitVertex();
    }
    EndPrimitive();
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[iomap.crossStage.vk.vert]=[
#version 460

out vec4 vgo1; // declaration order different than fragment shader
out vec2 vgo2; // declaration order different than fragment shader

layout(location = 5) out outBlock {
    vec4 o3;
};

layout (binding = 0) uniform sampler2D glass;

uniform crossStageBlock1 {
    uniform vec4 a;
    vec4 b;
};

readonly buffer vertOnlyBlock {
    vec2 vb1;
};

uniform crossStageBlock2 {
    uniform vec4 a;
    vec2 b;
} blockName1 [2]; // instance name different from frag

void main()
{
    vgo1 = vec4(0);
    vgo2 = vec2(0);
    o3 = vec4(0);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[length.frag]=[
#version 120

uniform vec4 u[3];

#ifdef TEST_POST_110
varying vec2 v[];
#else
varying vec2 v[2];
#endif

void main()
{
    int a[5];

    vec2 t = v[0] + v[1];

    gl_FragColor = vec4(u.length() * v.length() * a.length());
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[lineContinuation.vert]=[
#version 300 es

// this file cont\
ains no errors other than the #error which are there to see if line numbering for errors is correct

#error e1

float f\
oo;  // same as 'float foo;'

#error e2

#define MAIN void main() \
   {                     \
gl_Position = vec4(foo); \
} 

#error e3

MAIN

vec4 foo2(vec4 a)
{                                
  vec4 b = a;       \
  return b;                   
}

// aoeuntheo unatehutna \ antaehnathe 
// anteonuth $ natohe " '
// anteonuth     natohe

#define FOO int /* \
*/ goodDecl;

FOO

#define A int q1 = \ 1
#define B int q2 = \1
#define C int q3 = $ 1
#define D int q4 = @ 1

const highp int a1 = \ 4;  // ERROR
const highp int a2 = @ 3;  // ERROR
const highp int a3 = $4;   // ERROR
const highp int a4 = a2\;  // ERROR

A;
B;
C;
D;

# \

# \
    error good continuation

#define AA1 a \ b
#define AA2 a \\ b
#define AA3 a \\\ b
#define AA4 a \\\\ b

// anoetuh nonaetu \\\\\\
still in comment

const int abdece = 10;
const int aoeuntaoehu = abd\
\
\
\
\
\
ece;

float funkyf = \
.\
1\
2\
3\
e\
+\
1\
7\
;\
int funkyh\
=\
0\
x\
f\
4\
;
int funkyo =\
0\
4\
2\
;
int c = \
11;
int d = 1\
2;

#define FOOM(a,b) a + b

#if FO\
OM(2\
,\
3)
int bar103 = 17;
#endif

// ERROR
#if FOOM(2,
3)
int bar104 = 19;
#endif

// ERROR
#if FOOM(
2,3)
int bar105 = 19;
#endif

int bar106 = FOOM(5,7);
int bar107 = FOOM  // okay
    (
    2
    ,
    3
    )
    ;

void foo203209409()
{
    bar107 \
+= 37;
    bar107 *\
= 38;
    bar107 /=\
39;
    bar107 +\
41;
}

#define QUOTE "ab\
cd"

void foo230920394()
{
    // syntax error
    bar107 +\
 = 42;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
42:21; <no symbol>; token recognition error at: '\ '; LexerNoViableAltException:null
43:21; <no symbol>; token recognition error at: '@'; LexerNoViableAltException:null
44:21; <no symbol>; token recognition error at: '$'; LexerNoViableAltException:null
45:23; <no symbol>; token recognition error at: '\;'; LexerNoViableAltException:null
4:8; [@13,44:49='errors',<IDENTIFIER>,4:8]; no viable alternative at input 'ains no errors'; NoViableAltException:null
22:0; [@59,300:303='vec4',<F32VEC4>,22:0]; no viable alternative at input 'MAIN\n\nvec4'; NoViableAltException:null
42:0; [@118,630:634='const',<'const'>,42:0]; no viable alternative at input 'FOO\n\n#define A int q1 = \ 1\n#define B int q2 = \1\n#define C int q3 = $ 1\n#define D int q4 = @ 1\n\nconst'; NoViableAltException:null
47:0; [@175,775:775='A',<IDENTIFIER>,47:0]; extraneous input 'A' expecting ';'; <no exception>
55:4; [@193,801:805='error',<NR_IDENTIFIER>,55:4]; no viable alternative at input '# \\n    error'; NoViableAltException:null
72:0; [@247,1011:1013='ece',<IDENTIFIER>,72:0]; extraneous input 'ece' expecting ';'; <no exception>
75:0; [@258,1034:1034='.',<'.'>,75:0]; extraneous input '.' expecting {'atomic_uint', 'struct', UINT16CONSTANT, INT16CONSTANT, UINT32CONSTANT, INT32CONSTANT, UINT64CONSTANT, INT64CONSTANT, FLOAT16CONSTANT, FLOAT32CONSTANT, FLOAT64CONSTANT, BOOLCONSTANT, 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', '++', '--', 'void', LPAREN, '{', '+', '-', '!', '~', IDENTIFIER}; <no exception>
77:0; [@262,1040:1040='2',<INT32CONSTANT>,77:0]; mismatched input '2' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
87:0; [@284,1079:1079='x',<IDENTIFIER>,87:0]; missing ';' at 'x'; <no exception>
93:0; [@300,1107:1107='4',<INT32CONSTANT>,93:0]; mismatched input '4' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
99:0; [@324,1140:1140='2',<INT32CONSTANT>,99:0]; extraneous input '2' expecting ';'; <no exception>
112:0; [@357,1235:1235='3',<INT32CONSTANT>,112:0]; extraneous input '3' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
118:0; [@376,1282:1282='2',<INT32CONSTANT>,118:0]; extraneous input '2' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
136:0; [@457,1456:1456='=',<'='>,136:0]; extraneous input '=' expecting {'atomic_uint', 'struct', UINT16CONSTANT, INT16CONSTANT, UINT32CONSTANT, INT32CONSTANT, UINT64CONSTANT, INT64CONSTANT, FLOAT16CONSTANT, FLOAT32CONSTANT, FLOAT64CONSTANT, BOOLCONSTANT, 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', '++', '--', 'void', LPAREN, '+', '-', '!', '~', IDENTIFIER}; <no exception>
150:1; [@503,1583:1583='=',<'='>,150:1]; extraneous input '=' expecting {'atomic_uint', 'struct', UINT16CONSTANT, INT16CONSTANT, UINT32CONSTANT, INT32CONSTANT, UINT64CONSTANT, INT64CONSTANT, FLOAT16CONSTANT, FLOAT32CONSTANT, FLOAT64CONSTANT, BOOLCONSTANT, 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', '++', '--', 'void', LPAREN, '+', '-', '!', '~', IDENTIFIER}; <no exception>
]


testGlslangErrors[lineContinuation100.vert]=[
#version 100

// non-line continuation comment \
#error good error
.
.

float f\
oo;  // same as 'float foo;'

#error e2

#define MAIN void main() \
   {                     \
gl_Position = vec4(foo); \
} 

#error e3

MAIN

vec4 foo2(vec4 a)
{                                
  vec4 b = a;       \
  return b;                   
}

// aoeuntheo unatehutna \ antaehnathe 
// anteonuth $ natohe " '
// anteonuth     natohe
/*@*/
/* *@/*/
//@

#define A int q1 = \ 1
#define B int q2 = \1
#define C int q3 = $ 1
#define D int q4 = @ 1

const highp int a1 = \ 4;  // ERROR
const highp int a2 = @ 3;  // ERROR
const highp int a3 = $4;   // ERROR
const highp int a4 = a2\;  // ERROR

A;
B;
C;
D;

# \

# \
    error bad continuation

#define QUOTE "ab\
cd"

<><><><><><><><><><><><><><><><><><><><><><><><><>
40:21; <no symbol>; token recognition error at: '\ '; LexerNoViableAltException:null
41:21; <no symbol>; token recognition error at: '@'; LexerNoViableAltException:null
42:21; <no symbol>; token recognition error at: '$'; LexerNoViableAltException:null
43:23; <no symbol>; token recognition error at: '\;'; LexerNoViableAltException:null
9:0; [@17,87:88='oo',<IDENTIFIER>,9:0]; no viable alternative at input 'float f\\r\noo'; NoViableAltException:null
22:0; [@43,243:246='vec4',<F32VEC4>,22:0]; no viable alternative at input 'MAIN\r\n\r\nvec4'; NoViableAltException:null
45:0; [@155,720:720='A',<IDENTIFIER>,45:0]; extraneous input 'A' expecting ';'; <no exception>
53:4; [@173,754:758='error',<NR_IDENTIFIER>,53:4]; no viable alternative at input '# \\r\n    error'; NoViableAltException:null
]


testGlslangErrors[link.multiAnonBlocksInvalid.0.0.vert]=[
#version 430

// Error: Block has different members
layout (std140) uniform Block
{
	mat4 uProj;
};

// Error: BufferBlock has different members
buffer BufferBlock
{
	vec4 b;
};

// Error: Vertex has different members
out Vertex
{
	vec4 v1;
};

// Error: ColorBlock has different members
layout (std140) uniform ColorBlock
{
	vec4 color1;
	vec4 color2;
	// Error, redeclare varaible in another anonymous block
	vec4 v1;
};

// Error: NamedBlock is anonymous in other compilation unit
layout (std140) uniform NamedBlock
{
	mat4 m;
} myName;

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

// Error: redeclare varaibles that are in anonymous blocks
out vec4 v1;
uniform mat4 uProj;

void
main()
{
	oColor = color1 * getColor2();
	v1 = color1;

	gl_Position = uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiAnonBlocksInvalid.0.1.vert]=[
#version 430

// Error: ColorBlock has different members
layout (std140) uniform ColorBlock
{
	vec4 color2;
};

// Error: Block has different members
layout (std140) uniform Block
{
	mat4 uProj;
	mat4 uWorld;
};

// Error: Vertex has different members
out Vertex
{
	vec4 v1;
	vec4 v2;
};

// Error BufferBlock has different members
buffer BufferBlock
{
	vec4 a;
};

// Error: NamedBlock is anonymous in other compilation unit
layout (std140) uniform NamedBlock
{
	mat4 m;
};
.
.
in vec4 P;

vec4 getColor2()
{
	return color2;
}

vec4 getWorld()
{
	return uWorld * P;
	v2 = vec4(1);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiAnonBlocksValid.0.0.vert]=[
#version 430

// Verify that matching by block name is working, not
// instance name, which was at one point failing on this
// test due to E.g anon@1 being different blocks for
// different compilation units

layout (std140) uniform Block
{
	mat4 uProj;
	mat4 uWorld;
};

out Vertex
{
	vec4 v1;
	vec4 v2;
};

layout (std140) uniform ColorBlock
{
	vec4 color1;
	vec4 color2;
};

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

void
main()
{
	oColor = color1 * getColor2();
	v1 = color1;

	gl_Position = uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiAnonBlocksValid.0.1.vert]=[
#version 430

layout (std140) uniform ColorBlock
{
	vec4 color1;
	vec4 color2;
};

layout (std140) uniform Block
{
	mat4 uProj;
	mat4 uWorld;
};

out Vertex
{
	vec4 v1;
	vec4 v2;
};
.
.
in vec4 P;

vec4 getColor2()
{
	return color2;
}

vec4 getWorld()
{
	return uWorld * P;
	v2 = vec4(1);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiBlocksInvalid.0.0.vert]=[
#version 430

// Verify that blocks with different instance names
// are correctly detected as invalid non-matching blocks
// when they are matched up by block name
layout (std140) uniform Block
{
	mat4 uProj;
} uD;

out Vertex
{
	vec4 v1;
} oV;

layout (std140) uniform ColorBlock
{
	vec4 color1;
} uC;

// Error, buffer blocks and uniform blocks share the
// same namespace for their block name
layout (std430) buffer ColorBlock
{
	vec4 color1;
} uBufC;

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

void
main()
{
	oColor = uC.color1 * getColor2();
	oV.v1 = uC.color1 + uBufC.color1;

	gl_Position = uD.uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiBlocksInvalid.0.1.vert]=[
#version 430

layout (std140) uniform ColorBlock
{
	vec4 color2;
} uColorB;

layout (std140) uniform Block
{
	mat4 uWorld;
} uDefaultB;

out Vertex
{
	vec4 v2;
} oVert;
.
.
in vec4 P;

vec4 getColor2()
{
	return uColorB.color2;
}

vec4 getWorld()
{
	return uDefaultB.uWorld * P;
	oVert.v2 = vec4(1);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiBlocksValid.1.0.vert]=[
#version 430
layout (std140) uniform Block
{
	mat4 uProj;
	mat4 uWorld;
} a;

out Vertex
{
	vec4 v1;
	vec4 v2;
} b;

layout (std140) uniform ColorBlock
{
	vec4 color1;
	vec4 color2;
} c;

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

void
main()
{
	oColor = c.color1 * getColor2();
	b.v1 = c.color1;

	gl_Position = a.uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.multiBlocksValid.1.1.vert]=[
#version 430

layout (std140) uniform ColorBlock
{
	vec4 color1;
	vec4 color2;
} a;

layout (std140) uniform Block
{
	mat4 uProj;
	mat4 uWorld;
} b;

out Vertex
{
	vec4 v1;
	vec4 v2;
} c;
.
.
in vec4 P;

vec4 getColor2()
{
	return a.color2;
}

vec4 getWorld()
{
	return b.uWorld * P;
	c.v2 = vec4(1);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.tesselation.frag]=[
#version 440

layout(location = 0) in Primitive
{
    vec2 texCoord;
} IN;

layout(location = 0) out vec4 oColor;

layout(binding = 0) uniform sampler2D mytex;

void main()
{
    oColor = texture(mytex, IN.texCoord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.tesselation.tesc]=[
#version 440

layout(location = 0) in Primitive
{
    vec2 texCoord;
} IN[];

layout(location = 0) out Primitive
{
    vec2 texCoord;
} OUT[];

layout(vertices = 3) out;
void main()
{
    OUT[gl_InvocationID].texCoord = IN[gl_InvocationID].texCoord;

    float tessLevel = 10.0;
    gl_TessLevelOuter[gl_InvocationID] = tessLevel;
    gl_TessLevelInner[0] = tessLevel;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.tesselation.tese]=[
#version 440

layout(location = 0) in Primitive
{
    vec2 texCoord;
} IN[];

layout(location = 0) out Primitive
{
    vec2 texCoord;
} OUT;

layout(triangles, fractional_odd_spacing) in;
layout(cw) in;
void main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;
    float w = gl_TessCoord.z;

    vec2 newUv = vec2( u * IN[0].texCoord + v * IN[1].texCoord + w * IN[2].texCoord);
    OUT.texCoord = newUv;
    gl_Position = gl_in[gl_PatchVerticesIn].gl_Position;
}
.
.

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.tesselation.vert]=[
#version 440

layout(location = 0) in vec4 i_Pos;
layout(location = 1) in vec2 i_Tex;

layout(location = 0) out Primitive
{
    vec2 texCoord;
} OUT;

void main()
{
    gl_Position = i_Pos;
    OUT.texCoord = i_Tex;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.0.0.frag]=[
#version 450

layout(location=0) out vec4 color;

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4 getColor2();
float getScale();

void main()
{
    color = uPC.color + getColor2() * getScale();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.0.1.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4
getColor2()
{
	return uPC.color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.0.2.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale2;
} uPC;

float
getScale()
{
	return uPC.scale2;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.1.0.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
	float scale2;
} uPC;

float
getScale()
{
	return uPC.scale;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.1.1.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4
getColor2()
{
	return uPC.color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.differentPC.1.2.frag]=[
#version 450

layout(location=0) out vec4 color;

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4 getColor2();
float getScale();

void main()
{
    color = uPC.color + getColor2() * getScale();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.inconsistentGLPerVertex.0.geom]=[
#version 460 core

layout(lines_adjacency) in; 
layout(triangle_strip, max_vertices = 50) out;

in vs_output 
{ 
	vec4 color;
} gs_in[]; 

out gs_output
{
	vec4 color;
} gs_out;

void main()
{
	gl_Position = gl_in[0].gl_Position;
	gs_out.color = gs_in[0].color;
	EmitVertex();
	gs_out.color = gs_in[1].color;
	gl_Position = gl_in[1].gl_Position;
	EmitVertex();
	gs_out.color = gs_in[0].color;
	gl_Position = gl_in[0].gl_Position;
	EmitVertex();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.inconsistentGLPerVertex.0.vert]=[
#version 460 core

// This test is to test isInconsistentGLPerVertexMember() workarounds.
// Without that workaround this compile fails due to block declarations
// in gl_PerVertex not being consistent for:
// gl_SecondaryPositionNV
// gl_PositionPerViewNV

out vs_output 
{ 
	vec4 color;
} vs_out; 

in vec4 P;
void main()
{
	vs_out.color = vec4(1.);
	gl_PointSize = 1.0;
	gl_Position = P;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.matchingPC.0.0.frag]=[
#version 450

layout(location=0) out vec4 color;

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4 getColor2();
float getScale();

void main()
{
    color = uPC.color + getColor2() * getScale();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.matchingPC.0.1.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

vec4
getColor2()
{
	return uPC.color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.matchingPC.0.2.frag]=[
#version 450

layout (push_constant) uniform PushConstantBlock
{
	vec4 color;
	vec4 color2;
	float scale;
} uPC;

float
getScale()
{
	return uPC.scale;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.multiBlocksValid.0.0.vert]=[
#version 430

// OK: different instance names is allowed in other unit
layout (std140, binding = 0) uniform MatrixBlock
{
	mat4 uProj;
	mat4 uWorld;
} uM;

// OK: other unit has it as anonymous, but that is allowed
out Vertex
{
	vec4 v1;
	vec4 v2;
} oV;

// OK: different instance names is allowed in other unit
layout (std140, binding = 1) uniform ColorBlock
{
	vec4 color1;
	bool b;
	vec4 color2;
	vec4 color3;
} uC;

// OK: different instance names is allowed in other unit
layout (std430, binding = 1) buffer BufferBlock
{
	mat4 p;
} uBuf;

layout (std430, binding = 0) buffer SecondaryColorBlock
{
	vec4 c;
} uColorBuf;

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

void
main()
{
	oColor = uC.color1 * getColor2() * uColorBuf.c;
	oV.v1 = uC.color1;

	gl_Position = uM.uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.multiBlocksValid.0.1.vert]=[
#version 430

// OK: different instance names is allowed in other unit
layout (std140, binding = 1) uniform ColorBlock
{
	vec4 color1;
	bool b;
	vec4 color2;
	vec4 color3;
} uColor;

// OK: different instance names is allowed in other unit
layout (std430, binding = 1) buffer BufferBlock
{
	mat4 p;
} uBuffer;

// OK: different instance names is allowed in other unit
layout (std140, binding = 0) uniform MatrixBlock
{
	mat4 uProj;
	mat4 uWorld;
} uMatrix;

// OK, it's allowed for input/output interfaces to
// be anonymous is one unit and not in another
out Vertex
{
	vec4 v1;
	vec4 v2;
};
.
.
in vec4 P;

vec4 getColor2()
{
	return uColor.color2;
}

vec4 getWorld()
{
	v1 = vec4(1);
	return uMatrix.uWorld * P;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.multiBlocksValid.1.0.geom]=[
#version 430

layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

// OK: different instance names is allowed
layout (std140, binding = 0) uniform MatrixBlock
{
	mat4 uProj;
	mat4 uWorld;
} uM;

// Verify that in/out blocks with same block name work
in Vertex
{
	vec4 v1;
	vec4 v2;
} iV[3];

out Vertex
{
	vec4 val1;
} oV;

// OK: different instance names is allowed
layout (std140, binding = 1) uniform ColorBlock
{
	vec4 color1;
	bool b;
	vec4 color2;
	vec4 color3;
} uC;

// OK: different instance names is allowed
layout (std430, binding = 1) buffer BufferBlock
{
	mat4 p;
} uBuf;

vec4 getWorld(int i);
vec4 getColor2();

out vec4 oColor;

float globalF;

void
main()
{
	oColor = uC.color1 * getColor2();

	globalF = 1.0;

	for (int i = 0; i < 3; i++)
	{
		gl_Position = uM.uProj * getWorld(i);
		oV.val1 = uC.color1 + iV[i].v2 * globalF;
		EmitVertex();
	}

	EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.multiBlocksValid.1.1.geom]=[
#version 430

layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

// OK: different instance names is allowed
layout (std140, binding = 1) uniform ColorBlock
{
	vec4 color1;
	bool b;
	vec4 color2;
	vec4 color3;
} uColor;

// OK: different instance names is allowed
layout (std430, binding = 1) buffer BufferBlock
{
	mat4 p;
} uBuffer;

// OK: different instance names is allowed
layout (std140, binding = 0) uniform MatrixBlock
{
	mat4 uProj;
	mat4 uWorld;
} uMatrix;

// OK, it's allowed for input/output interfaces to
// be anonymous is one unit and not in another
out Vertex
{
	vec4 val1;
};

in Vertex
{
	vec4 v1;
	vec4 v2;
} iVV[];
.
.
in vec4 P[3];

vec4 getColor2()
{
	return uColor.color2;
}

vec4 getWorld(int i)
{
	val1 = vec4(1);
	return uMatrix.uWorld * iVV[i].v1;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.pcNamingInvalid.0.0.vert]=[
#version 450
layout (push_constant) uniform Block
{
	mat4 uWorld;
	mat4 uProj;
	vec4 color1;
	vec4 color2;
} a;

vec4 getWorld();
vec4 getColor2();

out vec4 oColor;

void
main()
{
	oColor = a.color1 * getColor2();

	gl_Position = a.uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.pcNamingInvalid.0.1.vert]=[
#version 450

layout (push_constant) uniform Block2
{
	mat4 uWorld;
	mat4 uProj;
	vec4 color1;
	vec4 color2;
} a;

in vec4 P;

vec4 getColor2()
{
	return a.color2;
}

vec4 getWorld()
{
	return a.uWorld * P;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.pcNamingValid.0.0.vert]=[
#version 450
layout (push_constant) uniform PCBlock
{
	mat4 uWorld;
	mat4 uProj;
	vec4 color1;
	vec4 color2;
} a;

vec4 getWorld();
vec4 getColor2();

layout(location = 0) out vec4 oColor;

void
main()
{
	oColor = a.color1 * getColor2();

	gl_Position = a.uProj * getWorld();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link.vk.pcNamingValid.0.1.vert]=[
#version 450

layout (push_constant) uniform PCBlock
{
	mat4 uWorld;
	mat4 uProj;
	vec4 color1;
	vec4 color2;
} b;

layout(location = 0) in vec4 P;

vec4 getColor2()
{
	return b.color2;
}

vec4 getWorld()
{
	return b.uWorld * P;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link1.frag]=[
#version 130

uniform vec4 uv4;
uniform vec3 glass;

const int ci = 8;

vec4 a = ci * uv4;

in vec3 iv3;
in vec4 cup;

void main()
{
}

vec4 b = ci * a;

ivec2 foo(mat2 m)
{
    return ivec2(m[0]);
}

vec4 c = b * b;

const vec3 cv3 = vec3(43.0, 0.34, 9.9);
const vec3 cv3n = vec3(43.0, 0.34, 9.9);
const vec3 cv3e = vec3(43.0, 0.34, 9.9);
uniform mat2 um2 = mat2(4.0);
uniform mat2 um2n = mat2(4.0);
uniform mat2 um2e = mat2(4.0);
struct S {
    int a;
    float b;
};
uniform S s = S(82, 3.9);
uniform S sn;
uniform S se = S(82, 3.9);

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link1.vk.frag]=[
#version 450

vec4 getColor();

layout(location=0) out vec4 color;

int a1[];  // max size from link1
int a2[];  // max size from link2
int b[5];
int c[];
int i;

layout (binding = 0) buffer bnameRuntime  { float r[]; };
layout (binding = 1) buffer bnameImplicit { float m[]; };

void main()
{
    color = getColor();

    a1[8] = 1;
    a2[1] = 1;
    b[i] = 1;
    c[3] = 1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link2.frag]=[
#version 130

uniform vec4 uv4;
uniform vec2 glass;

const int ci = 8;

vec4 d = ci * uv4;

in vec3 iv3;
flat in vec4 cup;

vec4 e = ci * d;

ivec2 foo()
{
    return ivec2(2);
}

vec4 f = e * e;

const vec3 cv3 = vec3(43.0, 0.34, 9.9);
const vec3 cv3e = vec3(43.0, 0.34, 2.9);
uniform mat2 um2 = mat2(4.0);
uniform mat2 um2n;
uniform mat2 um2e = mat2(3.0);
struct S {
    int a;
    float b;
};
uniform S s = S(82, 3.9);
uniform S sn = S(82, 3.9);
uniform S se = S(81, 3.9);

#extension GL_OES_texture_3D : enable
#extension GL_OES_standard_derivatives : enable

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link2.vk.frag]=[
#version 450

layout(binding=1) uniform sampler2D s2D;

int a1[];  // max size from link1
int a2[];  // max size from link2
int b[];
int c[7];
int i;

layout (binding = 0) buffer bnameRuntime  { float r[]; };
layout (binding = 1) buffer bnameImplicit { float m[4]; };

vec4 getColor()
{
    a1[2] = 1;
    a2[9] = 1;
    b[2] = 1;
    c[3] = 1;
    c[i] = 1;

    return texture(s2D, vec2(0.5));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[link3.frag]=[
#version 300 es

precision highp float;

in vec2 iv3;

#extension GL_OES_standard_derivatives : enable
#extension GL_OES_EGL_image_external : require
#extension GL_OES_texture_3D : enable

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[localAggregates.frag]=[
#version 130

uniform sampler2D sampler;
varying vec2 coord;
varying vec4 color;

struct s1 {
    int i;
    float f;
};

struct s2 {
    int i;
    float f;
	s1 s1_1;
	vec4 bleh;
};

struct s3 {
	s2 s2_1;
    int i;
    float f;
	s1 s1_1;
};
.
.
uniform s1 foo;
uniform s2 foo2;
uniform s3 foo3;

uniform float[16] uFloatArray;
uniform int condition;

void main()
{
	s2 locals2;
	s3 locals3;
	float localFArray[16];
	int localIArray[8];

	locals2 = foo3.s2_1;

	if (foo3.s2_1.i > 0) {
		locals2.s1_1.f = 1.0;
		localFArray[4] = coord.x;
		localIArray[2] = foo3.s2_1.i;
	} else {
		locals2.s1_1.f = coord.x;
		localFArray[4] = 1.0;
		localIArray[2] = 0;
	}

	if (localIArray[2] == 0)
		++localFArray[4];

 	float localArray[16];
	int x = 5;
	localArray[x] = coord.x;

	float[16] a;

	for (int i = 0; i < 16; i++)
		a[i] = 0.0;
	
	if (condition == 1)
		a = localArray;
	
	locals2.bleh = color;
	locals2.bleh.z = coord.y;

	gl_FragColor = locals2.bleh * (localFArray[4] + locals2.s1_1.f + localArray[x] + a[x]) * texture2D(sampler, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[loops.frag]=[
#version 130
uniform vec4 bigColor;
uniform vec4 bigColor1_1;
uniform vec4 bigColor1_2;
uniform vec4 bigColor1_3;
uniform vec4 bigColor2;
uniform vec4 bigColor3;
uniform vec4 bigColor4;
uniform vec4 bigColor5;
uniform vec4 bigColor6;
uniform vec4 bigColor7;
uniform vec4 bigColor8;

varying vec4 BaseColor;

uniform float d;
uniform float d2;
uniform float d3;
uniform float d4;
uniform float d5;
uniform float d6;
uniform float d7;
uniform float d8;
uniform float d9;
uniform float d10;
uniform float d11;
uniform float d12;
uniform float d13;
uniform float d14;
uniform float d15;
uniform float d16;
uniform float d17;
uniform float d18;
uniform float d19;
uniform float d20;
uniform float d21;
uniform float d22;
uniform float d23;
uniform float d24;
uniform float d25;
uniform float d26;
uniform float d27;
uniform float d28;
uniform float d29;
uniform float d30;
uniform float d31;
uniform float d32;
uniform float d33;
uniform float d34;

uniform int Count;

void main()
{
    vec4 color = BaseColor;

    // Not a real loop
    while (true) {
        if (color.x < 0.33) {
            color += vec4(0.33);
            break;
        }
        if (color.x < 0.66) {
            color += vec4(0.66);
            break;
        }

        color += vec4(0.33);
        break;
    }

    // While
    while (color.x < d) {
        color += bigColor;
    }

    // While (latchy)
    while (color.z < d) {
        color += bigColor1_1;
        if (color.w < d)
            continue;

        color += bigColor1_1;
    }

    // While (constant)
    while (color.x < 42.0) {
        ++color;
    }

    // While (complicated-conditional)
    while (color.w < d2 && color.y < d3) {
        color += bigColor1_2;
    }

    // While (multi-exit)
    while (color.z < d3) {
        color += bigColor1_3;
        if (color.y < d4)
            break;
        color += bigColor1_3;
    }

    // For (dynamic)
    for (int i = 0; i < Count; ++i) {
        color += bigColor2;
    }

    // Do while
    do {
        color += bigColor3;
    } while (color.x < d2);

    // For (static)
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
    }

    // For (static) flow-control
    for (int i = 0; i < 100; ++i) {
        if (color.z < 20.0)
            color.x++;
        else
            color.y++;
        if (color.w < 20.0)
            if (color.z > color.y)
                0;              // do nothing
    }

    // For (static) flow-control with latch merge
    for (int i = 0; i < 120; ++i) {
        if (color.z < 20.0)
            color.x++;
        else
            color.y++;
    }

    // For (static) latchy
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
        if (color.x < d4)
            continue;
        ++color.w;
    }

    // For (static) multi-exit
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
        if (color.x < d4)
            break;
        ++color.w;
    }

    // Latchy
    do {
        color += bigColor4;
        if (color.x < d4)
            continue;
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    } while (color.z < d4);

    // Do while flow control
    do {
        color += bigColor5;
        if (color.y < d5)
            color.y += d5;
    } while (color.x < d5);

    // If then loop
    if (color.x < d6) {
        while (color.y < d6)
            color += bigColor6;
    } else {
        while (color.z < d6)
            color.z += bigColor6.z;
    }

    // If then multi-exit
    if (color.x < d6) {
        while (color.y < d6) {
            color += bigColor6;
            if (d7 < 1.0)
                break;
        }

    } else {
        while (color.z < d6)
            color.z += bigColor6.z;
    }
.
.
    // Multi-exit
    do {
       if (d7 < 0.0)
           break;

       color += bigColor7;

       if (d7 < 1.0) {
           color.z++;
           break;
       }

       color += BaseColor;

    } while (true);
.
.
    // Multi-exit2
    do {
        // invariant conditional break at the top of the loop. This could be a
        // situation where unswitching the loop has no real increases in code
        // size.
       if (d8 < 0.0)
           break;

       color += bigColor7;

       if (d8 < 1.0) {
           color.z++;
           if (d8 < 2.0) {
               color.y++;
           } else {
               color.x++;
           }
           break;
       }

       color += BaseColor;

    } while (color.z < d8);

    // Deep exit
    while (color.w < d9) {
        if (d9 > d8) {
            if (color.x <= d7) {
                if (color.z == 5.0)
                    color.w++;
                else
                    break;
            }
        }

    }

    // No end loop-back.
    while (color.z < d10) {
        color.y++;
        if (color.y < d11) {
            color.z++;
            if (color.w < d12)
                color.w++;
            else
                color.x++;
            continue;
        }

        color++;
        break;
    }

    // Multi-continue
    while (color.x < 10.0) {
        color += bigColor8;

        if (color.z < d8)
            if (color.w < d6)
                continue;

        color.y += bigColor8.x;
    }

    color++;
    gl_FragColor = color;

    // Early Return
    while (color.x < d14) {
        if (color.y < d15) {
            return;
        }
        else
            color++;
    }

    color++;

    while (color.w < d16) {
        color.w++;
    }
.
.
    // While (complicated-conditional)
    while (color.w < d2 && color.y < d3) {
        color += bigColor1_2;
        if (color.z < d3)
            return;
    }
.
.
    do {
        if (color.y < d18)
            return;
        color++;
    } while (color.x < d17);

    // Early Discard
    while (color.y < d16) {
        if (color.w < d16) {
            discard;
        } else
            color++;
    }

    color++;

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[loopsArtificial.frag]=[
#version 130
uniform vec4 bigColor;
uniform vec4 bigColor1_1;
uniform vec4 bigColor1_2;
uniform vec4 bigColor1_3;
uniform vec4 bigColor2;
uniform vec4 bigColor3;
uniform vec4 bigColor4;
uniform vec4 bigColor5;
uniform vec4 bigColor6;
uniform vec4 bigColor7;
uniform vec4 bigColor8;

varying vec4 BaseColor;

uniform float d;
uniform float d2;
uniform float d3;
uniform float d4;
uniform float d5;
uniform float d6;
uniform float d7;
uniform float d8;
uniform float d9;
uniform float d10;
uniform float d11;
uniform float d12;
uniform float d13;
uniform float d14;
uniform float d15;
uniform float d16;
uniform float d17;
uniform float d18;
uniform float d19;
uniform float d20;
uniform float d21;
uniform float d22;
uniform float d23;
uniform float d24;
uniform float d25;
uniform float d26;
uniform float d27;
uniform float d28;
uniform float d29;
uniform float d30;
uniform float d31;
uniform float d32;
uniform float d33;
uniform float d34;

uniform int Count;

void main()
{
    vec4 color = BaseColor;

    // Latchy2
    do {
        color += bigColor4;
        if (color.x < d4) {
            color.z += 2.0;
            if (color.z < d4) {
                color.x++;
                continue;
            }
        }
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    } while (color.z < d4);

    // Immediate dominator
    while (color.w < d13) {
        if (color.z < d13)
            color++;
        else
            color--;
        // code from Latchy 2
        color += bigColor4;
        if (color.x < d4) {
            color.z += 2.0;
            if (color.z < d4) {
                color.x++;
                continue;
            }
        }
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    }

    color++;
    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[mains.frag]=[
#version 300 es

void main()
{
}

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[mains1.frag]=[
#version 110

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[mains2.frag]=[
#version 110

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[matrix.frag]=[
#version 130

//#define TEST_POST_110

uniform mat3 colorTransform;
varying vec3 Color;
uniform mat4 m, n;

#ifdef TEST_POST_110
uniform mat4x3 um43;
uniform mat3x4 un34;
#else
uniform mat4 um43;
uniform mat4 un34;
#endif

varying vec4 v;

#ifdef TEST_POST_110
varying vec3 u;
#else
varying vec4 u;
#endif

void main()
{
    gl_FragColor = vec4(un34[1]);
    gl_FragColor += vec4(Color * colorTransform, 1.0);

    if (m != n)
        gl_FragColor += v;
   else {
        gl_FragColor += m * v;
        gl_FragColor += v * (m - n);
   }

#ifdef TEST_POST_110
    mat3x4 m34 = outerProduct(v, u);
    m34 += mat4(v.x);
    m34 += mat4(u, u.x, u, u.x, u, u.x, u.x);
#else
    mat4 m34 = mat4(v.x*u.x, v.x*u.y, v.x*u.z, v.x*u.w,
                    v.y*u.x, v.y*u.y, v.y*u.z, v.y*u.w,
                    v.z*u.x, v.z*u.y, v.z*u.z, v.z*u.w,
                    v.w*u.x, v.w*u.y, v.w*u.z, v.w*u.w);
    m34 += mat4(v.x);
    m34 += mat4(u, u.x, u, u.x, u, u.x, u.x);

#endif

    if (m34 == un34)
        gl_FragColor += m34 * u;
    else
        gl_FragColor += (un34 * um43) * v;

    mat4x2 m42 = mat4x2(42);
    if (m42 == mat4x2(42, 0, 0, 42, 0, 0, 0, 0)) {
        gl_FragColor += v;
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[matrix2.frag]=[
#version 150

uniform mat3 colorTransform;
varying vec3 Color;
uniform mat4 m, n;

uniform mat4x3 um43;
uniform mat3x4 un34;
uniform mat2 um2;
uniform mat3 um3;
uniform mat4 um4;

varying vec4 v;

varying vec3 u;

out vec4 FragColor;

void main()
{
    mat3x4 m34 = outerProduct(v, u);

    m34 += mat3x4(4.3);

    FragColor = vec4(Color, 1.0);
    FragColor *= vec4(FragColor * m34, 1.0);

    m34 *= v.x;

    mat4 m44 = mat4(un34);

    m44 += m34 * um43;

    FragColor += (-m44) * v;

    FragColor *= matrixCompMult(m44, m44);

    m34 = transpose(um43);
    FragColor *= vec4(FragColor * m34, 1.0);
    FragColor *= vec4(determinant(um4));
    mat2 inv = inverse(um2);
    FragColor *= vec4(inv[0][0], inv[1][0], inv[0][1], inv[1][1]);
    mat3 inv3 = inverse(um3);
    FragColor *= vec4(inv3[2][1]);

    mat4 inv4 = inverse(um4);
    FragColor *= inv4;

    FragColor = vec4(FragColor * matrixCompMult(un34, un34), FragColor.w);
    m34 *= colorTransform;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[matrixError.vert]=[
#version 120

attribute vec3 v3;

uniform mat3x2 m32;

const mat2x4 m24 = mat2x4(1.0, 2.0, 
                          3.0, 4.0,
                          3.0, 4.0,
                          3.0, 4.0, 5.0);          // ERROR, too many arguments

void main()
{
    mat2x3 m23;
    vec3 a, b;

    a = v3 * m23;      // ERROR, type mismatch
    b = m32 * v3;      // ERROR, type mismatch
    m23.xy;            // ERROR, can't use .

    gl_Position = vec4(m23 * m32 * v3, m24[2][4]);  // ERROR, 2 and 4 are out of range
    m23 *= m23;        // ERROR, right side needs to be square
    m23 *= m32;        // ERROR, left columns must match right rows
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[maxClipDistances.vert]=[
#version 130

out float gl_ClipDistance[8];	// OK, 8 is gl_MaxClipDistances

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[max_vertices_0.geom]=[
#version 330

layout(points) in;
layout(triangle_strip, max_vertices = 0) out;
in highp vec4 v_geom_FragColor[];
out highp vec4 v_frag_FragColor;

void main (void)
{
    EndPrimitive();
    EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[missingBodies.vert]=[
#version 450

void bar();
void foo() { bar(); }

void B();
void C(int);
void C(int, int) { }
void C(bool);
void A() { B(); C(1); C(true); C(1, 2); }

void main()
{
    foo();
    C(true);
}

int ret1();

int f1 = ret1();

int ret2() { return 3; }

int f2 = ret2();

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[negativeWorkGroupSize.comp]=[
#version 460

void fn(){
    uvec3 wgs = gl_WorkGroupSize; // error: fixed workgroup size has not been declared
}

layout(local_size_x = 64) in; // declare workgroup size

void main(){
    fn();
    uvec3 wgs = gl_WorkGroupSize; // valid
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[newTexture.frag]=[
#version 430

uniform samplerBuffer sb;
uniform sampler2DRect sr;
uniform sampler2D s2D;
uniform sampler3D s3D;
uniform samplerCube sCube;
uniform samplerCubeShadow sCubeShadow;
uniform sampler2DShadow s2DShadow;
uniform sampler2DArray s2DArray;
uniform sampler2DArrayShadow s2DArrayShadow;

uniform isampler2D is2D;
uniform isampler3D is3D;
uniform isamplerCube isCube;
uniform isampler2DArray is2DArray;
uniform isampler2DMS is2Dms;

uniform usampler2D us2D;
uniform usampler3D us3D;
uniform usamplerCube usCube;
uniform usampler2DArray us2DArray;

in float c1D;
in vec2  c2D;
in vec3  c3D;
in vec4  c4D;

flat in int   ic1D;
flat in ivec2 ic2D;
flat in ivec3 ic3D;
flat in ivec4 ic4D;

out vec4 FragData;

void main()
{
    vec4 v = texture(s2D, c2D);
    v += textureProj(s3D, c4D);
    v += textureLod(s2DArray, c3D, 1.2);
    v.y += textureOffset(s2DShadow, c3D, ivec2(3), c1D);
    v += texelFetch(s3D, ic3D, ic1D);
    v += texelFetchOffset(s2D, ic2D, 4, ivec2(3));
    v += texelFetchOffset(sr, ic2D, ivec2(4));
    v.y += textureLodOffset(s2DShadow, c3D, c1D, ivec2(3));
    v += textureProjLodOffset(s2D, c3D, c1D, ivec2(3));
    v += textureGrad(sCube, c3D, c3D, c3D);
    v.x += textureGradOffset(s2DArrayShadow, c4D, c2D, c2D, ivec2(3));
    v += textureProjGrad(s3D, c4D, c3D, c3D);
    v += textureProjGradOffset(s2D, c3D, c2D, c2D, ivec2(3));

    ivec4 iv = texture(is2D, c2D);
    v += vec4(iv);
    iv = textureProjOffset(is2D, c4D, ivec2(3));
    v += vec4(iv);
    iv = textureProjLod(is2D, c3D, c1D);
    v += vec4(iv);
    iv = textureProjGrad(is2D, c3D, c2D, c2D);
    v += vec4(iv);
    iv = texture(is3D, c3D, 4.2);
    v += vec4(iv);
    iv = textureLod(isCube, c3D, c1D);
    v += vec4(iv);
    iv = texelFetch(is2DArray, ic3D, ic1D);
    v += vec4(iv);
    iv += texelFetch(is2Dms, ic2D, ic1D);
    v += vec4(iv);
    v += texelFetch(sb, ic1D);
    v += texelFetch(sr, ic2D);

    ivec2 iv2 = textureSize(sCubeShadow, 2);
    // iv2 += textureSize(is2Dms);

    FragData = v + vec4(iv2, 0.0, 0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[noMain.vert]=[
#version 300 es

void foo()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[noMain1.geom]=[
#version 110

void foo()
{
}

layout(points) out;
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[noMain2.geom]=[
#version 150

void bar()
{
}

layout(line_strip) out;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[nonSquare.vert]=[
#version 120

attribute vec3 v3;
attribute vec4 v4;

uniform mat3x2 m32;

const vec2 cv2 = vec2(10.0, 20.0);
const mat2x4 m24 = mat2x4(3.0);
const mat4x2 m42 = mat4x2(1.0, 2.0, 
                          3.0, 4.0,
                          5.0, 6.0, 
                          7.0, 8.0);

void main()
{
    mat2x3 m23;
    vec2 a, b;

    a = v3 * m23;
    b = m32 * v3;

    gl_Position = vec4(m23 * m32 * v3, m24[1][3]) + 
                  (m24 * m42) * v4 + cv2 * m42 + m24 * cv2 + vec4(cv2[1], cv2.x, m42[2][1], m42[2][0]);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[nonVulkan.frag]=[
#version 450

layout(constant_id = 17) const int arraySize = 12;            // ERROR
layout(input_attachment_index = 1) int foo;                   // ERROR
layout(push_constant) uniform ubn { int a; } ubi;             // ERROR

#ifdef VULKAN
#error VULKAN should not be defined
#endif

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[nonuniform.frag]=[
#version 450

int nonuniformEXT;

#extension GL_EXT_nonuniform_qualifier : enable

nonuniformEXT in vec4 nu_inv4;
nonuniformEXT float nu_gf;

nonuniformEXT out vec4 nu_outv4;           // ERROR, out
nonuniformEXT uniform vec4 nu_uv4;         // ERROR, uniform
nonuniformEXT const float nu_constf = 1.0; // ERROR, const

nonuniformEXT int foo(nonuniformEXT int nupi, nonuniformEXT out int f)
{
    return nupi;
}

void main()
{
    nonuniformEXT int nu_li;
    nonuniformEXT const int nu_ci = 2; // ERROR, const

    foo(nu_li, nu_li);
    int table[5];
    int a;
    nu_li = nonuniformEXT(a) + nonuniformEXT(a * 2);
    nu_li = nonuniformEXT(a, a);       // ERROR, too many arguments
    nu_li = nonuniformEXT();           // ERROR, no arguments
    nu_li = table[nonuniformEXT(3)];
}
layout(location=1) in struct S { float a; nonuniformEXT float b; } ins;  // ERROR, not on member
layout(location=3) in inbName { float a; nonuniformEXT float b; } inb;   // ERROR, not on member

<><><><><><><><><><><><><><><><><><><><><><><><><>
7:14; [@24,103:104='in',<'in'>,7:14]; no viable alternative at input 'nonuniformEXT in'; NoViableAltException:null
8:14; [@33,135:139='float',<FLOAT32>,8:14]; no viable alternative at input 'nonuniformEXT float'; NoViableAltException:null
10:14; [@41,165:167='out',<'out'>,10:14]; no viable alternative at input 'nonuniformEXT out'; NoViableAltException:null
11:14; [@51,223:229='uniform',<'uniform'>,11:14]; no viable alternative at input 'nonuniformEXT uniform'; NoViableAltException:null
12:14; [@61,285:289='const',<'const'>,12:14]; no viable alternative at input 'nonuniformEXT const'; NoViableAltException:null
14:14; [@76,347:349='int',<INT32>,14:14]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
14:60; [@89,393:395='out',<'out'>,14:60]; missing ';' at 'out'; <no exception>
17:0; [@104,426:426='}',<'}'>,17:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
21:18; [@118,465:467='int',<INT32>,21:18]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
22:18; [@126,495:499='const',<'const'>,22:18]; no viable alternative at input 'nonuniformEXT const'; NoViableAltException:null
32:56; [@250,873:877='float',<FLOAT32>,32:56]; no viable alternative at input 'layout(location=1) in struct S { float a; nonuniformEXT float'; NoViableAltException:null
32:56; [@250,873:877='float',<FLOAT32>,32:56]; no viable alternative at input 'nonuniformEXT float'; NoViableAltException:null
32:65; [@255,882:882='}',<'}'>,32:65]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
33:55; [@281,970:974='float',<FLOAT32>,33:55]; extraneous input 'float' expecting IDENTIFIER; <no exception>
]


testGlslangErrors[nosuffix]=[
void main()
{
    gl_Position = vec4(1.0);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[numeral.frag]=[
#version 400

void main()
{
    int o00 = 00;
    int o000 = 000;
    int o0000 = 0000;
    int o5 = 05;
    int o05 = 005;
    int o006 = 0006;
    int o7 = 07;
    int o58 = 072;
    int omax = 037777777777;
    int o8 = 08;                      // ERROR
    int o08 = 008;                    // ERROR
    int o009 = 0009;                  // ERROR
    int obig = 07324327323472347234;  // ERROR
    int omax1 = 040000000000;         // ERROR

    uint uo5 = 05u;
    uint uo6 = 06u;
    uint uo7 = 07u;
    uint uo8 = 08u;                   // ERROR
    uint uo9 = 09u;                   // ERROR

    int h0 = 0x0;
    int h00 = 0x00;
    int h000 = 0x000;
    int h1 = 0x1;
    int h2 = 0x00000002;
    int h300 = 0x000300;
    int hABCDEF = 0xAbCdEF;
    int hFFFFFFFF = 0xFFFFFFFF;
    int h12345678 = 0xBC614E;
    int hToBeOrNotToBe = 0x2b | ~0x2B;

    uint uh0 = 0x0u;
    uint uhg = (0xcu);
    uint uh000 = 0x000u;
    uint uh1 = 0x1u;
    uint uh2 = 0x00000002u;
    uint uh300 = 0x000300u;
    uint uhABCDEF = 0xAbCdEFu;
    uint uhFFFFFFFF = 0xFFFFFFFFu;
    uint uh12345678 = 0xBC614Eu;
    uint uhToBeOrNotToBe = 0x2bu | ~0x2BU;

    //int he1 = 0xG;                     // ERROR
    int he2 = 0x;                      // ERROR
    int hbig = 0xFFFFFFFF1;            // ERROR

    float f1 = 1.0;
    float f2 = 2.;
    float f3 = 3e0;
    float f4 = 40e-1;
    float f5 = 05.;
    float f6 = 006.;
    float f7 = .7e1;
    float f8 = 08e0;
    float f9 = .9e+1;
    float f10 = 10.0;
    float f11 = .011e+3;
    float f12 = .0012e4;
    float f543 = 000000543.;
    float f6789 = 00006789.;
    float f88 = 0000088.;

    float g1 = 5.3876e4;
    float g2 = 4000000000e-11;
    float g3 = 1e+5;
    float g4 = 7.321E-3;
    float g5 = 3.2E+4;
    float g6 = 0.5e-5;
    float g7 = 0.45;
    float g8 = 6.e10;

    double gf1 = 1.0lf;
    double gf2 = 2.Lf;
    double gf3 = .3e1lF;
    double gf4 = .4e1LF;
    float gf5 = 5.f;
    float gf6 = 6.F;

    //float e1 = 1..;        // ERROR
    //float e2 = 2.l;        // ERROR
    //float e3 = ..3;        // ERROR
    //float e4 = 4ee1;       // ERROR
    float e5 = 5f;         // ERROR
}

layout (location = 2) out vec4 c2;
layout (location = 3u) out vec4 c3;
layout (location = 04) out vec4 c4;
layout (location = 005u) out vec4 c5;
layout (location = 0x6) out vec4 c6;
layout (location = 0x7u) out vec4 c7;

uint g1 = 4294967296u; // ERROR, too big
uint g2 = 4294967295u;
uint g3 = 4294967294u;
int g4 = 4294967296;   // ERROR, too big
int g5 = 4294967295;
int g6 = 4294967294;
float inf1 = -1.#INF;
float inf2 =  1.#INF;
float inf3 = +1.#INF;

<><><><><><><><><><><><><><><><><><><><><><><><><>
23:17; [@198,545:545='u',<IDENTIFIER>,23:17]; extraneous input 'u' expecting ';'; <no exception>
24:17; [@210,593:593='u',<IDENTIFIER>,24:17]; extraneous input 'u' expecting ';'; <no exception>
49:15; [@439,1261:1261='x',<IDENTIFIER>,49:15]; extraneous input 'x' expecting ';'; <no exception>
104:16; [@937,2671:2671='#',<'#'>,104:16]; missing ';' at '#'; <no exception>
104:20; <no symbol>; token recognition error at: ';'; LexerNoViableAltException:null
105:16; [@947,2694:2694='#',<'#'>,105:16]; missing ';' at '#'; <no exception>
105:20; <no symbol>; token recognition error at: ';'; LexerNoViableAltException:null
106:16; [@958,2717:2717='#',<'#'>,106:16]; missing ';' at '#'; <no exception>
106:20; <no symbol>; token recognition error at: ';'; LexerNoViableAltException:null
]


testGlslangErrors[nvShaderNoperspectiveInterpolation.frag]=[
#version 300 es

precision mediump float;

noperspective in vec4 bad; // ERROR

#extension GL_NV_shader_noperspective_interpolation : enable

noperspective in vec4 color;

out vec4 fragColor;

void main() {
    fragColor = color;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[overlongLiteral.frag]=[
0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;

<><><><><><><><><><><><><><><><><><><><><><><><><>
1:0; [@0,0:1024='0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',<INT32CONSTANT>,1:0]; extraneous input '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[parentBad]=[
int a;

#error bad parent

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[pointCoord.frag]=[
precision highp float;

uniform sampler2D sampler;

void main()
{
    vec4 color;

    if (length(gl_PointCoord) < 0.3)
        color = texture2D(sampler, gl_PointCoord);
    else
        color = vec4(0.0);

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[precise.tesc]=[
#version 450
#extension GL_EXT_tessellation_shader : require
#extension GL_EXT_gpu_shader5 : require

float minimal() {
  precise float result = 5.0;
  float a = 10.0;
  float b = 20.0;
  float c = 30.0;
  float d = 40.0;
  result = a * b + c * d; //  c * d, a * b and rvalue1 + rvalue2 should be 'noContraction'.
  return result;
}

void continuous_assignment() {
  precise float result = 5.0;
  float a = 10.0;
  float b = 20.0;
  result = a = b + 4; // b + 4 should be 'noContraction'.
}

void convert() {
  precise double result;
  float a = 10.0;
  float b = 20.0;
  b = a + b; //  a + b should be 'noContraction'.
  result  = double(b); // convert operation should not be 'noContraction'.
}

float loop_for() {
  precise float r1 = 5.0;
  precise float r2 = 10.0;
  int a = 10;
  int b = 20;
  int c = 30;
  for (int i = 0; i < a; i++) {
    r1 += 3.12 + b + i; // 'noContration', this make i++ also 'noContraction'
    c += 1; // 'noContration'
  }
  a += 1; // a + 1 should not be 'noContraction'.
  r2 = c; // The calculation of c should be 'noContration'.
  return float(r1 + r2); // conversion should not be 'noContration'.
}

void loop_array(void) {
  precise float result;

  int x = 22;
  int y = 33;

  float a0[3];
  result += float(x) + float(y); // x + y should be 'noContraction' also result + rvalue.

  for (int i = 0; i < 3; ++i) {
    // a's dereference + 2 should be 'noContraction'.
    result += a0[i] + 2;
    // result + 1 and 3 - rvalue should be 'noContraction'.
    a0[i] = 3 - result++;
  }
}

void loop_while() {
  precise float result = 5.0;
  int a = 10;
  int b = 20;
  while (result < 10) {
    result += 3.12 + b; // result + 3.12 should be 'noContraction'.
  }
  result = a + b + 5; // b + 5 should not be 'noCtraction' because all operands are integers.
  result = 11.1;
}

float fma_not_decorated() {
    precise float result;
    float a = 1.0;
    float b = 2.0;
    float c = 3.0;
    b = b + c; // b + c should be decorated with 'noContraction'
    result = fma(a, b, c); // fma() should not be decorated with 'noContradtion'
    return result;
}

precise float precise_return_exp_func() {
  float a = 1.0;
  float b = 2.0;
  return a + b; // the ADD operation should be 'noContraction'
}

precise float precise_return_val_func() {
  float a = 1.0;
  float b = 2.0;
  float result = a + b; // the ADD operation should be 'noContraction'
  return result;
}

float precise_func_parameter(float b, precise out float c) {
  float a = 0.5;
  c = a + b; // noContration
  return a - b; // Not noContraction
}

mat3 matrix (mat2x3 a, mat3x2 b) {
  mat2x3 c = mat2x3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
  precise mat3 result;
  result = (a + c) * b; // should be noContraction
  return result;
}

void main(){}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[precise_struct_block.vert]=[
#version 450

struct T {
  float f1;
  float f2;
};

out B1 {precise T s; float x;} partial_precise_block;
precise out B2 {T s; float x;} all_precise_block;

float struct_member() {
  float a = 1.0;
  float b = 2.0;
  float c = 3.0;
  float d = 4.0;

  precise float result;

  T S, S2, S3;

  S2.f1 = a + 0.2;      // NoContraction
  S2.f2 = b + 0.2;      // NOT NoContraction
  S3.f1 = a + b;        // NOT NoContraction
  S = S2;               // "precise" propagated through parent object nodes
  result = S.f1 + 0.1;  // the ADD operation should be NoContraction

  return result;
}

float complex_array_struct() {
  precise float result;
  struct T1 {
    float t1_array[3];
    float t1_scalar;
  };
  struct T2 {
    T1 t1a[5];
    T1 t1b[6];
    T1 t1c[7];
  };
  struct T3 {float f; T2 t2; vec4 v; int p;};
  T3 t3[10];
  for(int i=0; i<10; i++) {
    t3[i].f = i / 3.0; // Not NoContraction
    t3[i].v = vec4(i * 1.5); // NoContraction
    t3[i].p = i + 1;
    for(int j=0; j<5; j++) {
      for(int k = 0; k<3; k++) {
        t3[i].t2.t1a[j].t1_array[k] = i * j + k; // Not NoContraction
      }
      t3[i].t2.t1a[j].t1_scalar = j * 2.0 / i; // Not NoContration
    }

    for(int j=0; j<6; j++) {
      for(int k = 0; k<3; k++) {
        t3[i].t2.t1b[j].t1_array[k] = i * j + k; // Not NoContraction
      }
      t3[i].t2.t1b[j].t1_scalar = j * 2.0 / i; // NoContraction
    }

    for(int j=0; j<6; j++) {
      for(int k = 0; k<3; k++) {
        t3[i].t2.t1c[j].t1_array[k] = i * j + k; // Not NoContraction because all operands are integers
      }
      t3[i].t2.t1c[j].t1_scalar = j * 2.0 / i; // Not NoContraction
    }
  }
  int i = 2;
  result = t3[5].t2.t1c[6].t1_array[1]
           + t3[2].t2.t1b[1].t1_scalar
           + t3[i - 1].v.xy.x; // NoContraction
  return result;
}

float out_block() {
    float a = 0.1;
    float b = 0.2;
    partial_precise_block.s.f1 = a + b; // NoContraction
    partial_precise_block.s.f2 = a - b; // NoContraction
    partial_precise_block.x = a * b; // Not NoContraction

    all_precise_block.s.f1 = a + b + 1.0; // NoContraction
    all_precise_block.s.f2 = a - b - 1.0; // NoContraction
    all_precise_block.x = a * b * 2.0; // Also NoContraction

    return a + b; // Not NoContraction
}

void main(){}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[precision.frag]=[
#version 100

varying vec3 color;       // ERRROR, there is no default qualifier for float

lowp vec2 foo(mediump vec3 mv3)
{
    highp vec4 hv4;
    return hv4.xy;
}

int global_medium;

uniform lowp sampler2D samplerLow;
uniform mediump sampler2D samplerMed;
uniform highp sampler2D samplerHigh;

precision highp int; 
precision highp ivec2;     // ERROR
precision mediump int[2];  // ERROR
vec4 uint;                 // okay
precision mediump vec4;    // ERROR

int global_high;

void main()
{
    lowp int sum = global_medium + global_high;

    gl_FragColor = vec4(color, 1.0);

    int level1_high;
    sum += level1_high;

    precision lowp int;
    int level1_low;
    sum += level1_low;
    
    // test maxing precisions of args to get precision of builtin
    lowp float arg1;
    mediump float arg2;
    lowp float d = distance(arg1, arg2);

    {
        int level2_low;
        sum += level2_low;
        
        precision highp int;
        int level2_high;
        sum += level2_high;
        do {
            if (true) {
                precision mediump int;
                int level4_medium;
                sum += level4_medium;
            }
            int level3_high;
            sum += level3_high;
        } while (true);	
        int level2_high2;
        sum += level2_high2;
    }
    int level1_low3;
    sum += level1_low3;

    sum += 4 + ((ivec2(level1_low3) * ivec2(level1_high) + ivec2((/* comma operator */level1_low3, level1_high)))).x;
    
    texture2D(samplerLow, vec2(0.1, 0.2));
    texture2D(samplerMed, vec2(0.1, 0.2));
    texture2D(samplerHigh, vec2(0.1, 0.2));
}

precision mediump bool;                 // ERROR
//precision mediump struct { int a; } s;  // ERROR
struct s {int a;};
precision mediump s;                    // ERROR
mediump bvec2 b2;                       // ERROR

<><><><><><><><><><><><><><><><><><><><><><><><><>
20:5; [@112,417:420='uint',<UINT32>,20:5]; no viable alternative at input 'vec4 uint'; NoViableAltException:null
]


testGlslangErrors[precision.vert]=[
#version 300 es

in vec4 pos;

uniform sampler2D s2D;
uniform samplerCube sCube;
uniform isampler2DArray is2DAbad;      // ERROR, no default precision
uniform sampler2DArrayShadow s2dASbad; // ERROR, no default precision

precision highp sampler2D;
precision mediump sampler2DArrayShadow;

uniform sampler2DArrayShadow s2dAS;
uniform isampler2DArray is2DAbad2;     // ERROR, still no default precision

uniform sampler2D s2Dhigh;

void main()
{
    vec4 t = texture(s2D, vec2(0.1, 0.2));
    t += texture(s2Dhigh, vec2(0.1, 0.2));
    t += texture(s2dAS, vec4(0.5));

    gl_Position = pos;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[prepost.frag]=[
#version 140

void main()
{
    struct s {
        float y[5];
    } str;

    float t;
    int index = 5;  // all indexing is 4

    str.y[4] = 2.0;             // 2.0
    t = ++str.y[--index];       // 3.0
    str.y[4] += t;              // 6.0
    t = str.y[4]--;             // 5.0 (t = 6.0)
    str.y[index++] += t;        // 11.0
    --str.y[--index];           // 10.0

    float x = str.y[4];
	++x;
	--x;
	x++;
	x--;

	// x is 10.0

	float y = x * ++x;  // 10 * 11
	float z = y * x--;  // 110 * 11

    // x is 10.0
    // z is 1210.0

    vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
    v.y = v.z--;  // (1,3,2,4)
    v.x = --v.w;  // (3,3,2,3)

    gl_FragColor = z * v;// (3630.0, 3630.0, 2420.0, 3630.0)
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[recurse1.frag]=[
#version 330 core

// cross-unit recursion

void main() {}

// two-level recursion

float cbar(int);

void cfoo(float)
{
	cbar(2);
}

// four-level, out of order

void CB();
void CD();
void CA() { CB(); }
void CC() { CD(); }

// high degree

void CBT();
void CDT();
void CAT() { CBT(); CBT(); CBT(); }
void CCT() { CDT(); CDT(); CBT(); }

// not recursive

void norA() {}
void norB() { norA(); }
void norC() { norA(); }
void norD() { norA(); }
void norE() { norB(); }
void norF() { norB(); }
void norG() { norE(); }
void norH() { norE(); }
void norI() { norE(); }

// not recursive, but with a call leading into a cycle if ignoring direction

void norcA() { }
void norcB() { norcA(); }
void norcC() { norcB(); }
void norcD() { norcC(); norcB(); } // head of cycle
void norcE() { norcD(); } // lead into cycle

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[recurse1.vert]=[
#version 330 core

void main() {}

float bar(int);

// direct recursion

void self()
{
    self();
}

// two-level recursion

void foo(float)
{
	bar(2);
}

float bar(int)
{
	foo(4.2);

	return 3.2;
}

// four-level, out of order

void B();
void D();
void A() { B(); }
void C() { D(); }
void B() { C(); }
void D() { A(); }

// high degree

void BT();
void DT();
void AT() { BT(); BT(); BT(); }
void CT() { DT(); AT(); DT(); BT(); }
void BT() { CT(); CT(); CT(); }
void DT() { AT(); }

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[recurse2.frag]=[
#version 330 core

// cross-unit recursion

// two-level recursion

void cfoo(float);

float cbar(int)
{
	cfoo(4.2);

	return 3.2;
}

// four-level, out of order

void CA();
void CC();
void CB() { CC(); }
void CD() { CA(); }

// high degree

void CAT();
void CCT();
void CBT() { CCT(); CCT(); CCT(); }
void CDT() { CAT(); }

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.frag]=[
#version 440 core

in float inval;

void main()
{
    float f = inval;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.linked.frag]=[
#version 440 core

layout(binding = 0, std140) uniform ubo_block {
	float unused_uniform;
	float shared_uniform;
	float vsonly_uniform;
	float fsonly_uniform;
} ubo;

in float vertout;

out float fragout;

void main()
{
    fragout = vertout;
    fragout += ubo.shared_uniform;
    fragout += ubo.fsonly_uniform;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.linked.vert]=[
#version 440 core

layout(binding = 0, std140) uniform ubo_block {
	float unused_uniform;
	float shared_uniform;
	float vsonly_uniform;
	float fsonly_uniform;
} ubo;

in float vertin;

out float vertout;

void main()
{
    vertout = vertin;
    vertout += ubo.shared_uniform;
    vertout += ubo.vsonly_uniform;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.options.geom]=[
#version 330 core

precision highp float;

layout(triangles) in;
layout(triangle_strip, max_vertices = 4) out;

in block
{
    vec2 Color;
    vec2 Texcoord;
    flat ivec3 in_a;
} In[];

out block
{
    vec4 Color;
    vec4 a;
    vec2 b[3];
} Out;

void main()
{
    for(int i = 0; i < gl_in.length(); ++i)
    {
        gl_Position = gl_in[i].gl_Position;
        Out.Color = vec4(In[i].Color, 0, 1);
        EmitVertex();
    }
    EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.options.vert]=[
#version 440 core

struct VertexInfo {
    float position[3];
    float normal[3];
};

struct TriangleInfo {
    VertexInfo v[3];
};

buffer VertexCollection {
    TriangleInfo t[5];
    uint padding[10];
};

buffer MultipleArrays {
    TriangleInfo tri[5];
    VertexInfo vert[5];
    float f[5];
} multiarray;

buffer ArrayedBind {
    float a;
    float b;
} buffers[3];

uniform UBO {
    VertexInfo verts[2];
    float flt[8];
    uvec4 unused;
    float uniform_multi[4][3][2];
} ubo;

uniform float uniform_multi[4][3][2];

struct OutputStruct {
    float val;
    vec3 a;
    vec2 b[4];
    mat2x2 c;
};

out OutputStruct outval;
out float outarr[3];

void main()
{
    float f;
    f += t[0].v[0].position[0];
    f += t[gl_InstanceID].v[gl_InstanceID].position[gl_InstanceID];
    f += t[gl_InstanceID].v[gl_InstanceID].normal[gl_InstanceID];
    f += multiarray.tri[gl_InstanceID].v[0].position[0];
    f += multiarray.vert[gl_InstanceID].position[0];
    f += multiarray.f[gl_InstanceID];
    f += ubo.verts[gl_InstanceID].position[0];
    f += ubo.flt[gl_InstanceID];
    f += ubo.uniform_multi[0][0][0];
    f += uniform_multi[gl_InstanceID][gl_InstanceID][gl_InstanceID];
    f += buffers[gl_InstanceID].b;
    TriangleInfo tlocal[5] = t;
    outval.val = f;
    outarr[2] = f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[reflection.vert]=[
#version 440 core

layout(std140, row_major) uniform nameless {
    vec3 anonMember1;
    mat3x2 m23;
    int scalarAfterm23;
    vec4 anonDeadMember2;
    vec4 anonMember3;
    int scalarBeforeArray;
    float floatArray[5];
    int scalarAfterArray;
    mat2x2 m22[9];
};

layout(std140, column_major) uniform c_nameless {
    vec3 c_anonMember1;
    mat3x2 c_m23;
    int c_scalarAfterm23;
    vec4 c_anonDeadMember2;
    vec4 c_anonMember3;
};

layout(std140) uniform named {
    vec3 deadMember1;
    int scalar;
    vec4 member2;
    vec4 member3;
    vec2 memvec2;
    float memf1;
    bool  memf2;
    int   memf3;
    vec2 memvec2a;
    mat2x2 m22[7];
} ablock;

layout(std140) uniform namelessdead {
    int a;
};

layout(std140) uniform namedDead {
    int b;
} bblock;

struct N1 {
    float a;
};

struct N2 {
    float b;
    float c;
    float d;
};

struct N3 {
    N1 n1;
    N2 n2;
};

layout(std140) uniform nested {
    N3 foo;
} nest;

layout(std140) uniform nested2 {
    vec4 padding; // offset 0, size 16
    N3 a;       // offset 16, size 32
    N1 b[4];    // offset 48, size 64
    N1 c[2];    // offset 112, size 32
    N1 d[4];    // offset 144, size 64
} nest2;

struct TS {
    int a;
    int dead;
};

uniform TS s;

uniform float uf1;
uniform float uf2;
uniform float ufDead3;
uniform float ufDead4;

uniform writeonly uimage2D image_ui2D;
uniform sampler2D sampler_2D;
uniform sampler2DMSArray sampler_2DMSArray;

uniform mat2 dm22[10];

struct deep1 {
    vec2 va[3];
    bool b;
};

struct deep2 {
    int i;
    deep1 d1[4];
};

struct deep3 {
    vec4 iv4;
    deep2 d2;
    ivec3 v3;
};

in float attributeFloat;
layout(location = 2) in vec2 attributeFloat2;
in vec3 attributeFloat3;
in vec4 attributeFloat4;
in mat4 attributeMat4;
in float attributeFloatArray[3];

uniform deep3 deepA[2], deepB[2], deepC[3], deepD[2];

const bool control = true;

void deadFunction()
{
    vec3 v3 = ablock.deadMember1;
    vec4 v = anonDeadMember2;
    float f = ufDead4;
}

void liveFunction2()
{
    vec3 v = anonMember1;
    float f = uf1;
}

void liveFunction1(writeonly uimage2D p_ui2D, sampler2D p_2D, sampler2DMSArray p_2DMSArray)

{
    liveFunction2();
    float f = uf2;
    vec4 v = ablock.member3;
}

uniform abl {
    float foo;
} arrBl[4];

uniform abl2 {
    float foo;
} arrBl2[4];

buffer buf1 {
    float scalar;
    float runtimeArray[];
} buf1i;

buffer buf2 {
    float scalar;
    N2 runtimeArray[];
} buf2i;

buffer buf3 {
    float scalar;
    float runtimeArray[];
} buf3i;

buffer buf4 {
    float scalar;
    N2 runtimeArray[];
} buf4i;

struct VertexInfo {
    float position[3];
    float normal[3];
};

struct TriangleInfo {
    VertexInfo v[3];
};

buffer VertexCollection {
    TriangleInfo t[5];
    uint padding[10];
};

out float outval;

void main()
{
    liveFunction1(image_ui2D, sampler_2D, sampler_2DMSArray);
    liveFunction2();

    if (! control)
        deadFunction();

    float f;
    int i;
    if (control) {
        liveFunction2();
        f = anonMember3.z;
        f = s.a;
        f = ablock.scalar;
        f = m23[1].y + scalarAfterm23;
        f = c_m23[1].y + c_scalarAfterm23;
        f += scalarBeforeArray;
        f += floatArray[2];
        f += floatArray[4];
        f += scalarAfterArray;
        f += ablock.memvec2.x;
        f += ablock.memf1;
        f += float(ablock.memf2);
        f += ablock.memf3;
        f += ablock.memvec2a.y;
        f += ablock.m22[i][1][0];
        f += dm22[3][0][1];
        f += m22[2][1].y;
        f += nest.foo.n1.a + nest.foo.n2.b + nest.foo.n2.c + nest.foo.n2.d;
        f += deepA[i].d2.d1[2].va[1].x;
        f += deepB[1].d2.d1[i].va[1].x;
        f += deepB[i].d2.d1[i].va[1].x;
        deep3 d = deepC[1];
        deep3 da[2] = deepD;
        deep1 db = deepA[i].d2.d1[i];
    } else
        f = ufDead3;

    f += arrBl[2].foo + arrBl[0].foo;
    f += arrBl2[i].foo;

    f += attributeFloat;
    f += attributeFloat2.x;
    f += attributeFloat3.x;
    f += attributeFloat4.x;
    f += attributeMat4[0][1];
    f += attributeFloatArray[2];
    f += buf1i.runtimeArray[3];
    f += buf2i.runtimeArray[3].c;
    f += buf3i.runtimeArray[gl_InstanceID];
    f += buf4i.runtimeArray[gl_InstanceID].c;

    N3 n = nest2.a;
    N1 b[4] = nest2.b;
    f += nest2.c[1].a;
    f += nest2.d[gl_InstanceID].a;

    f += t[0].v[0].position[0];
    f += t[gl_InstanceID].v[gl_InstanceID].position[gl_InstanceID];
    f += t[gl_InstanceID].v[gl_InstanceID].normal[gl_InstanceID];
    TriangleInfo tlocal[5] = t;

    outval = f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.basic.dcefunc.frag]=[
#version 450

in float  inf;
out vec4  outf4;

vec3 dead_fn() { return vec3(0); }

void main()
{
    outf4 = vec4(inf);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.basic.everything.frag]=[
#version 450

in float  inf;
out vec4  outf4;

vec3 dead_fn() { return vec3(0); }

void main()
{
    outf4 = vec4(inf);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.basic.none.frag]=[
#version 450

in float  inf;
out vec4  outf4;

vec3 dead_fn() { return vec3(0); }

void main()
{
    outf4 = vec4(inf);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.basic.strip.frag]=[
#version 450

in float  inf;
out vec4  outf4;

vec3 dead_fn() { return vec3(0); }

void main()
{
    outf4 = vec4(inf);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.if.everything.frag]=[
#version 450

in float  inf;
out vec4  outf4;

void main()
{
    if (inf > 2.0)
        outf4 = vec4(inf);
    else
        outf4 = vec4(inf + -.5);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.if.none.frag]=[
#version 450

in float  inf;
out vec4  outf4;

void main()
{
    if (inf > 2.0)
        outf4 = vec4(inf);
    else
        outf4 = vec4(inf + -.5);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.similar_1a.everything.frag]=[
#version 450

in float  inf;
in flat ivec4  ini4;
out vec4  outf4;

float Test1(int bound)
{
    float r = 0;
    for (int x=0; x<bound; ++x)
        r += 0.5;
    return r;
}

float Test2(int bound)
{
    if (bound > 2)
        return Test1(bound);
    else
        return float(bound * 2 +
                     ini4.y * ini4.z +
                     ini4.x);
}

void main()
{
    outf4 = vec4(Test1(int(inf)) + 
                 Test2(int(inf)));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.similar_1a.none.frag]=[
#version 450

in float  inf;
in flat ivec4  ini4;
out vec4  outf4;

float Test1(int bound)
{
    float r = 0;
    for (int x=0; x<bound; ++x)
        r += 0.5;
    return r;
}

float Test2(int bound)
{
    if (bound > 2)
        return Test1(bound);
    else
        return float(bound * 2 +
                     ini4.y * ini4.z +
                     ini4.x);
}

void main()
{
    outf4 = vec4(Test1(int(inf)) + 
                 Test2(int(inf)));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.similar_1b.everything.frag]=[
#version 450

out vec4  outf4;
in flat ivec4  ini4;
in float  inf;

float Test1(int bound)
{
    float r = 0;
    for (int x=0; x<bound; ++x)
        r += 0.5;
    r += 0.2;
    return r;
}

float Test2(int bound)
{
    if (bound > 2) {
        return Test1(bound * 2);
    } else
        return float(bound * 4 +
                     ini4.y * ini4.z +
                     ini4.x);
}

void main()
{
    outf4 = vec4(Test1(int(inf)) + 
                 Test2(int(inf)));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.similar_1b.none.frag]=[
#version 450

out vec4  outf4;
in flat ivec4  ini4;
in float  inf;

float Test1(int bound)
{
    float r = 0;
    for (int x=0; x<bound; ++x)
        r += 0.5;
    r += 0.2;
    return r;
}

float Test2(int bound)
{
    if (bound > 2) {
        return Test1(bound * 2);
    } else
        return float(bound * 4 +
                     ini4.y * ini4.z +
                     ini4.x);
}

void main()
{
    outf4 = vec4(Test1(int(inf)) + 
                 Test2(int(inf)));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.specconst.comp]=[
#version 450

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

shared int foo[gl_WorkGroupSize.x + gl_WorkGroupSize.y * gl_WorkGroupSize.z];

void main () {}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.switch.everything.frag]=[
#version 450

precision highp float;

layout(location = 0) out mediump vec4 FragColor;
layout(location = 0) in vec4 in0;

void main()
{
    switch(int(in0.w)) {
    case 0: FragColor = vec4(in0.x + 0); break;
    case 1: FragColor = vec4(in0.y + 1); break;
    case 2: FragColor = vec4(in0.z + 2); break;
    default: FragColor = vec4(-1);
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[remap.switch.none.frag]=[
#version 450

precision highp float;

layout(location = 0) out mediump vec4 FragColor;
layout(location = 0) in vec4 in0;

void main()
{
    switch(int(in0.w)) {
    case 0: FragColor = vec4(in0.x + 0); break;
    case 1: FragColor = vec4(in0.y + 1); break;
    case 2: FragColor = vec4(in0.z + 2); break;
    default: FragColor = vec4(-1);
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[sample.frag]=[
//
//Copyright (C) 2002-2004  3Dlabs Inc. Ltd.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of 3Dlabs Inc. Ltd. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 110

varying vec3 color;

void main()
{
    gl_FragColor = vec4(color, 1.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[sample.vert]=[
//
//Copyright (C) 2002-2004  3Dlabs Inc. Ltd.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of 3Dlabs Inc. Ltd. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 110

varying vec3 color;

void main()
{
    color = vec3(1.0, 1.0, 1.0);

    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[samplerlessTextureFunctions.frag]=[
#version 450 core

layout(binding = 1) uniform texture2D tex2D;
layout(binding = 1) uniform texture2DMS texMS;
layout(binding = 0) uniform textureBuffer buf;

void testBad()
{
    vec4 tex2DFetch = texelFetch(tex2D, ivec2(0, 0), 0);
    vec4 texMSFetch = texelFetch(texMS, ivec2(0, 0), 0);

    // Allowed by KHR_vulkan_glsl without the extension. All others should
    // error.
    vec4 bufFetch = texelFetch(buf, 0);

    vec4 tex2DFetchOffset = texelFetchOffset(tex2D, ivec2(0, 0), 0, ivec2(0, 0));

    ivec2 tex2DSize = textureSize(tex2D, 0);
    ivec2 texMSSize = textureSize(texMS);
    int bufSize = textureSize(buf);

    int tex2DLevels = textureQueryLevels(tex2D);

    int texMSSamples = textureSamples(texMS);
}

#extension GL_EXT_samplerless_texture_functions : enable

void main()
{
    // These should all succeed.

    vec4 tex2DFetch = texelFetch(tex2D, ivec2(0, 0), 0);
    vec4 texMSFetch = texelFetch(texMS, ivec2(0, 0), 0);
    vec4 bufFetch = texelFetch(buf, 0);

    vec4 tex2DFetchOffset = texelFetchOffset(tex2D, ivec2(0, 0), 0, ivec2(0, 0));

    ivec2 tex2DSize = textureSize(tex2D, 0);
    ivec2 texMSSize = textureSize(texMS);
    int bufSize = textureSize(buf);

    int tex2DLevels = textureQueryLevels(tex2D);

    int texMSSamples = textureSamples(texMS);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[simpleFunctionCall.frag]=[
#version 150

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

vec4 foo()
{
    return BaseColor;
}

void main()
{
    gl_FragColor = foo();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[specExamples.frag]=[
<invalid content>
]


testGlslangErrors[specExamples.vert]=[
<invalid content>
]


testGlslangErrors[spv.1.3.8bitstorage-ssbo.vert]=[
#version 450

#extension GL_EXT_shader_8bit_storage: require

layout(binding = 0) readonly buffer Vertices
{
    uint8_t vertices[];
};

layout(location = 0) out vec4 color;

void main()
{
    color = vec4(int(vertices[gl_VertexIndex]));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.3.8bitstorage-ubo.vert]=[
#version 450

#extension GL_EXT_shader_8bit_storage: require

layout(binding = 0) readonly uniform Vertices
{
    uint8_t vertices[512];
};

layout(location = 0) out vec4 color;

void main()
{
    color = vec4(int(vertices[gl_VertexIndex]));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.3.coopmat.comp]=[
#version 450 core
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_NV_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable

#pragma use_variable_pointers

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) coherent buffer Block {
    float y[1024*1024];
    float x[];
} block;
.
.
void main()
{
    fcoopmatNV<32, gl_ScopeSubgroup, 16, 8> m = fcoopmatNV<32, gl_ScopeSubgroup, 16, 8>(0.0);

    m = m + m;
    m = m - m;
    m = -m;
    m = 2.0*m;
    m = m*2.0;

    coopMatLoadNV(m, block.x, 16, 128, false);
    coopMatStoreNV(m, block.x, 16, 128, false);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
18:46; [@144,457:457='=',<'='>,18:46]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
]


testGlslangErrors[spv.1.4.LoopControl.frag]=[
#version 450

#extension GL_EXT_control_flow_attributes : enable

bool cond;

void main()
{
        [[min_iterations(3), max_iterations(7)]]   for (int i = 0; i < 8; ++i) { }
        [[iteration_multiple(2)]]                  while(true) {  }
        [[peel_count(5)]]                          do {  } while(true);
        [[partial_count(4)]]                       for (int i = 0; i < 8; ++i) { }

        // warnings on all these
        [[min_iterations, max_iterations]]   for (int i = 0; i < 8; ++i) { }
        //[[iteration_multiple(0)]]                  while(true) {  }
        //[[peel_count]]                          do {  } while(true);
        //[[partial_count]]                       for (int i = 0; i < 8; ++i) { }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.NonWritable.frag]=[
#version 450

layout(location = 0) flat in int index;

layout(location = 0) out float color;

// lookup table
const float table[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };

void main()
{
    color = table[index];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpCopyLogical.comp]=[
#version 450 core

struct MyStruct
{
    vec2 foo[2];
    int sb;
};

layout(binding = 0, std430) buffer SSBO0
{
    MyStruct a;
} inBuf;

layout(binding = 1, std430) buffer SSBO1
{
    MyStruct b;
} outBuf;

layout(binding = 2, std140) uniform UBO
{
    MyStruct c;
} uBuf;

struct Nested {
    float f;
    MyStruct S[2];
};

layout(binding = 2, std140) uniform UBON
{
    Nested N1;
} uBufN;

layout(binding = 1, std430) buffer SSBO1N
{
    Nested N2;
} outBufN;

void main()
{
    MyStruct t = inBuf.a;
    outBuf.b = t;
    t = uBuf.c;
    outBuf.b = t;

    Nested n = uBufN.N1;
    outBufN.N2 = n;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpCopyLogical.funcall.frag]=[
#version 450

struct S { mat4 m; };
buffer blockName { S s1; };  // need an S with decoration
S s2;                        // no decorations on S

void fooConst(const in S s) { }
void foo(in S s) { }
void fooOut(inout S s) { }

void main()
{
  fooConst(s1);
  fooConst(s2);

  foo(s1);
  foo(s2);

  fooOut(s1);
  fooOut(s2);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpCopyLogicalBool.comp]=[
#version 450 core

struct MyStruct
{
    vec2 foo[2];
    bool sb;
};

layout(binding = 0, std430) buffer SSBO0
{
    MyStruct a;
} inBuf;

layout(binding = 1, std430) buffer SSBO1
{
    MyStruct b;
} outBuf;

layout(binding = 2, std140) uniform UBO
{
    MyStruct c;
} uBuf;

struct Nested {
    bool b;
    MyStruct S[2];
};

layout(binding = 2, std140) uniform UBON
{
    Nested N1;
} uBufN;

layout(binding = 1, std430) buffer SSBO1N
{
    Nested N2;
} outBufN;

void main()
{
    MyStruct t = inBuf.a;
    outBuf.b = t;
    t = uBuf.c;
    outBuf.b = t;

    Nested n = uBufN.N1;
    outBufN.N2 = n;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpEntryPoint.frag]=[
#version 450

layout(location = 0) in vec4 inv;
layout(location = 0) out vec4 outv;

vec4 globalv;

layout(binding = 0) uniform ubt {
    vec4 v;
} uniformv;

layout(binding = 1) buffer bbt {
    float f;
} bufferv;

layout(binding = 2, push_constant) uniform pushB {
    int a;
} pushv;

void main()
{
    vec4 functionv;
    functionv = inv;
    globalv = inv;
    outv = functionv + inv + globalv + uniformv.v * pushv.a * bufferv.f;
    outv += functionv + inv + globalv + uniformv.v * pushv.a * bufferv.f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpEntryPoint.opaqueParams.vert]=[
#version 450

layout(binding = 0) uniform sampler2D s2D;
layout(binding = 1) uniform texture2D t2D;
layout(binding = 3) uniform sampler s;

vec2 funOpaque(in sampler2D s2D, texture2D t2D, sampler s)
{
    return textureSize(s2D, 0) * texture(sampler2D(t2D, s), vec2(0.5)).xy;
}

void main()
{
    vec2 size = funOpaque(s2D, t2D, s);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.OpSelect.frag]=[
#version 450

struct S1 {
    float a;
    int b;
};

layout(location = 0) flat in S1 in1;
layout(location = 2) flat in S1 in2;
layout(location = 4) flat in int cond;

layout(location = 0) out float outv;

void fun1(){}
void fun2(){}

void main()
{
    // glslang will only make OpSelect for very trivial looking expressions

    float f1 = 1.0;
    float f2 = 2.0;
    outv = cond < 8 ? f1 : f2;           // in all versions

    ivec4 iv1 = ivec4(f1);
    ivec4 iv2 = ivec4(f2);
    outv *= (cond > 0 ? iv1 : iv2).z;     // in all versions, but in 1.4 as scalar condition, not smeared ala mix()

    mat3 m1 = mat3(1.0);
    mat3 m2 = mat3(2.0);
    outv *= (cond < 20 ? m1 : m2)[2][1];  // in 1.4, but not before

    S1 fv = cond > 5 ? in1 : in2;         // in 1.4, but not before
    outv *= fv.a;

    cond > 0 ? fun1() : fun2();           // not allowed by any version
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.constructComposite.comp]=[
#version 460 core

layout(local_size_x=64) in;

struct sA {
  int x, y;
};

struct sB {
  sA a;
};

layout(binding=0,set=0) uniform ubo {
  sB  b;
};

struct sC {
  sA state;
} c = {
  b.a,
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.image.frag]=[
#version 450

layout(rgba32f, binding = 1)    uniform  image2D         i2D;
layout(r32i,   binding = 12)    uniform iimage2D        ii2D;
layout(r32ui,   binding = 12)   uniform uimage2D        ui2D;

layout(rgba32f, binding = 9)    uniform  image2DMS     i2DMS;
layout(r32i,    binding = 13)   uniform iimage2DMS    ii2DMS;
layout(r32ui,    binding = 13)  uniform uimage2DMS    ui2DMS;

flat in ivec2 ic2D;
flat in uint value;

out vec4 fragData;

void main()
{
    vec4 v = vec4(0.0);
    ivec4 iv = ivec4(0.0);
    uvec4 uv = uvec4(0.0);

    v += imageLoad(i2D, ic2D);
    imageStore(i2D, ic2D, v);
    v += imageLoad(ii2D, ic2D);
    imageStore(ii2D, ic2D, iv);
    v += imageLoad(ui2D, ic2D);
    imageStore(ui2D, ic2D, uv);

    v += imageLoad(i2DMS, ic2D, 1);
    imageStore(i2DMS, ic2D, 2, v);
    v += imageLoad(ii2DMS, ic2D, 1);
    imageStore(ii2DMS, ic2D, 2, iv);
    v += imageLoad(ui2DMS, ic2D, 1);
    imageStore(ui2DMS, ic2D, 2, uv);

    fragData = v;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.sparseTexture.frag]=[
#version 450
#extension GL_ARB_sparse_texture2: enable

uniform sampler2D               s2D;
uniform isampler2D             is2D;
uniform usampler2D             us2D;

layout(rgba32f)  uniform  image2D i2D;
layout(rgba32i)  uniform iimage2DMS ii2DMS;
layout(rgba32ui) uniform uimage3D ui3D;

in vec2 c2;
in vec3 c3;
in vec4 c4;

in flat ivec2 ic2;
in flat ivec3 ic3;

in flat ivec2 offsets[4];

out vec4 outColor;

void main()
{
    int   resident = 0;
    vec4  texel  = vec4(0.0);
    ivec4 itexel = ivec4(0);
    uvec4 utexel = uvec4(0);

    resident |= sparseTextureARB(s2D,  c2, texel);
    resident |= sparseTextureARB(is2D, c2, texel);
    resident |= sparseTextureARB(us2D, c2, texel);

    resident |= sparseTextureLodARB( s2D, c2, 2.0, texel);
    resident |= sparseTextureLodARB(is2D, c2, 2.0, texel);
    resident |= sparseTextureLodARB(us2D, c2, 2.0, texel);

    resident |= sparseTexelFetchARB( s2D, ivec2(c2), 2, texel);
    resident |= sparseTexelFetchARB(is2D, ivec2(c2), 2, texel);
    resident |= sparseTexelFetchARB(us2D, ivec2(c2), 2, texel);

    resident |= sparseImageLoadARB(i2D, ic2, texel);
    resident |= sparseImageLoadARB(ii2DMS, ic2, 3, texel);
    resident |= sparseImageLoadARB(ui3D, ic3, utexel);

    outColor = sparseTexelsResidentARB(resident) ? texel : vec4(itexel) + vec4(utexel);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.1.4.texture.frag]=[
#version 450

uniform  sampler2D       texSampler2D;
uniform isampler2D      itexSampler2D;
uniform usampler2D      utexSampler2D;

in  vec2 t;
in  vec2 coords2D;
flat in ivec2 iCoords2D;

out vec4 color;

flat in int iLod;

void main()
{
    vec4  color = vec4(0.0, 0.0, 0.0, 0.0);

    color += texture( texSampler2D, coords2D);
    color += texture(itexSampler2D, coords2D);
    color += texture(utexSampler2D, coords2D);

    color += texelFetch( texSampler2D, iCoords2D, iLod);
    color += texelFetch(itexSampler2D, iCoords2D, iLod);
    color += texelFetch(utexSampler2D, iCoords2D, iLod);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.100ops.frag]=[
#version 310 es

lowp float foo();

in lowp float low, high;

lowp float face1 = 11.0;

out lowp vec4 Color;

void main()
{
    int z = 3;

    if (2.0 * low + 1.0 < high)
        ++z;

    Color = face1 * vec4(z) + foo();
}

lowp float face2 = -2.0;

lowp float foo()
{
    // testing if face2 initializer insert logic is correct in main
    return face2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.130.frag]=[
#version 140
#extension GL_ARB_texture_gather : enable

vec3 a;
float b;

in vec4 i;
out vec4 o;
out ivec3 io;
out uvec4 uo;

flat in float fflat;
smooth in float fsmooth;
noperspective in float fnop;

uniform samplerCube sampC;

#extension GL_ARB_texture_rectangle : enable

uniform sampler2D samp2D;
uniform sampler2DShadow samp2DS;
uniform sampler2DRect samp2DR;
uniform sampler2DArray samp2DA;

void bar3()
{
    o += textureGatherOffset(samp2D, vec2(0.3), ivec2(1));
    o += textureGatherOffset(samp2DA, vec3(0.3), ivec2(1));
}

#extension GL_ARB_gpu_shader5 : enable

void bar4()
{
    o += textureGatherOffset(samp2DR, vec2(0.3), ivec2(1));
    o += textureGatherOffset(samp2DS, vec2(0.3), 1.3, ivec2(1));
    o += textureGatherOffset(samp2D, vec2(0.3), ivec2(1), 2);
}

#extension GL_ARB_texture_cube_map_array : enable

uniform  samplerCubeArray Sca;
uniform isamplerCubeArray Isca;
uniform usamplerCubeArray Usca;
uniform samplerCubeArrayShadow Scas;

void bar5()
{
    io = textureSize(Sca, 3);
    o += texture(Sca, i);
    io += texture(Isca, i, 0.7).xyz;
    uo = texture(Usca, i);
    
    o += textureLod(Sca, i, 1.7);
    a = textureSize(Scas, 3);
    float f = texture(Scas, i, i.y);
    ivec4 c = textureGrad(Isca, i, vec3(0.1), vec3(0.2));
    o += vec4(a, f + c);
}

#extension GL_ARB_shading_language_420pack : enable

const int ai[3] = { 10, 23, 32 };
uniform layout(binding=0) sampler2D bounds;

void bar6()
{
    mat4x3 m43;
    float a1 = m43[3].y;
    //int a2 = m43.length();  // ERROR until shading_language_420pack is fully implemented
    const float b = 2 * a1;
    //a.x = gl_MinProgramTexelOffset + gl_MaxProgramTexelOffset;    // ERROR until shading_language_420pack is fully implemented
}
.
.
#extension GL_ARB_texture_rectangle : enable
#extension GL_ARB_shader_texture_lod : require

uniform sampler2D s2D;
uniform sampler2DRect s2DR;
uniform sampler2DRectShadow s2DRS;
uniform sampler1D s1D;
uniform sampler2DShadow s2DS;

void main()
{
    o = textureGather(sampC, vec3(0.2));
    o.y =  gl_ClipDistance[3];
    bar3();
    bar4();
    bar5();
    bar6();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.140.frag]=[
#version 140
#extension GL_ARB_enhanced_layouts : require

in vec4 k;
out vec4 o;

in float gl_ClipDistance[5];

layout(row_major) uniform;

uniform sampler2D samp2Da[3];

layout(std140) uniform bn {
    layout(row_major) mat4 matra[4];
    layout(column_major) mat4 matca[4];
    layout(row_major) mat4 matr;
    layout(column_major) mat4 matc;
    layout(align=512, offset=1024) mat4 matrdef;
};

uniform sampler2DRect sampR;
uniform isamplerBuffer sampB;

float foo();

void main()
{
    o.y = gl_ClipDistance[2];
    o.z = gl_ClipDistance[int(k)];
    o.w = float(textureSize(sampR) + textureSize(sampB)) / 100.0;
    o.z = foo();
}

// Test extra-function initializers

float i1 = gl_FrontFacing ? -2.0 : 2.0;
float i2 = 102;

float foo()
{
    return i1 + i2;
}

// test arrayed block
layout(std140) uniform bi {
    vec3 v[2];
} bname[4];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.150.geom]=[
#version 150 core

layout(triangles_adjacency) in;
layout(max_vertices = 30) out;
layout(stream = 3, triangle_strip) out;

in fromVertex {
    in vec3 color;
} fromV[];

out toFragment {
    out vec3 color;
} toF;

out fromVertex {
    vec3 color;
};

void main()
{
    color = fromV[0].color;
    //?? gl_ClipDistance[3] = gl_in[1].gl_ClipDistance[2];
    gl_Position = gl_in[0].gl_Position;
    gl_PointSize = gl_in[3].gl_PointSize;
    gl_PrimitiveID = gl_PrimitiveIDIn;
    gl_Layer = 2;

    EmitVertex();

    color = 2 * fromV[0].color;
    gl_Position = 2.0 * gl_in[0].gl_Position;
    gl_PointSize = 2.0 * gl_in[3].gl_PointSize;
    gl_PrimitiveID = gl_PrimitiveIDIn + 1;
    gl_Layer = 3;

    EmitVertex();

    EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.150.vert]=[
#version 150 core

in vec4 iv4;

in float ps;
in int ui;
uniform sampler2D s2D;

invariant gl_Position;

struct s1 {
    int a;
    int a2;
    vec4 b[3];
};

struct s2 {
    int c;
    s1 d[4];
};

out s2 s2out;

void main()
{
    gl_Position = iv4;
    gl_PointSize = ps;
    gl_ClipDistance[2] = iv4.x;
    int i;
    s2out.d[i].b[2].w = ps;

    // test non-implicit lod
    texture(s2D, vec2(0.5));
    textureProj(s2D, vec3(0.5));
    textureLod(s2D, vec2(0.5), 3.2);
}

out float gl_ClipDistance[4];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage-int.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    int16_t  x;
    i16vec2    y;
    i16vec3    z;
};

layout(column_major, std140) uniform B1
{
    int16_t  a;
    i16vec2    b;
    i16vec3    c;
    int16_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    int16_t  o;
    i16vec2    p;
    i16vec3    q;
    int16_t  r[2];
    S          u;
    S          v[2];
    i16vec2    x[100];
    int16_t  w[];
} b2;

layout(row_major, std140) uniform B5
{
    int16_t  o;
    i16vec2    p;
    i16vec3    q;
    int16_t  r[2];
    S          u;
    S          v[2];
    i16vec2    x[100];
    int16_t  w[100];
} b5;

struct S2 {
    mat4x4 x;
    int16_t y;
    int z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
    S3 y;
} b4;

void main()
{
    b2.o = b1.a;
    b2.p = i16vec2(ivec3(b2.q).xy);
    b2.p = i16vec2(ivec3(b5.q).xy);
    b2.r[0] = b2.r[0];
    b2.r[1] = b5.r[1];
    b2.p = b2.p;
    int x0 = int(b1.a);
    ivec4 x1 = ivec4(b1.a, b2.p, 1);
    b4.x.x = b3.x.x;
    b2.o = int16_t(ivec2(b2.p).x);
    b2.p = b2.v[1].y;
    ivec3 v3 = ivec3(b2.w[b1.j], b2.w[b1.j+1], b2.w[b1.j+2]);
    ivec3 u3 = ivec3(b5.w[b1.j], b5.w[b1.j+1], b5.w[b1.j+2]);
    b2.x[0] = b2.x[0];
    b2.x[1] = b5.x[1];
    b2.p.x = b1.a;
    b2.o = b2.p.x;
    b2.p = i16vec2(ivec2(1, 2));
    b2.o = int16_t(3);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage-uint.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    uint16_t  x;
    u16vec2    y;
    u16vec3    z;
};

layout(column_major, std140) uniform B1
{
    uint16_t  a;
    u16vec2    b;
    u16vec3    c;
    uint16_t  d[2];
    S          g;
    S          h[2];
    uint        j;
} b1;

layout(row_major, std430) buffer B2
{
    uint16_t  o;
    u16vec2    p;
    u16vec3    q;
    uint16_t  r[2];
    S          u;
    S          v[2];
    u16vec2    x[100];
    uint16_t  w[];
} b2;

layout(row_major, std140) uniform B5
{
    uint16_t  o;
    u16vec2    p;
    u16vec3    q;
    uint16_t  r[2];
    S          u;
    S          v[2];
    u16vec2    x[100];
    uint16_t  w[100];
} b5;

struct S2 {
    mat4x4 x;
    uint16_t y;
    uint z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
    S3 y;
} b4;

void main()
{
    b2.o = b1.a;
    b2.p = u16vec2(uvec3(b2.q).xy);
    b2.p = u16vec2(uvec3(b5.q).xy);
    b2.r[0] = b2.r[0];
    b2.r[1] = b5.r[1];
    b2.p = b2.p;
    uint x0 = uint(b1.a);
    uvec4 x1 = uvec4(b1.a, b2.p, 1);
    b4.x.x = b3.x.x;
    b2.o = uint16_t(uvec2(b2.p).x);
    b2.p = b2.v[1].y;
    uvec3 v3 = uvec3(b2.w[b1.j], b2.w[b1.j+1], b2.w[b1.j+2]);
    uvec3 u3 = uvec3(b5.w[b1.j], b5.w[b1.j+1], b5.w[b1.j+2]);
    b2.x[0] = b2.x[0];
    b2.x[1] = b5.x[1];
    b2.p.x = b1.a;
    b2.o = b2.p.x;
    b2.p = u16vec2(uvec2(1, 2));
    b2.o = uint16_t(3u);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    float16_t  x;
    f16vec2    y;
    f16vec3    z;
};

layout(column_major, std140) uniform B1
{
    float16_t  a;
    f16vec2    b;
    f16vec3    c;
    float16_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    float16_t  o;
    f16vec2    p;
    f16vec3    q;
    float16_t  r[2];
    S          u;
    S          v[2];
    f16vec2    x[100];
    float16_t  w[];
} b2;

layout(row_major, std140) uniform B5
{
    float16_t  o;
    f16vec2    p;
    f16vec3    q;
    float16_t  r[2];
    S          u;
    S          v[2];
    f16vec2    x[100];
    float16_t  w[100];
} b5;

struct S2 {
    mat4x4 x;
    float16_t y;
    float z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
    S3 y;
} b4;

void main()
{
    b2.o = b1.a;
    b2.p = f16vec2(vec3(b2.q).xy);
    b2.p = f16vec2(vec3(b5.q).xy);
    b2.r[0] = b2.r[0];
    b2.r[1] = b5.r[1];
    b2.p = b2.p;
    float x0 = float(b1.a);
    vec4 x1 = vec4(b1.a, b2.p, 1.0);
    b4.x.x = b3.x.x;
    b2.o = float16_t(vec2(b2.p).x);
    b2.p = b2.v[1].y;
    vec3 v3 = vec3(b2.w[b1.j], b2.w[b1.j+1], b2.w[b1.j+2]);
    vec3 u3 = vec3(b5.w[b1.j], b5.w[b1.j+1], b5.w[b1.j+2]);
    b2.x[0] = b2.x[0];
    b2.x[1] = b5.x[1];
    b2.p.x = b1.a;
    b2.o = b2.p.x;
    b2.p = f16vec2(vec2(1.0, 2.0));
    b2.o = float16_t(3.0);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage_Error-int.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    int16_t  x;
    i16vec2    y;
    i16vec3    z;
};

layout(column_major, std140) uniform B1
{
    int16_t  a;
    i16vec2    b;
    i16vec3    c;
    int16_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    int16_t  o;
    i16vec2    p;
    i16vec3    q;
    int16_t  r[2];
    S          u;
    S          v[2];
    int16_t  w[];
} b2;

struct S2 {
    mat4x4 x;
    int16_t y;
    int z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
} b4;

void func3(S2 x) {
}

S2 func4() {
    return b4.x;
}

int func(int16_t a) {
    return 0;
}

struct S4 {
    int x;
    int16_t y;
};

int func2(int a) { return 0; }

void main()
{
    b2.o = b2.q[1];
    b2.p = b2.q.xy;
    b2.o = max(b1.a, b1.a);
    bvec2 bv = lessThan(b2.p, b2.p);
    b2.o = b1.a + b1.a;
    b2.o = -b1.a;
    b2.o = b1.a + 1;
    b2.p = b2.p.yx;
    b4.x = b3.x;
    int16_t f0;
    S2 f1;
    S3 f2;
    if (b1.a == b1.a) {}
    b2.r = b2.r;
    b2.p = i16vec2(3, 4);
    i16vec2[2](i16vec2(ivec2(1,2)), i16vec2(ivec2(3,4)));
    // NOT ERRORING YET
    b3.x;
    S4(0, int16_t(0));
    func2(b1.a);
}
.
.
layout(column_major, std140) uniform B6
{
    i16mat2x3  e;
} b6;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage_Error-uint.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    uint16_t  x;
    u16vec2    y;
    u16vec3    z;
};

layout(column_major, std140) uniform B1
{
    uint16_t  a;
    u16vec2    b;
    u16vec3    c;
    uint16_t  d[2];
    S          g;
    S          h[2];
    uint        j;
} b1;

layout(row_major, std430) buffer B2
{
    uint16_t  o;
    u16vec2    p;
    u16vec3    q;
    uint16_t  r[2];
    S          u;
    S          v[2];
    uint16_t  w[];
} b2;

struct S2 {
    mat4x4 x;
    uint16_t y;
    uint z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
} b4;

void func3(S2 x) {
}

S2 func4() {
    return b4.x;
}

uint func(uint16_t a) {
    return 0;
}

struct S4 {
    uint x;
    uint16_t y;
};

uint func2(uint a) { return 0; }

void main()
{
    b2.o = b2.q[1];
    b2.p = b2.q.xy;
    b2.o = max(b1.a, b1.a);
    bvec2 bv = lessThan(b2.p, b2.p);
    b2.o = b1.a + b1.a;
    b2.o = -b1.a;
    b2.o = b1.a + 1;
    b2.p = b2.p.yx;
    b4.x = b3.x;
    uint16_t f0;
    S2 f1;
    S3 f2;
    if (b1.a == b1.a) {}
    b2.r = b2.r;
    b2.p = u16vec2(3, 4);
    u16vec2[2](u16vec2(uvec2(1,2)), u16vec2(uvec2(3,4)));
    // NOT ERRORING YET
    b3.x;
    S4(0u, uint16_t(0u));
    func2(b1.a);
}
.
.
layout(column_major, std140) uniform B6
{
    u16mat2x3  e;
} b6;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitstorage_Error.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : enable

struct S
{
    float16_t  x;
    f16vec2    y;
    f16vec3    z;
};

layout(column_major, std140) uniform B1
{
    float16_t  a;
    f16vec2    b;
    f16vec3    c;
    float16_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    float16_t  o;
    f16vec2    p;
    f16vec3    q;
    float16_t  r[2];
    S          u;
    S          v[2];
    float16_t  w[];
} b2;

struct S2 {
    mat4x4 x;
    float16_t y;
    float z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
} b4;

void func3(S2 x) {
}

S2 func4() {
    return b4.x;
}

float func(float16_t a) {
    return 0.0;
}

struct S4 {
    float x;
    float16_t y;
};

float func2(float a) { return 0.0; }

void main()
{
    b2.o = b2.q[1];
    b2.p = b2.q.xy;
    b2.o = max(b1.a, b1.a);
    bvec2 bv = lessThan(b2.p, b2.p);
    b2.o = b1.a + b1.a;
    b2.o = -b1.a;
    b2.o = b1.a + 1.0;
    b2.p = b2.p.yx;
    b4.x = b3.x;
    float16_t f0;
    S2 f1;
    S3 f2;
    if (b1.a == b1.a) {}
    b2.r = b2.r;
    b2.o = 1.0HF;
    b2.p = f16vec2(3.0, 4.0);
    f16vec2[2](f16vec2(vec2(1.0,2.0)), f16vec2(vec2(3.0,4.0)));
    // NOT ERRORING YET
    b3.x;
    S4(0.0, float16_t(0.0));
    func2(b1.a);
}
.
.
layout(column_major, std140) uniform B6
{
    f16mat2x3  e;
} b6;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.16bitxfb.vert]=[
#version 450 core

#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_AMD_gpu_shader_int16: enable

layout(location = 0) in f16vec4 if16v4;
layout(location = 1) in i16vec4 ii16v4;
layout(location = 2) in u16vec4 iu16v4;

layout(location = 0, xfb_buffer = 0, xfb_stride = 6, xfb_offset = 0) out f16vec3 of16v3;
layout(location = 1, xfb_buffer = 1, xfb_stride = 6, xfb_offset = 0) out F16Out
{
    float16_t of16;
    f16vec2   of16v2;
};

layout(location = 5, xfb_buffer = 2, xfb_stride = 6, xfb_offset = 0) out i16vec3 oi16v3;
layout(location = 6, xfb_buffer = 3, xfb_stride = 6, xfb_offset = 0) out I16Out
{
    uint16_t ou16;
    u16vec2  ou16v2;
};

void main()
{
    of16v3 = if16v4.xyz;
    of16   = if16v4.x;
    of16v2 = if16v4.xy;

    oi16v3 = ii16v4.xyz;
    ou16   = iu16v4.x;
    ou16v2 = iu16v4.xy;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.300BuiltIns.vert]=[
#version 310 es

in mediump float ps;

invariant gl_Position;

void main()
{
    gl_Position = vec4(ps);
    gl_Position *= float(4 - gl_VertexIndex);

    gl_PointSize = ps; 
    gl_PointSize *= float(5 - gl_InstanceIndex);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.300layout.frag]=[
#version 310 es

precision mediump float;

in vec4 pos;
in vec3 color;

layout(location = 7) out vec3 c;
layout(LocatioN = 3) out vec4 p[2];

struct S {
    vec3 c;
    float f;
};

in S s;

void main()
{
    c = color + s.c;
    p[1] = pos * s.f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.300layout.vert]=[
#version 310 es

layout(location = 7) in vec3 c;
layout(LocatioN = 3) in vec4 p;
layout(location = 9) in ivec2 aiv2;
out vec4 pos;
out vec3 color;
flat out int iout;

layout(row_major) uniform; // default is now row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1; // row_major
    layout(column_major) mat4 M2; // column major
    mat3 N1; // row_major
    int iuin;
} tblock;

uniform T2 { // layout of this block is shared
    bool b;
    mat4 t2m;
};

layout(column_major) uniform T3 { // shared and column_major
    mat4 M3; // column_major
    layout(row_major) mat4 M4; // row major
    mat2x3 N2; // column_major
    layout(align=16, offset=2048) uvec3 uv3a[4];
};

in uint uiuin;

struct S {
    vec3 c;
    float f;
};

out S s;

void main()
{
    pos = p * (tblock.M1 + tblock.M2 + M4 + M3 + t2m);
    color = c * tblock.N1;
    iout = tblock.iuin + int(uiuin) + aiv2.y;
    s.c = c;
    s.f = p.x;
    if (N2[1] != vec3(1.0) || uv3a[2] != uvec3(5))
        ++s.c;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.300layoutp.vert]=[
#version 310 es

layout(location = 7) in vec3 c;
layout(LocatioN = 3) in vec4 p;
layout(location = 9) in ivec2 aiv2;
out vec4 pos;
out vec3 color;
flat out int iout;

layout(row_major) uniform; // default is now row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1; // row_major
    layout(column_major) mat4 M2; // column major
    mat3 N1; // row_major
    int iuin;
} tblock;

uniform T2 { // layout of this block is shared
    bool b;
    mat4 t2m;
};

layout(column_major) uniform T3 { // shared and column_major
    mat4 M3; // column_major
    layout(row_major) mat4 M4; // row major
    mat2x3 N2; // column_major
    uvec3 uv3a[4];
};

uint uiuin;

struct S {
    vec3 c;
    float f;
};

out S s;

void main()
{
    pos = p * (tblock.M1 * tblock.M2 * M4 * M3 * t2m);
    color = c * tblock.N1;
    iout = tblock.iuin + int(uiuin) + aiv2.y;
    s.c = c;
    s.f = p.x;
    if (N2[1] != vec3(1.0) || uv3a[2] != uvec3(5))
        ++s.c;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.310.bitcast.frag]=[
#version 310 es

flat in mediump int   i1;
flat in lowp    ivec2 i2;
flat in mediump ivec3 i3;
flat in highp   ivec4 i4;

flat in mediump uint  u1;
flat in lowp    uvec2 u2;
flat in mediump uvec3 u3;
flat in highp   uvec4 u4;

mediump in float f1;
lowp    in vec2  f2;
mediump in vec3  f3;
highp   in vec4  f4;

void main()
{
	highp ivec4 idata = ivec4(0);
	idata.x     += floatBitsToInt(f1);
	idata.xy    += floatBitsToInt(f2);
	idata.xyz   += floatBitsToInt(f3);
	idata       += floatBitsToInt(f4);

	highp uvec4 udata = uvec4(0);
	udata.x     += floatBitsToUint(f1);
	udata.xy    += floatBitsToUint(f2);
	udata.xyz   += floatBitsToUint(f3);
	udata       += floatBitsToUint(f4);

	highp vec4 fdata = vec4(0.0);
	fdata.x     += intBitsToFloat(i1);
	fdata.xy    += intBitsToFloat(i2);
	fdata.xyz   += intBitsToFloat(i3);
	fdata       += intBitsToFloat(i4);
    fdata.x     += uintBitsToFloat(u1);
	fdata.xy    += uintBitsToFloat(u2);
	fdata.xyz   += uintBitsToFloat(u3);
	fdata       += uintBitsToFloat(u4);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.310.comp]=[
#version 310 es

precision highp float;

layout (local_size_x = 16, local_size_y = 32, local_size_z = 4) in;

shared float s;
shared int i;

buffer outb {
    float f;
    float g;
    float h;
    vec3 uns[];
} outbname;

buffer outbna {
    int k;
    vec4 na;
} outbnamena;

buffer outs {
    int s;
    vec4 va[];
} outnames;

#extension GL_EXT_device_group : enable

void main()
{
    barrier();
    outbname.f = s;
    outbnamena.na = vec4(s);
    s = outbname.uns[18].x;
    outbname.uns[17] = vec3(3.0);
    outbname.uns[i] = vec3(s);
    outnames.va[gl_LocalInvocationID.x] = vec4(s);
    outnames.s = outbname.uns.length();
    gl_DeviceIndex;
    memoryBarrierShared();
    groupMemoryBarrier();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.330.geom]=[
#version 330 core
#extension GL_ARB_separate_shader_objects : enable

in gl_PerVertex
{
    float gl_ClipDistance[1];
    vec4 gl_Position;
} gl_in[];

out gl_PerVertex
{
    vec4 gl_Position;
    float gl_ClipDistance[1];
};

layout( triangles ) in;
layout( triangle_strip, max_vertices = 3 ) out;

void main()
{
    vec4 v;
    gl_Position = gl_in[1].gl_Position;
    gl_ClipDistance[0] = gl_in[1].gl_ClipDistance[0];
    EmitVertex();
    EndPrimitive();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.400.frag]=[
#version 400 core

in vec2 c2D;
flat in int i;
flat in uint u;
out uint uo;
out vec4 outp;
out ivec4 ioutp;
out uvec4 uoutp;
uniform sampler2D arrayedSampler[5];
uniform usampler2DRect samp2dr;
uniform isampler2DArray isamp2DA;
uniform sampler2DRectShadow u2drs;

#extension GL_ARB_separate_shader_objects : enable

layout(location = 6) in vec4 vl2;

void foo23()
{
    const ivec2[3] offsets = ivec2[3](ivec2(1,2), ivec2(3,4), ivec2(15,16));

    outp.x += textureProjGradOffset(u2drs, outp, vec2(0.0), vec2(0.0), offsets[1]);
}

void doubles()
{
    double doublev;
    dvec2 dvec2v;
    dvec3 dvec3v;
    dvec4 dvec4v;

    bool boolv;
    bvec2 bvec2v;
    bvec3 bvec3v;
    bvec4 bvec4v;

    doublev = sqrt(2.9);
    dvec2v  = sqrt(dvec2(2.7));
    dvec3v  = sqrt(dvec3(2.0));
    dvec4v  = sqrt(dvec4(doublev));

    doublev += inversesqrt(doublev);
    dvec2v  += inversesqrt(dvec2v);
    dvec3v  += inversesqrt(dvec3v);
    dvec4v  += inversesqrt(dvec4v);

    doublev += abs(doublev);
    dvec2v  += abs(dvec2v);
    dvec3v  += abs(dvec3v);
    dvec4v  += abs(dvec4v);

    doublev += sign(doublev);
    dvec2v  += sign(dvec2v);
    dvec3v  += sign(dvec3v);
    dvec4v  += sign(dvec4v);

    doublev += floor(doublev);
    dvec2v  += floor(dvec2v);
    dvec3v  += floor(dvec3v);
    dvec4v  += floor(dvec4v);

    doublev += trunc(doublev);
    dvec2v  += trunc(dvec2v);
    dvec3v  += trunc(dvec3v);
    dvec4v  += trunc(dvec4v);

    doublev += round(doublev);
    dvec2v  += round(dvec2v);
    dvec3v  += round(dvec3v);
    dvec4v  += round(dvec4v);

    doublev += roundEven(doublev);
    dvec2v  += roundEven(dvec2v);
    dvec3v  += roundEven(dvec3v);
    dvec4v  += roundEven(dvec4v);

    doublev += ceil(doublev);
    dvec2v  += ceil(dvec2v);
    dvec3v  += ceil(dvec3v);
    dvec4v  += ceil(dvec4v);

    doublev += fract(doublev);
    dvec2v  += fract(dvec2v);
    dvec3v  += fract(dvec3v);
    dvec4v  += fract(dvec4v);

    doublev += mod(doublev, doublev);
    dvec2v  += mod(dvec2v, doublev);
    dvec3v  += mod(dvec3v, doublev);
    dvec4v  += mod(dvec4v, doublev);
    dvec2v  += mod(dvec2v, dvec2v);
    dvec3v  += mod(dvec3v, dvec3v);
    dvec4v  += mod(dvec4v, dvec4v);

    doublev += modf(doublev, doublev);
    dvec2v  += modf(dvec2v,  dvec2v);
    dvec3v  += modf(dvec3v,  dvec3v);
    dvec4v  += modf(dvec4v,  dvec4v);

    doublev += min(doublev, doublev);
    dvec2v  += min(dvec2v, doublev);
    dvec3v  += min(dvec3v, doublev);
    dvec4v  += min(dvec4v, doublev);
    dvec2v  += min(dvec2v, dvec2v);
    dvec3v  += min(dvec3v, dvec3v);
    dvec4v  += min(dvec4v, dvec4v);

    doublev += max(doublev, doublev);
    dvec2v  += max(dvec2v, doublev);
    dvec3v  += max(dvec3v, doublev);
    dvec4v  += max(dvec4v, doublev);
    dvec2v  += max(dvec2v, dvec2v);
    dvec3v  += max(dvec3v, dvec3v);
    dvec4v  += max(dvec4v, dvec4v);

    doublev += clamp(doublev, doublev, doublev);
    dvec2v  += clamp(dvec2v, doublev, doublev);
    dvec3v  += clamp(dvec3v, doublev, doublev);
    dvec4v  += clamp(dvec4v, doublev, doublev);
    dvec2v  += clamp(dvec2v, dvec2v, dvec2v);
    dvec3v  += clamp(dvec3v, dvec3v, dvec3v);
    dvec4v  += clamp(dvec4v, dvec4v, dvec4v);

    doublev += mix(doublev, doublev, doublev);
    dvec2v  += mix(dvec2v, dvec2v, doublev);
    dvec3v  += mix(dvec3v, dvec3v, doublev);
    dvec4v  += mix(dvec4v, dvec4v, doublev);
    dvec2v  += mix(dvec2v, dvec2v, dvec2v);
    dvec3v  += mix(dvec3v, dvec3v, dvec3v);
    dvec4v  += mix(dvec4v, dvec4v, dvec4v);
    doublev += mix(doublev, doublev, boolv);
    dvec2v  += mix(dvec2v, dvec2v, bvec2v);
    dvec3v  += mix(dvec3v, dvec3v, bvec3v);
    dvec4v  += mix(dvec4v, dvec4v, bvec4v);

    doublev += step(doublev, doublev);
    dvec2v  += step(dvec2v, dvec2v);
    dvec3v  += step(dvec3v, dvec3v);
    dvec4v  += step(dvec4v, dvec4v);
    dvec2v  += step(doublev, dvec2v);
    dvec3v  += step(doublev, dvec3v);
    dvec4v  += step(doublev, dvec4v);

    doublev += smoothstep(doublev, doublev, doublev);
    dvec2v  += smoothstep(dvec2v, dvec2v, dvec2v);
    dvec3v  += smoothstep(dvec3v, dvec3v, dvec3v);
    dvec4v  += smoothstep(dvec4v, dvec4v, dvec4v);
    dvec2v  += smoothstep(doublev, doublev, dvec2v);
    dvec3v  += smoothstep(doublev, doublev, dvec3v);
    dvec4v  += smoothstep(doublev, doublev, dvec4v);

    boolv  = isnan(doublev);
    bvec2v = isnan(dvec2v);
    bvec3v = isnan(dvec3v);
    bvec4v = isnan(dvec4v);

    boolv  = boolv ? isinf(doublev) : false;
    bvec2v = boolv ? isinf(dvec2v)  : bvec2(false);
    bvec3v = boolv ? isinf(dvec3v)  : bvec3(false);
    bvec4v = boolv ? isinf(dvec4v)  : bvec4(false);

    doublev += length(doublev);
    doublev += length(dvec2v);
    doublev += length(dvec3v);
    doublev += length(dvec4v);

    doublev += distance(doublev, doublev);
    doublev += distance(dvec2v, dvec2v);
    doublev += distance(dvec3v, dvec3v);
    doublev += distance(dvec4v, dvec4v);

    doublev += dot(doublev, doublev);
    doublev += dot(dvec2v, dvec2v);
    doublev += dot(dvec3v, dvec3v);
    doublev += dot(dvec4v, dvec4v);

    dvec3v += cross(dvec3v, dvec3v);

    doublev += normalize(doublev);
    dvec2v  += normalize(dvec2v);
    dvec3v  += normalize(dvec3v);
    dvec4v  += normalize(dvec4v);

    doublev += faceforward(doublev, doublev, doublev);
    dvec2v  += faceforward(dvec2v, dvec2v, dvec2v);
    dvec3v  += faceforward(dvec3v, dvec3v, dvec3v);
    dvec4v  += faceforward(dvec4v, dvec4v, dvec4v);

    doublev += reflect(doublev, doublev);
    dvec2v  += reflect(dvec2v, dvec2v);
    dvec3v  += reflect(dvec3v, dvec3v);
    dvec4v  += reflect(dvec4v, dvec4v);

    doublev += refract(doublev, doublev, doublev);
    dvec2v  += refract(dvec2v, dvec2v, doublev);
    dvec3v  += refract(dvec3v, dvec3v, doublev);
    dvec4v  += refract(dvec4v, dvec4v, doublev);

    dmat2   dmat2v   = outerProduct(dvec2v, dvec2v);
    dmat3   dmat3v   = outerProduct(dvec3v, dvec3v);
    dmat4   dmat4v   = outerProduct(dvec4v, dvec4v);
    dmat2x3 dmat2x3v = outerProduct(dvec3v, dvec2v);
    dmat3x2 dmat3x2v = outerProduct(dvec2v, dvec3v);
    dmat2x4 dmat2x4v = outerProduct(dvec4v, dvec2v);
    dmat4x2 dmat4x2v = outerProduct(dvec2v, dvec4v);
    dmat3x4 dmat3x4v = outerProduct(dvec4v, dvec3v);
    dmat4x3 dmat4x3v = outerProduct(dvec3v, dvec4v);

    dmat2v *= matrixCompMult(dmat2v, dmat2v);
    dmat3v *= matrixCompMult(dmat3v, dmat3v);
    dmat4v *= matrixCompMult(dmat4v, dmat4v);
    dmat2x3v = matrixCompMult(dmat2x3v, dmat2x3v);  // For now, relying on no dead-code elimination
    dmat2x4v = matrixCompMult(dmat2x4v, dmat2x4v);
    dmat3x2v = matrixCompMult(dmat3x2v, dmat3x2v);
    dmat3x4v = matrixCompMult(dmat3x4v, dmat3x4v);
    dmat4x2v = matrixCompMult(dmat4x2v, dmat4x2v);
    dmat4x3v = matrixCompMult(dmat4x3v, dmat4x3v);

    dmat2v   *= transpose(dmat2v);
    dmat3v   *= transpose(dmat3v);
    dmat4v   *= transpose(dmat4v);
    dmat2x3v  = transpose(dmat3x2v);  // For now, relying on no dead-code elimination
    dmat3x2v  = transpose(dmat2x3v);
    dmat2x4v  = transpose(dmat4x2v);
    dmat4x2v  = transpose(dmat2x4v);
    dmat3x4v  = transpose(dmat4x3v);
    dmat4x3v  = transpose(dmat3x4v);

    doublev += determinant(dmat2v);
    doublev += determinant(dmat3v);
    doublev += determinant(dmat4v);

    dmat2v *= inverse(dmat2v);
    dmat3v *= inverse(dmat3v);
    dmat4v *= inverse(dmat4v);
    
    outp *= float(doublev + dvec2v.y + dvec3v.z + dvec4v.w + 
                  dmat2v[1][1] + dmat3v[2][2] + dmat4v[3][3] + dmat2x3v[1][1] + dmat3x2v[1][1] + dmat3x4v[2][2] + dmat4x3v[2][2] + dmat2x4v[1][1] + dmat4x2v[1][1] +
                  float(boolv) + float(bvec2v.x) + float(bvec3v.x) + float(bvec4v.x));
}

void main()
{
    vec4 v;
    v = texture(arrayedSampler[i], c2D);
    outp.x = gl_ClipDistance[1];
    outp.yzw = v.yzw;

    ivec2 offsets[4];
    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));
    uoutp = textureGatherOffsets(samp2dr, c2D, constOffsets, 2);
    outp += textureGather(arrayedSampler[0], c2D);
    ioutp = textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 3);
    ioutp += textureGatherOffset(isamp2DA, vec3(0.1), ivec2(1), 1+2);
    ioutp += textureGatherOffset(isamp2DA, vec3(0.1), ivec2(i));

    outp += gl_FragCoord + vl2;
    uo = u % i;
    foo23();
    doubles();

    int id = gl_PrimitiveID;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.400.tesc]=[
#version 400 core

layout(vertices = 4) out;
int outa[gl_out.length()];

patch out vec4 patchOut;

void main()
{
    barrier();

    int a = gl_MaxTessControlInputComponents +
            gl_MaxTessControlOutputComponents +
            gl_MaxTessControlTextureImageUnits +
            gl_MaxTessControlUniformComponents +
            gl_MaxTessControlTotalOutputComponents;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    int iid = gl_InvocationID;

    gl_out[gl_InvocationID].gl_Position = p;
    gl_out[gl_InvocationID].gl_PointSize = ps;
    gl_out[gl_InvocationID].gl_ClipDistance[1] = cd;

    gl_TessLevelOuter[3] = 3.2;
    gl_TessLevelInner[1] = 1.3;
}

in vec2 inb[];
in vec2 ind[gl_MaxPatchVertices];

#extension GL_ARB_separate_shader_objects : enable

layout(location = 3) in vec4 ivla[];
layout(location = 4) in vec4 ivlb[];

layout(location = 3) out vec4 ovla[];
layout(location = 4) out vec4 ovlb[];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.400.tese]=[
#version 400 core

layout(triangles, ccw) in;

layout(fractional_odd_spacing) in;

layout(point_mode) in;

patch in vec4 patchIn;

void main()
{
    int a = gl_MaxTessEvaluationInputComponents +
            gl_MaxTessEvaluationOutputComponents +
            gl_MaxTessEvaluationTextureImageUnits +
            gl_MaxTessEvaluationUniformComponents +
            gl_MaxTessPatchComponents +
            gl_MaxPatchVertices +
            gl_MaxTessGenLevel;

    vec4 p = gl_in[1].gl_Position;
    float ps = gl_in[1].gl_PointSize;
    float cd = gl_in[1].gl_ClipDistance[2];

    int pvi = gl_PatchVerticesIn;
    int pid = gl_PrimitiveID;
    vec3 tc = gl_TessCoord;
    float tlo = gl_TessLevelOuter[3];
    float tli = gl_TessLevelInner[1];

    gl_Position = p;
    gl_PointSize = ps;
    gl_ClipDistance[2] = cd;
}

#extension GL_ARB_separate_shader_objects : enable

in vec2 inb[];
in vec2 ind[gl_MaxPatchVertices];

in testblb {
    int f;
} blb[];

in testbld {
    int f;
} bld[gl_MaxPatchVertices];

layout(location = 23) in vec4 ivla[];
layout(location = 24) in vec4 ivlb[];

layout(location = 23) out vec4 ovla[2];

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.420.geom]=[
#version 420 core

layout(triangles) in;

in gl_PerVertex {
    float gl_PointSize;
} gl_in[];

out gl_PerVertex {
    float gl_PointSize;
};

layout(line_strip) out;
layout(max_vertices = 127) out;
layout(invocations = 4) in;

uniform sampler2D s2D;
in vec2 coord[];

int i;

void main()
{
    float p = gl_in[1].gl_PointSize;
    gl_PointSize = p;
    gl_ViewportIndex = 7;

    EmitStreamVertex(1);
    EndStreamPrimitive(0);
    EmitVertex();
    EndPrimitive();
    int id = gl_InvocationID;

    const ivec2 offsets[5] =
    {
        ivec2(0,1),
        ivec2(1,-2),
        ivec2(0,3),
        ivec2(-3,0),
        ivec2(2,1)
    };
    vec4 v = textureGatherOffset(s2D, coord[0], offsets[i].xy);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.430.frag]=[
#version 430 core

out vec4 color;

void main()
{
     color = vec4(1.0);
     color *= gl_Layer;
     color *= gl_ViewportIndex;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.430.vert]=[
#version 450 core
.
.

out gl_PerVertex {
    float gl_ClipDistance[];
};

const float cx = 4.20;
const float dx = 4.20;
in vec4 bad[10];
highp in vec4 badorder;
out invariant vec4 badorder2;
out flat vec4 badorder3;

in float f;

void main()
{
    gl_ClipDistance[2] = 3.7;

    if (bad[0].x == cx.x)
        badorder3 = bad[0];

    gl_ClipDistance[0] = f.x;
}

layout(binding = 3) uniform boundblock { int aoeu; } boundInst;
layout(binding = 7) uniform anonblock { int aoeu; } ;
layout(binding = 4) uniform sampler2D sampb1;
layout(binding = 5) uniform sampler2D sampb2[10];
layout(binding = 31) uniform sampler2D sampb4;

struct S { mediump float a; highp uvec2 b; highp vec3 c; };
struct SS { vec4 b; S s; vec4 c; };
layout(location = 0) flat out SS var;
out MS { layout(location = 17) float f; } outMS;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.450.geom]=[
#version 450 core

layout(triangles) in;

layout(line_strip) out;
layout(max_vertices = 127) out;
layout(invocations = 4) in;

void main()
{
    gl_PointSize = gl_in[1].gl_PointSize;
    gl_Layer = 2;
    gl_ViewportIndex = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.450.noRedecl.tesc]=[
#version 450 core

layout(vertices = 4) out;

patch out vec4 patchOut;

void main()
{
    gl_in[0].gl_PointSize;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.450.tesc]=[
#version 450 core

layout(vertices = 4) out;

layout(location=1) patch out vec4 patchOut;

struct S {
    float sMem1;  // should not see a patch decoration
    float sMem2;  // should not see a patch decoration
};

layout(location = 12) patch out TheBlock {
    highp float bMem1;  // should not see a location decoration
    highp float bMem2;
    S s;                // should see a patch decoration
} tcBlock[2];

void main()
{
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}

layout(location = 2) patch out SingleBlock {
    highp float bMem1;  // should not see a location decoration
    highp float bMem2;
    S s;                // should see a patch decoration
} singleBlock;

layout(location = 20) patch out bn {
                        vec4 v1; // location 20
  layout(location = 24) vec4 v2; // location 24
                        vec4 v3; // location 25
};
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.460.comp]=[
#version 460

void main()
{
    bool b1;
    b1 = anyInvocation(b1);
    b1 = allInvocations(b1);
    b1 = allInvocationsEqual(b1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.460.frag]=[
#version 460 core

layout(binding = 0) uniform atomic_uint aui;
uint ui;

void main()
{
    atomicCounterAdd(aui, ui);
    atomicCounterSubtract(aui, ui);
    atomicCounterMin(aui, ui);
    atomicCounterMax(aui, ui);
    atomicCounterAnd(aui, ui);
    atomicCounterOr(aui, ui);
    atomicCounterXor(aui, ui);
    atomicCounterExchange(aui, ui);
    atomicCounterCompSwap(aui, ui, ui);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.460.vert]=[
#version 460

void main()
{
    int a = gl_BaseVertex + gl_BaseInstance + gl_DrawID;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bit-16bit-construction.frag]=[
#version 450 core

#extension GL_EXT_shader_8bit_storage : enable
#extension GL_EXT_shader_16bit_storage : enable

buffer B
{
    int8_t i8_from_i16;
    int16_t i16_from_i8;
    uint8_t u8_from_u16;
    uint16_t u16_from_u8;
    float16_t f16_from_i8;
};

void main()
{
    i8_from_i16 = int8_t(int16_t(1));
    i16_from_i8 = int16_t(int8_t(1));
    u8_from_u16 = uint8_t(uint16_t(1));
    u16_from_u8 = uint16_t(uint8_t(1));
    f16_from_i8 = float16_t(int8_t(1));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage-int.frag]=[
#version 450 core

#extension GL_EXT_shader_8bit_storage : enable

struct S
{
    int8_t  x;
    i8vec2    y;
    i8vec3    z;
};

layout(column_major, std140) uniform B1
{
    int8_t  a;
    i8vec2    b;
    i8vec3    c;
    int8_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    int8_t  o;
    i8vec2    p;
    i8vec3    q;
    int8_t  r[2];
    S          u;
    S          v[2];
    i8vec2    x[100];
    int8_t  w[];
} b2;

layout(row_major, std140) uniform B5
{
    int8_t  o;
    i8vec2    p;
    i8vec3    q;
    int8_t  r[2];
    S          u;
    S          v[2];
    i8vec2    x[100];
    int8_t  w[100];
} b5;

struct S2 {
    mat4x4 x;
    int8_t y;
    int z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
    S3 y;
} b4;

void main()
{
    b2.o = b1.a;
    b2.p = i8vec2(ivec3(b2.q).xy);
    b2.p = i8vec2(ivec3(b5.q).xy);
    b2.r[0] = b2.r[0];
    b2.r[1] = b5.r[1];
    b2.p = b2.p;
    int x0 = int(b1.a);
    ivec4 x1 = ivec4(b1.a, b2.p, 1);
    b4.x.x = b3.x.x;
    b2.o = int8_t(ivec2(b2.p).x);
    b2.p = b2.v[1].y;
    ivec3 v3 = ivec3(b2.w[b1.j], b2.w[b1.j+1], b2.w[b1.j+2]);
    ivec3 u3 = ivec3(b5.w[b1.j], b5.w[b1.j+1], b5.w[b1.j+2]);
    b2.x[0] = b2.x[0];
    b2.x[1] = b5.x[1];
    b2.p.x = b1.a;
    b2.o = b2.p.x;
    b2.p = i8vec2(ivec2(1, 2));
    b2.o = int8_t(3);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage-ssbo.vert]=[
#version 450

#extension GL_EXT_shader_8bit_storage: require

layout(binding = 0) readonly buffer Vertices
{
    uint8_t vertices[];
};

layout(location = 0) out vec4 color;

void main()
{
    color = vec4(int(vertices[gl_VertexIndex]));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage-ubo.vert]=[
#version 450

#extension GL_EXT_shader_8bit_storage: require

layout(binding = 0) readonly uniform Vertices
{
    uint8_t vertices[512];
};

layout(location = 0) out vec4 color;

void main()
{
    color = vec4(int(vertices[gl_VertexIndex]));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage-uint.frag]=[
#version 450 core

#extension GL_EXT_shader_8bit_storage : enable

struct S
{
    uint8_t  x;
    u8vec2    y;
    u8vec3    z;
};

layout(column_major, std140) uniform B1
{
    uint8_t  a;
    u8vec2    b;
    u8vec3    c;
    uint8_t  d[2];
    S          g;
    S          h[2];
    uint        j;
} b1;

layout(row_major, std430) buffer B2
{
    uint8_t  o;
    u8vec2    p;
    u8vec3    q;
    uint8_t  r[2];
    S          u;
    S          v[2];
    u8vec2    x[100];
    uint8_t  w[];
} b2;

layout(row_major, std140) uniform B5
{
    uint8_t  o;
    u8vec2    p;
    u8vec3    q;
    uint8_t  r[2];
    S          u;
    S          v[2];
    u8vec2    x[100];
    uint8_t  w[100];
} b5;

struct S2 {
    mat4x4 x;
    uint8_t y;
    uint z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
    S3 y;
} b4;

void main()
{
    b2.o = b1.a;
    b2.p = u8vec2(uvec3(b2.q).xy);
    b2.p = u8vec2(uvec3(b5.q).xy);
    b2.r[0] = b2.r[0];
    b2.r[1] = b5.r[1];
    b2.p = b2.p;
    uint x0 = uint(b1.a);
    uvec4 x1 = uvec4(b1.a, b2.p, 1);
    b4.x.x = b3.x.x;
    b2.o = uint8_t(uvec2(b2.p).x);
    b2.p = b2.v[1].y;
    uvec3 v3 = uvec3(b2.w[b1.j], b2.w[b1.j+1], b2.w[b1.j+2]);
    uvec3 u3 = uvec3(b5.w[b1.j], b5.w[b1.j+1], b5.w[b1.j+2]);
    b2.x[0] = b2.x[0];
    b2.x[1] = b5.x[1];
    b2.p.x = b1.a;
    b2.o = b2.p.x;
    b2.p = u8vec2(uvec2(1, 2));
    b2.o = uint8_t(3u);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage_Error-int.frag]=[
#version 450 core

#extension GL_EXT_shader_8bit_storage : enable

struct S
{
    int8_t  x;
    i8vec2    y;
    i8vec3    z;
};

layout(column_major, std140) uniform B1
{
    int8_t  a;
    i8vec2    b;
    i8vec3    c;
    int8_t  d[2];
    S          g;
    S          h[2];
    int        j;
} b1;

layout(row_major, std430) buffer B2
{
    int8_t  o;
    i8vec2    p;
    i8vec3    q;
    int8_t  r[2];
    S          u;
    S          v[2];
    int8_t  w[];
} b2;

struct S2 {
    mat4x4 x;
    int8_t y;
    int z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
} b4;

void func3(S2 x) {
}

S2 func4() {
    return b4.x;
}

int func(int8_t a) {
    return 0;
}

struct S4 {
    int x;
    int8_t y;
};

int func2(int a) { return 0; }

void main()
{
    b2.o = b2.q[1];
    b2.p = b2.q.xy;
    b2.o = max(b1.a, b1.a);
    bvec2 bv = lessThan(b2.p, b2.p);
    b2.o = b1.a + b1.a;
    b2.o = -b1.a;
    b2.o = b1.a + 1;
    b2.p = b2.p.yx;
    b4.x = b3.x;
    int8_t f0;
    S2 f1;
    S3 f2;
    if (b1.a == b1.a) {}
    b2.r = b2.r;
    b2.p = i8vec2(3, 4);
    i8vec2[2](i8vec2(ivec2(1,2)), i8vec2(ivec2(3,4)));
    // NOT ERRORING YET
    b3.x;
    S4(0, int8_t(0));
    func2(b1.a);
}
.
.
layout(column_major, std140) uniform B6
{
    i8mat2x3  e;
} b6;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.8bitstorage_Error-uint.frag]=[
#version 450 core

#extension GL_EXT_shader_8bit_storage : enable

struct S
{
    uint8_t  x;
    u8vec2    y;
    u8vec3    z;
};

layout(column_major, std140) uniform B1
{
    uint8_t  a;
    u8vec2    b;
    u8vec3    c;
    uint8_t  d[2];
    S          g;
    S          h[2];
    uint        j;
} b1;

layout(row_major, std430) buffer B2
{
    uint8_t  o;
    u8vec2    p;
    u8vec3    q;
    uint8_t  r[2];
    S          u;
    S          v[2];
    uint8_t  w[];
} b2;

struct S2 {
    mat4x4 x;
    uint8_t y;
    uint z;
};

struct S3 {
    S2 x;
};

layout(row_major, std430) buffer B3
{
    S2 x;
} b3;

layout(column_major, std430) buffer B4
{
    S2 x;
} b4;

void func3(S2 x) {
}

S2 func4() {
    return b4.x;
}

uint func(uint8_t a) {
    return 0;
}

struct S4 {
    uint x;
    uint8_t y;
};

uint func2(uint a) { return 0; }

void main()
{
    b2.o = b2.q[1];
    b2.p = b2.q.xy;
    b2.o = max(b1.a, b1.a);
    bvec2 bv = lessThan(b2.p, b2.p);
    b2.o = b1.a + b1.a;
    b2.o = -b1.a;
    b2.o = b1.a + 1;
    b2.p = b2.p.yx;
    b4.x = b3.x;
    uint8_t f0;
    S2 f1;
    S3 f2;
    if (b1.a == b1.a) {}
    b2.r = b2.r;
    b2.p = u8vec2(3, 4);
    u8vec2[2](u8vec2(uvec2(1,2)), u8vec2(uvec2(3,4)));
    // NOT ERRORING YET
    b3.x;
    S4(0u, uint8_t(0u));
    func2(b1.a);
}
.
.
layout(column_major, std140) uniform B6
{
    u8mat2x3  e;
} b6;
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.AofA.frag]=[
#version 430

in float infloat;
out float outfloat;

uniform uAofA {
    float f[2][4];
} nameAofA[3][5];

float[4][5][6] many[1][2][3];

float g4[4][7];
in float g5[5][7];

flat in int i, j, k;

float[4][7] foo(float a[5][7])
{
    float r[7];
    r = a[2];

    return float[4][7](a[0], a[1], r, a[3]);
}

void main()
{
    outfloat = 0.0;

    g4 = foo(g5);

//    if (foo(g5) == g4)
//        ++outfloat;

    float u[][7];
    u[2][2] = 3.0;
    float u[5][7];

    foo(u);

    many[i][j][k][i][j][k] = infloat;
    outfloat += many[j][j][j][j][j][j];
    outfloat += nameAofA[1][2].f[0][3];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.GeometryShaderPassthrough.geom]=[
#version 450
#extension GL_NV_geometry_shader_passthrough : require

layout(triangles) in;

layout(passthrough) in gl_PerVertex {
    vec4 gl_Position;
};

layout(passthrough) in Inputs {
vec2 texcoord;
vec4 baseColor;
};

void main()
{
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.OVR_multiview.vert]=[
#version 330

#extension GL_OVR_multiview : enable

layout(num_views = 2) in;

void main() {
    gl_Position = vec4(gl_ViewID_OVR, 0, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.Operations.frag]=[
#version 450

flat in ivec4 uiv4;
in vec4 uv4;
bool ub;
bvec4 ub41, ub42;
in float uf;
flat in int ui;
flat in uvec4 uuv4;
flat in uint uui;

out vec4 FragColor;

void main()
{
    vec4 v;
	float f;
	bool b;
	bvec4 bv4;
	int i;
	uint u;

	// floating point
    v = radians(uv4);
    v += degrees(v);
    v += (i = ui*ui, sin(v));
    v += cos(v);
    v += tan(v);
    v += asin(v);
    v += acos(v);

    v += atan(v);
    v += sinh(v);
    v += cosh(v);
    v += tanh(v);
    v += asinh(v);
    v += acosh(v);
    v += atanh(v);

    v += pow(v, v);
    v += exp(v);
    v += log(v);
    v += exp2(v);
    v += log2(v);
    v += sqrt(v);
    v += inversesqrt(v);
    v += abs(v);
    v += sign(v);
    v += floor(v);

    v += trunc(v);
    v += round(v);
    v += roundEven(v);

    v += ceil(v);
    v += fract(v);
    v += mod(v, v);
    v += mod(v, v.x);

    v += modf(v, v);
    v += modf(v, v.yzxw);

    v += min(v, uv4);
    v += max(v, uv4);
    v += clamp(v, uv4, uv4);
    v += mix(v,v,v);

    v += mix(v,v,ub41);
    v += mix(v,v,f);
//spv    v += intBitsToFloat(ui);
//    v += uintBitsToFloat(uui);
//    i += floatBitsToInt(f);
//    u += floatBitsToUint(f);
    v += fma(v, uv4, v);

    v += step(v,v);
    v += smoothstep(v,v,v);
    v += step(uf,v);
    v += smoothstep(uf,uf,v);
    v += normalize(v);
    v += faceforward(v, v, v);
    v += reflect(v, v);
    v += refract(v, v, uf);
    v += dFdx(v);
    v += dFdy(v);
    v += fwidth(v);

	// signed integer
	i += abs(ui);
	i += sign(i);
	i += min(i, ui);
	i += max(i, ui);
	i += clamp(i, ui, ui);

	// unsigned integer
    u += min(u, uui);
    u += max(u, uui);
    u += clamp(u, uui, uui);

    // multiple out operands
    uvec4 msb;
    uvec4 lsb;
    umulExtended(uuv4.xyz, uuv4.xyz, msb.xyz, lsb.xyz);
    u += msb.x + msb.y + msb.z;
    u += lsb.x + lsb.y + lsb.z;

	//// bool
	b = isnan(uf);
    b = isinf(f);
	b = any(lessThan(v, uv4));
	b = (b && any(lessThanEqual(v, uv4)));
    b = (b && any(greaterThan(v, uv4)));
    b = (b && any(greaterThanEqual(v, uv4)));
    b = (b && any(equal(ub41, ub42)));
    b = (b && any(notEqual(ub41, ub42)));
    b = (b && any(ub41));
    b = (b && all(ub41));
    b = (b && any(not(ub41)));
	
	i = ((i + ui) * i - ui) / i;
	i = i % ui;
	if (i == ui || i != ui && i == ui ^^ i != 2)
	    ++i;
	
	f = ((uf + uf) * uf - uf) / uf;

	f += length(v);
    f += distance(v, v);
    f += dot(v, v);
    f += dot(f, uf);
	f += cross(v.xyz, v.xyz).x;

	if (f == uf || f != uf && f != 2.0)
	    ++f;

    i &= ui;
    i |= 0x42;
    i ^= ui;
    i %= 17;
    i >>= 2;
    i <<= ui;
    i = ~i;
    b = !b;

    FragColor = b ? vec4(i) + vec4(f) + v : v;

    mat4 m1 = mat4(1.0), m2 = mat4(0.0);
    FragColor += (b ? m1 : m2)[1];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.16BitAccess.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable

layout(local_size_x = 2) in;

shared first
{
    int16_t a;
    float16_t f;
};

void main()
{
    a = int16_t(3);
    f = float16_t(12.3);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.8BitAccess.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable

layout(local_size_x = 2) in;

shared first
{
    int8_t a;
};

void main()
{
    a = int8_t(2);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.MixBlockNonBlock_Errors.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

shared first
{
    int a;
};

shared int b;

// Cannot mix shared block and shared non-block, will fail at linking.

void main()
{
    a = 2;
    b = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.MultiBlock.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

shared first
{
    int a;
};

shared second
{
    int b;
};

void main()
{
    a = 2;
    b = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.NonBlock.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

shared int a;
shared int b;

void main()
{
    a = 2;
    b = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.SingleBlock.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

shared first
{
    int a;
};

void main()
{
    a = 2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.scalar.comp]=[
#version 430 core

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

struct T
{
    float t[3];
};

struct S
{
    float f;
    vec2 v2;
    vec3 v3;
    vec4 v4;
    T t;

    float f_array[6];
    vec2 v2_array[6];
    vec3 v3_array[6];
    vec4 v4_array[6];
    T t_array[6];
};

// Use a default qualifier.
layout(scalar) shared;

shared Block
{
    S s;
    S s_array[6];
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.std140.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

struct T
{
    float t[3];
};

struct S
{
    float f;
    vec2 v2;
    vec3 v3;
    vec4 v4;
    T t;

    float f_array[6];
    vec2 v2_array[6];
    vec3 v3_array[6];
    vec4 v4_array[6];
    T t_array[6];
};

layout(std140) shared Block
{
    S s;
    S s_array[6];
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.WorkgroupMemoryExplicitLayout.std430.comp]=[
#version 430 core

#extension GL_EXT_shared_memory_block : enable

layout(local_size_x = 8) in;

struct T
{
    float t[3];
};

struct S
{
    float f;
    vec2 v2;
    vec3 v3;
    vec4 v4;
    T t;

    float f_array[6];
    vec2 v2_array[6];
    vec3 v3_array[6];
    vec4 v4_array[6];
    T t_array[6];
};

layout(std430) shared Block
{
    S s;
    S s_array[6];
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.accessChain.frag]=[
#version 420

struct S 
{
    vec3 color;
};

layout(location = 0) out vec3 OutColor;

flat in int u;

void GetColor1(const S i) 
{ 
    OutColor += i.color.x;
}

void GetColor2(const S i, int comp)
{ 
    OutColor += i.color[comp];
}

void GetColor3(const S i, int comp)
{ 
    OutColor += i.color[comp].x;
}

void GetColor4(const S i, int comp)
{ 
    OutColor += i.color[comp].x;
}

void GetColor5(const S i, int comp)
{ 
    OutColor += i.color;
}

void GetColor6(const S i, int comp)
{ 
    OutColor += i.color.yx[comp];
}

void GetColor7(const S i, int comp)
{ 
    OutColor.xy += i.color.yxz.yx;
}

void GetColor8(const S i, int comp)
{ 
    OutColor += i.color.yzx.yx.x.x;
}

void GetColor9(const S i, int comp)
{ 
    OutColor.zxy += i.color;
}

void GetColor10(const S i, int comp)
{ 
    OutColor.zy += i.color.xy;
}

void GetColor11(const S i, int comp)
{ 
    OutColor.zxy.yx += i.color.xy;
}

void GetColor12(const S i, int comp)
{ 
    OutColor[comp] += i.color.x;
}

void GetColor13(const S i, int comp)
{ 
    OutColor.zy[comp] += i.color.x;
}

void GetColor14(const S i, int comp)
{ 
    OutColor.zyx[comp] = i.color.x;
}

void main()
{
    S s;
    OutColor = vec3(0.0);
    GetColor1(s);
    GetColor2(s, u);
    GetColor3(s, u);
    GetColor4(s, u);
    GetColor5(s, u);
    GetColor6(s, u);
    GetColor7(s, u);
    GetColor8(s, u);
    GetColor9(s, u);
    GetColor10(s, u);
    GetColor11(s, u);
    GetColor12(s, u);
    GetColor13(s, u);
    GetColor14(s, u);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.aggOps.frag]=[
#version 450

uniform sampler2D samp2D;
in mediump vec2 coord;

in vec4 u, w;
out vec4 color;

struct s1 {
    int i;
    float f;
};

struct s2 {
    int i;
    float f;
	s1 s1_1;
};

layout(std140) uniform ub1 { s2 foo2a; } uName1;
layout(std430) buffer  ub2 { s2 foo2b; } uName2;

void main()
{
    vec4 v;
    s1 a[3], b[3];
    a = s1[3](s1(int(u.x), u.y), s1(int(u.z), u.w), s1(14, 14.0));
    b = s1[3](s1(17, 17.0), s1(int(w.x), w.y), s1(int(w.z), w.w));

    if (uName1.foo2a == uName2.foo2b)
        v = texture(samp2D, coord);
    else
        v = texture(samp2D, 2.0*coord);

    if (u == v)
        v *= 3.0;

    if (u != v)
        v *= 4.0;

    if (coord == v.yw)
        v *= 5.0;

    if (a == b)
        v *= 6.0;

    if (a != b)
        v *= 7.0;

	color =  v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.always-discard.frag]=[
#version 140
in vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    float radius = sqrt(x*x + y*y);
    if (radius > 1.0) {
        if (radius > 1.1) {
            ++color;
        }

        gl_FragColor = color;

        if (radius > 1.2) {
            ++color;
        }

    }

    discard;

    // If we're near an edge, darken us a tiny bit
    if (radius >= 0.75)
        color -= abs(pow(radius, 16.0)/2.0);

    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.always-discard2.frag]=[
#version 140
in vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    discard;
.
.
    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.arbPostDepthCoverage.frag]=[
#version 450

#extension GL_ARB_post_depth_coverage : enable
#extension GL_EXT_post_depth_coverage : enable //according to ARB_post_depth_coverage, 
                                               //if both enabled, this one should be ignored
precision highp int;
layout(post_depth_coverage) in;

layout (location = 0) out int readSampleMaskIn;

void main () {
    readSampleMaskIn = gl_SampleMaskIn[0];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
4:47; <no symbol>; token recognition error at: '/'; LexerNoViableAltException:null
4:48; <no symbol>; token recognition error at: '/'; LexerNoViableAltException:null
4:49; [@24,113:121='according',<NR_IDENTIFIER>,4:49]; mismatched input 'according' expecting NR_EOL; InputMismatchException:null
4:85; <no symbol>; token recognition error at: ','; LexerNoViableAltException:null
]


testGlslangErrors[spv.arbPostDepthCoverage_Error.frag]=[
#version 310 es

#extension GL_ARB_post_depth_coverage : enable

precision highp float;

layout(post_depth_coverage, location = 0) in float a;  // should fail since post_depth_coverage may only
                                                       // be declared on in only (not with variable declarations)

void main () {

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomic.comp]=[
#version 450
.
.

layout(binding = 0) uniform atomic_uint counter;

layout(binding = 0, offset = 4) uniform atomic_uint countArr[4];
shared uint value;

int arrX[gl_WorkGroupSize.x];
int arrY[gl_WorkGroupSize.y];
int arrZ[gl_WorkGroupSize.z];

uint func(atomic_uint c)
{
    return atomicCounterIncrement(c);
}

void main()
{
    memoryBarrierAtomicCounter();
    func(counter);
    uint val = atomicCounter(countArr[2]);
    atomicCounterDecrement(counter);
    atomicCounterIncrement(counter);
}

shared int atomi;
shared uint atomu;

layout (std140, binding = 0) restrict buffer dataSSB
{
    float f;
    ivec4 n_frames_rendered;
} result;

void atoms()
{
    int origi = atomicAdd(atomi, 3);
    uint origu = atomicAnd(atomu, value);
    origu = atomicOr(atomu, 7u);
    origu = atomicXor(atomu, 7u);
    origu = atomicMin(atomu, value);
    origi = atomicMax(atomi, 7);
    origi = atomicExchange(atomi, origi);
    origu = atomicCompSwap(atomu, 10u, value);
    atomicAdd(result.n_frames_rendered.z, 1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicAdd.bufferReference.comp]=[
#version 450 core
#pragma use_vulkan_memory_model
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_shuffle : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_buffer_reference : enable
// DIM/NUM_WORKGROUP_EACH_DIM overriden by spec constants
layout(constant_id = 0) const int DIM = 1;
layout(constant_id = 1) const int NUM_WORKGROUP_EACH_DIM = 1;
shared bool sharedSkip;
layout(local_size_x_id = 0, local_size_y_id = 0, local_size_z = 1) in;
layout(buffer_reference) buffer PayloadRef { uint x[]; };
layout(buffer_reference) buffer GuardRef { uint x[]; };
layout(set=0, binding=2) buffer Fail { uint x[]; } fail;
layout (push_constant, std430) uniform PC {
   layout(offset = 0) PayloadRef payloadref;
layout(offset = 8) GuardRef guard;
};
void main()
{
   bool pass = true;
   bool skip = false;
   sharedSkip = false;
   nonprivate PayloadRef payload = payloadref;
   ivec2 globalId          = ivec2(gl_GlobalInvocationID.xy);
   ivec2 partnerGlobalId   = ivec2(DIM*NUM_WORKGROUP_EACH_DIM-1) - ivec2(gl_GlobalInvocationID.xy);
   uint bufferCoord        = globalId.y * DIM*NUM_WORKGROUP_EACH_DIM + globalId.x;
   uint partnerBufferCoord = partnerGlobalId.y * DIM*NUM_WORKGROUP_EACH_DIM + partnerGlobalId.x;
   ivec2 imageCoord        = globalId;
   ivec2 partnerImageCoord = partnerGlobalId;
   ivec2 globalId00          = ivec2(DIM) * ivec2(gl_WorkGroupID.xy);
   ivec2 partnerGlobalId00   = ivec2(DIM) * (ivec2(NUM_WORKGROUP_EACH_DIM-1) - ivec2(gl_WorkGroupID.xy));
   uint bufferCoord00        = globalId00.y * DIM*NUM_WORKGROUP_EACH_DIM + globalId00.x;
   uint partnerBufferCoord00 = partnerGlobalId00.y * DIM*NUM_WORKGROUP_EACH_DIM + partnerGlobalId00.x;
   ivec2 imageCoord00        = globalId00;
   ivec2 partnerImageCoord00 = partnerGlobalId00;
   payload.x[bufferCoord] = bufferCoord + (payload.x[partnerBufferCoord]>>31);
   controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable);
   if (all(equal(gl_LocalInvocationID.xy, ivec2(0,0)))) {
       atomicStore(guard.x[bufferCoord], uint(1u), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease | gl_SemanticsMakeAvailable);
       skip = atomicLoad(guard.x[partnerBufferCoord00], gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire | gl_SemanticsMakeVisible) == 0;
       sharedSkip = skip;
   }
   controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquireRelease | gl_SemanticsMakeVisible);
   skip = sharedSkip;
   uint r = payload.x[partnerBufferCoord];
   if (!skip && r != uint(partnerBufferCoord)) { fail.x[bufferCoord] = 1; }
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicCounter.comp]=[
#version 450
.
.

layout(binding = 0) uniform atomic_uint counter;

layout(binding = 0, offset = 4) uniform atomic_uint countArr[4];
shared uint value;

int arrX[gl_WorkGroupSize.x];
int arrY[gl_WorkGroupSize.y];
int arrZ[gl_WorkGroupSize.z];

uint func(atomic_uint c)
{
    return atomicCounterIncrement(c);
}

void main()
{
    memoryBarrierAtomicCounter();
    func(counter);
    uint val = atomicCounter(countArr[2]);
    atomicCounterDecrement(counter);
    atomicCounterIncrement(counter);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicFloat.comp]=[
#version 450 core

#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_shader_atomic_float: enable
#pragma use_vulkan_memory_model

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer Buffer
{
    float dataf;
    double datad;
} buf;

shared float  atomf;
shared double atomd;

layout(binding = 0, r32f) volatile coherent uniform image1D        fimage1D;
layout(binding = 1, r32f) volatile coherent uniform image1DArray   fimage1DArray;
layout(binding = 2, r32f) volatile coherent uniform image2D        fimage2D;
layout(binding = 3, r32f) volatile coherent uniform image2DArray   fimage2DArray;
layout(binding = 4, r32f) volatile coherent uniform image2DRect    fimage2DRect;
layout(binding = 5, r32f) volatile coherent uniform imageCube      fimageCube;
layout(binding = 6, r32f) volatile coherent uniform imageCubeArray fimageCubeArray;
layout(binding = 9, r32f) volatile coherent uniform image3D        fimage3D;

void main()
{
    //atomicAdd
    float resultf = 0;
    resultf = atomicAdd(atomf, 3.0);
    resultf = atomicAdd(atomf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultf = atomicAdd(buf.dataf, 3.0);
    resultf = atomicAdd(buf.dataf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    double resultd = 0;
    resultd = atomicAdd(atomd, 3.0);
    resultd = atomicAdd(atomd, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultd = atomicAdd(buf.datad, 3.0);
    resultd = atomicAdd(buf.datad, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicExchange
    resultf = atomicExchange(buf.dataf, resultf);
    buf.dataf += resultf;
    resultf = atomicExchange(buf.dataf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;
    resultf = atomicExchange(atomf, resultf);
    buf.dataf += resultf;
    resultf = atomicExchange(atomf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    resultd = atomicExchange(buf.datad, resultd);
    buf.datad += resultd;
    resultd = atomicExchange(buf.datad, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;
    resultd = atomicExchange(atomd, resultd);
    buf.datad += resultd;
    resultd = atomicExchange(atomd, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;

    //atomic load/store
    resultf = atomicLoad(buf.dataf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.dataf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    resultf = atomicLoad(atomf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(atomf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    resultd = atomicLoad(buf.datad, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.datad, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;

    resultd = atomicLoad(atomd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(atomd, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;

    // image atomics on 1D:
    atomf = imageAtomicAdd(fimage1D, int(0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage1D, int(1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage1D, int(1), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage1D, int(1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage1D, int(2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 1D Array:
    atomf = imageAtomicAdd(fimage1DArray, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage1DArray, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage1DArray, ivec2(1,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage1DArray, ivec2(1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage1DArray, ivec2(2,2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D:
    atomf = imageAtomicAdd(fimage2D, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage2D, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage2D, ivec2(1,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage2D, ivec2(1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage2D, ivec2(2,2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D Rect:
    atomf = imageAtomicAdd(fimage2DRect, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage2DRect, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage2DRect, ivec2(1,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage2DRect, ivec2(1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage2DRect, ivec2(2,2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D Array:
    atomf = imageAtomicAdd(fimage2DArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage2DArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage2DArray, ivec3(1,0,1), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage2DArray, ivec3(1,1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage2DArray, ivec3(2,2,0), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on Cube:
    atomf = imageAtomicAdd(fimageCube, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimageCube, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimageCube, ivec3(1,0,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimageCube, ivec3(1,1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimageCube, ivec3(2,2,1), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on Cube Array:
    atomf = imageAtomicAdd(fimageCubeArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimageCubeArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimageCubeArray, ivec3(1,0,1), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimageCubeArray, ivec3(1,1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimageCubeArray, ivec3(2,2,0), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 3D:
    atomf = imageAtomicAdd(fimage3D, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicAdd(fimage3D, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicExchange(fimage3D, ivec3(1,0,1), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicLoad(fimage3D, ivec3(1,1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;

    imageAtomicStore(fimage3D, ivec3(2,2,0), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicFloat2.comp]=[
#version 450 core

#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_atomic_float2: enable
#pragma use_vulkan_memory_model

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer Buffer
{
    float16_t datah;
    float dataf;
    double datad;
} buf;

shared float16_t    atomh;
shared float        atomf;
shared double       atomd;

layout(binding = 0, r32f) volatile coherent uniform image1D        fimage1D;
layout(binding = 1, r32f) volatile coherent uniform image1DArray   fimage1DArray;
layout(binding = 2, r32f) volatile coherent uniform image2D        fimage2D;
layout(binding = 3, r32f) volatile coherent uniform image2DArray   fimage2DArray;
layout(binding = 4, r32f) volatile coherent uniform image2DRect    fimage2DRect;
layout(binding = 5, r32f) volatile coherent uniform imageCube      fimageCube;
layout(binding = 6, r32f) volatile coherent uniform imageCubeArray fimageCubeArray;
layout(binding = 9, r32f) volatile coherent uniform image3D        fimage3D;

void main()
{
    //atomicAdd
    float16_t resulth = float16_t(0.0);
    resulth = atomicAdd(atomh, float16_t(3.0));
    resulth = atomicAdd(atomh, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resulth = atomicAdd(buf.datah, float16_t(3.0));
    resulth = atomicAdd(buf.datah, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicMin
    resulth = atomicMin(atomh, float16_t(3.0));
    resulth = atomicMin(atomh, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resulth = atomicMin(buf.datah, float16_t(3.0));
    resulth = atomicMin(buf.datah, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    float resultf = 0.0;
    resultf = atomicMin(atomf, 3.0);
    resultf = atomicMin(atomf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultf = atomicMin(buf.dataf, 3.0);
    resultf = atomicMin(buf.dataf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    double resultd = 0.0;
    resultd = atomicMin(atomd, 3.0);
    resultd = atomicMin(atomd, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultd = atomicMin(buf.datad, 3.0);
    resultd = atomicMin(buf.datad, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicMax
    resulth = atomicMax(atomh, float16_t(3.0));
    resulth = atomicMax(atomh, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resulth = atomicMax(buf.datah, float16_t(3.0));
    resulth = atomicMax(buf.datah, float16_t(4.5), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    resultf = atomicMax(atomf, 3.0);
    resultf = atomicMax(atomf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultf = atomicMax(buf.dataf, 3.0);
    resultf = atomicMax(buf.dataf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    resultd = atomicMax(atomd, 3.0);
    resultd = atomicMax(atomd, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultd = atomicMax(buf.datad, 3.0);
    resultd = atomicMax(buf.datad, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicExchange
    resulth = atomicExchange(buf.datah, resulth);
    buf.datah += resulth;
    resulth = atomicExchange(buf.datah, resulth, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datah += resulth;
    resulth = atomicExchange(atomh, resulth);
    buf.datah += resulth;
    resulth = atomicExchange(atomh, resulth, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datah += resulth;

    //atomic load/store
    resulth = atomicLoad(buf.datah, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.datah, resulth, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datah += resulth;

    resulth = atomicLoad(atomh, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(atomh, resulth, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datah += resulth;

    // image atomics on 1D:
    atomf = imageAtomicMin(fimage1D, int(0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage1D, int(1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage1D, int(0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage1D, int(1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 1D Array:
    atomf = imageAtomicMin(fimage1DArray, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage1DArray, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage1DArray, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage1DArray, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D:
    atomf = imageAtomicMin(fimage2D, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage2D, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage2D, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage2D, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D Rect:
    atomf = imageAtomicMin(fimage2DRect, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage2DRect, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage2DRect, ivec2(0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage2DRect, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 2D Array:
    atomf = imageAtomicMin(fimage2DArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage2DArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage2DArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage2DArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on Cube:
    atomf = imageAtomicMin(fimageCube, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimageCube, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimageCube, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimageCube, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on Cube Array:
    atomf = imageAtomicMin(fimageCubeArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimageCubeArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimageCubeArray, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimageCubeArray, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    // image atomics on 3D:
    atomf = imageAtomicMin(fimage3D, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMin(fimage3D, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;

    atomf = imageAtomicMax(fimage3D, ivec3(0,0,0), 2.0);
    buf.dataf += atomf;
    atomf = imageAtomicMax(fimage3D, ivec3(1,1,0), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    buf.dataf += atomf;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicFloat_Error.comp]=[
#version 450 core
#extension GL_KHR_memory_scope_semantics : enable
#pragma use_vulkan_memory_model

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer Buffer
{
    int    datai;
    float  dataf;
    double datad;
} buf;

shared int    atomi;
shared float  atomf;
shared double atomd;

layout(binding = 0, r32f) volatile coherent uniform image1D fimage1D;
layout(binding = 1, r32f) volatile coherent uniform image2D fimage2D;

void undeclared_errors()
{
    //atomicAdd
    float resultf = 0;
    resultf = atomicAdd(atomf, 3.0);
    resultf = atomicAdd(atomf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultf = atomicAdd(buf.dataf, 3.0);
    resultf = atomicAdd(buf.dataf, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    double resultd = 0;
    resultd = atomicAdd(atomd, 3.0);
    resultd = atomicAdd(atomd, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultd = atomicAdd(buf.datad, 3.0);
    resultd = atomicAdd(buf.datad, 4.5, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicExchange
    resultf = atomicExchange(buf.dataf, resultf);
    resultf = atomicExchange(buf.dataf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultf = atomicExchange(atomf, resultf);
    resultf = atomicExchange(atomf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    resultd = atomicExchange(buf.datad, resultd);
    resultd = atomicExchange(buf.datad, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultd = atomicExchange(atomd, resultd);
    resultd = atomicExchange(atomd, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;

    //atomic load/store
    resultf = atomicLoad(buf.dataf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.dataf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultf = atomicLoad(atomf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(atomf, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    resultd = atomicLoad(buf.datad, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.datad, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultd = atomicLoad(atomd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(atomd, resultd, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.datad += resultd;

    // image atomics:
    atomf = imageAtomicAdd(fimage2D, ivec2(0,0), 2.0);
    atomf = imageAtomicAdd(fimage2D, ivec2(1,1), 3.0, gl_ScopeDevice, gl_StorageSemanticsImage , gl_SemanticsRelaxed);
    atomf = imageAtomicExchange(fimage2D, ivec2(1,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicLoad(fimage2D, ivec2(1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(fimage2D, ivec2(2,2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;
}

#extension GL_EXT_shader_atomic_float: enable

void main()
{
    float resultf = 0;
    double resultd = 0;
    int resulti = 0;

    //atomicAdd
    resultf = atomicAdd(atomi);
    resultf = atomicAdd(atomi, 3.0);
    resultf = atomicAdd(atomi, resultf, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    resultf = atomicAdd(atomi, resultf, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);

    //atomicExchange
    resultf = atomicExchange(buf.datai);
    resultf = atomicExchange(buf.datai, resultf);
    resultf = atomicExchange(buf.datai, resultf, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultf = atomicExchange(buf.datai, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    resultf = atomicExchange(atomi, resultf);
    resultf = atomicExchange(atomi, resultf, gl_ScopeDevice, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    buf.dataf += resultf;

    //atomic load/store
    resultf = atomicLoad(buf.datai, gl_StorageSemanticsShared, gl_SemanticsRelaxed);
    atomicStore(buf.datai, resulti, gl_StorageSemanticsShared, gl_SemanticsRelaxed);

    // image atomics:
    atomf = imageAtomicAdd(fimage1D, ivec2(0,0), 2.0);
    atomf = imageAtomicAdd(fimage2D, ivec3(0,0,0), 2.0);
    atomf = imageAtomicAdd(fimage2D, 2.0);
    atomf = imageAtomicExchange(fimage1D, ivec2(1,0), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicExchange(fimage2D, 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicExchange(fimage2D, ivec3(1,0,1), 4.0, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicLoad(fimage1D, ivec2(1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicLoad(fimage2D, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    atomf = imageAtomicLoad(fimage2D, ivec3(1,1,1), gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(fimage1D, ivec2(2,2), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(fimage2D, atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(fimage2D, ivec3(2,2,1), atomf, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    buf.dataf += atomf;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicInt64.comp]=[
#version 450 core

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_NV_shader_atomic_int64: enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer Buffer
{
    int64_t  i64;
    uint64_t u64;
} buf;

struct Struct
{
    int64_t  i64;
    uint64_t u64;
};

shared Struct s;

void main()
{
    const int64_t  i64c = -24;
    const uint64_t u64c = 0xF00000000Ful; 

    // Test shader storage block
    int64_t  i64 = 0;
    uint64_t u64 = 0;

    i64 += atomicMin(buf.i64, i64c);
    u64 += atomicMin(buf.u64, u64c);

    i64 += atomicMax(buf.i64, i64c);
    u64 += atomicMax(buf.u64, u64c);

    i64 += atomicAnd(buf.i64, i64c);
    u64 += atomicAnd(buf.u64, u64c);

    i64 += atomicOr(buf.i64, i64c);
    u64 += atomicOr(buf.u64, u64c);

    i64 += atomicXor(buf.i64, i64c);
    u64 += atomicXor(buf.u64, u64c);

    i64 += atomicAdd(buf.i64, i64c);
    i64 += atomicExchange(buf.i64, i64c);
    i64 += atomicCompSwap(buf.i64, i64c, i64);

    buf.i64 = i64;
    buf.u64 = u64;

    // Test shared variable
    i64 = 0;
    u64 = 0;

    i64 += atomicMin(s.i64, i64c);
    u64 += atomicMin(s.u64, u64c);

    i64 += atomicMax(s.i64, i64c);
    u64 += atomicMax(s.u64, u64c);

    i64 += atomicAnd(s.i64, i64c);
    u64 += atomicAnd(s.u64, u64c);

    i64 += atomicOr(s.i64, i64c);
    u64 += atomicOr(s.u64, u64c);

    i64 += atomicXor(s.i64, i64c);
    u64 += atomicXor(s.u64, u64c);

    i64 += atomicAdd(s.i64, i64c);
    i64 += atomicExchange(s.i64, i64c);
    i64 += atomicCompSwap(s.i64, i64c, i64);

    s.i64 = i64;
    s.u64 = u64;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.atomicStoreInt64.comp]=[
#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_KHR_memory_scope_semantics : enable

layout(set = 0, binding = 0) buffer ssbo { uint64_t y; };
layout(set = 0, binding = 1) uniform ubo { uint64_t z; };

void main() {
    atomicStore(y, z, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.barrier.vert]=[
#version 450

layout(location=0) out vec4 c0;
layout(location=1) out vec4 c1;

void main()
{
    c0 = vec4(1.0);
    memoryBarrier();
    c1 = vec4(1.0);
    memoryBarrierBuffer();
    ++c0;
    memoryBarrierImage();
    ++c0;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bitCast.frag]=[
#version 450

flat in int   i1;
flat in ivec2 i2;
flat in ivec3 i3;
flat in ivec4 i4;

flat in uint  u1;
flat in uvec2 u2;
flat in uvec3 u3;
flat in uvec4 u4;

in float f1;
in vec2  f2;
in vec3  f3;
in vec4  f4;

out vec4 fragColor;

void main()
{
	ivec4 idata = ivec4(0);
	idata.x     += floatBitsToInt(f1);
	idata.xy    += floatBitsToInt(f2);
	idata.xyz   += floatBitsToInt(f3);
	idata       += floatBitsToInt(f4);

	uvec4 udata = uvec4(0);
	udata.x     += floatBitsToUint(f1);
	udata.xy    += floatBitsToUint(f2);
	udata.xyz   += floatBitsToUint(f3);
	udata       += floatBitsToUint(f4);

	vec4 fdata = vec4(0.0);
	fdata.x     += intBitsToFloat(i1);
	fdata.xy    += intBitsToFloat(i2);
	fdata.xyz   += intBitsToFloat(i3);
	fdata       += intBitsToFloat(i4);
    fdata.x     += uintBitsToFloat(u1);
	fdata.xy    += uintBitsToFloat(u2);
	fdata.xyz   += uintBitsToFloat(u3);
	fdata       += uintBitsToFloat(u4);

    fragColor = (idata == udata) ? fdata : fdata + vec4(0.2);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bool.vert]=[
#version 450

const bool condition = false;

uniform ubname {
    bool b;
} ubinst;

bool foo(bool b)
{
	return b != condition;
}

void main()
{
    gl_Position = foo(ubinst.b) ? vec4(0.0) : vec4(1.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.boolInBlock.frag]=[
#version 450

layout(binding = 0, std140) uniform Uniform
{
    bvec4 b4;
};

layout(binding = 1, std430) buffer Buffer
{
    bvec2 b2;
};

void foo(bvec4 paramb4, out bvec2 paramb2)
{
    bool b1 = paramb4.z;
    paramb2 = bvec2(b1);
}

layout(location = 0) out vec4 fragColor;

void main()
{
    b2 = bvec2(0.0);
    if (b4.z)
        b2 = bvec2(b4.x);
    if (b2.x)
        foo(b4, b2);

    fragColor  = vec4(b4.x && b4.y);
    fragColor -= vec4(b4.x || b4.y);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.branch-return.vert]=[
#version 310 es
void main() {
  switch (gl_InstanceIndex) {
    case 0: return;
    case 1: gl_Position = vec4(0.0); break;
    case 2: return;
    case 3: return;
  }
  gl_Position.x += 0.123;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.buffer.autoassign.frag]=[

cbuffer MyUB1 : register(b5)  // explicitly assigned & offsetted
{
    float g_a;
    int g_b;
};

cbuffer MyUB2  // implicitly assigned
{
    float g_c;
};

cbuffer MyUB3  // implicitly assigned
{
    float g_d;
};

struct PS_OUTPUT
{
    float4 Color : SV_Target0;
};

PS_OUTPUT main()
{
    PS_OUTPUT psout;
    psout.Color = g_a + g_b + g_c + g_d;
    return psout;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
2:14; [@5,15:15=':',<COLON>,2:14]; no viable alternative at input 'cbuffer MyUB1 :'; NoViableAltException:null
6:0; [@27,96:96='}',<'}'>,6:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
9:0; [@36,138:138='{',<'{'>,9:0]; no viable alternative at input 'cbuffer MyUB2  // implicitly assigned\n{'; NoViableAltException:null
11:0; [@44,155:155='}',<'}'>,11:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
14:0; [@53,197:197='{',<'{'>,14:0]; no viable alternative at input 'cbuffer MyUB3  // implicitly assigned\n{'; NoViableAltException:null
16:0; [@61,214:214='}',<'}'>,16:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
20:17; [@76,254:254=':',<COLON>,20:17]; no viable alternative at input 'struct PS_OUTPUT\n{\n    float4 Color :'; NoViableAltException:null
21:0; [@81,268:268='}',<'}'>,21:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[spv.bufferhandle1.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable
#pragma use_vulkan_memory_model

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
    layout(offset = 32) int f[2];
    coherent layout(offset = 48) ivec4 g;
};

layout(std430) buffer t2 {
    blockType f;
    blockType g;
} t;

void main() {
    t.f.b = t.g.a;

    blockType j = t.f;
    j.d = j.c;
    j.d = j.f[1];
    j.d = j.g.y;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle10.frag]=[
#version 450

#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer blockType {
    uint x[];
};

layout(std430) buffer t2 {
    blockType f;
} t;

layout(location = 0) flat in uint i;

void main() {

    atomicAdd(t.f.x[i], 1);

    coherent blockType b = t.f;
    b.x[0] = 2;

    volatile blockType b2 = t.f;
    b2.x[0] = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle11.frag]=[
#version 450
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable
#extension GL_EXT_buffer_reference : enable

layout(std140, binding = 0) buffer AcBlock { highp uint ac_numPassed; };

layout(std140, buffer_reference) buffer Block
{
	uint8_t var;
};
layout (push_constant, std430) uniform PC {
	Block block;
};

bool compare_uint8_t  (highp uint a, highp uint b)    { return a == b; }

void main (void)
{
	bool allOk = true;
	allOk = allOk && compare_uint8_t(uint(block.var), 7u);
	if (allOk)
		ac_numPassed++;

	block.var = uint8_t(9u);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle12.frag]=[
#version 450
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_8bit_storage : enable
#extension GL_EXT_buffer_reference : enable

layout(std140, binding = 0) buffer AcBlock { highp uint ac_numPassed; };

layout(std430, column_major, buffer_reference) buffer BlockB
{
	float16_t a;
	highp ivec2 b;
};
layout(std430, buffer_reference) buffer BlockC
{
	mediump mat2x3 c;
};
layout(std430, row_major, buffer_reference) buffer BlockD
{
	lowp uvec3 d;
};
layout (push_constant, std430) uniform PC {
	BlockB blockB;
	BlockC blockC;
	BlockD blockD;
};

bool compare_float    (highp float a, highp float b)  { return abs(a - b) < 0.05; }
bool compare_vec3     (highp vec3 a, highp vec3 b)    { return compare_float(a.x, b.x)&&compare_float(a.y, b.y)&&compare_float(a.z, b.z); }
bool compare_mat2x3   (highp mat2x3 a, highp mat2x3 b){ return compare_vec3(a[0], b[0])&&compare_vec3(a[1], b[1]); }
bool compare_ivec2    (highp ivec2 a, highp ivec2 b)  { return a == b; }
bool compare_uvec3    (highp uvec3 a, highp uvec3 b)  { return a == b; }
bool compare_float16_t(highp float a, highp float b)  { return abs(a - b) < 0.05; }

void main (void)
{
	bool allOk = true;
	allOk = allOk && compare_mat2x3(blockC.c, mat2x3(-5.0, 1.0, -7.0, 1.0, 2.0, 8.0));
	if (allOk)
		ac_numPassed++;

	blockD.d = (uvec3(8u, 1u, 5u));
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle13.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(set = 1, binding = 2, buffer_reference, std430) buffer t4 {
    layout(offset = 0)  int j;
};

layout(std430) buffer t5 {
    t4 m;
} s5;

t4 f1(const t4 y) { return y; }
t4 f2(t4 y) { return y; }
t4 f3(const restrict t4 y) { return y; }
t4 f4(restrict t4 y) { return y; }

t4 g1;
restrict t4 g2;

void main()
{
    t4 a = s5.m;
    restrict t4 b = s5.m;

    f1(a);
    f2(a);
    f3(a);
    f4(a);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle14.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430, buffer_reference_align = 4) buffer T1 {
    int i;
    int j;
    int k;
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer T2 {
    int i;
    int j;
    int k;
};

layout(buffer_reference, std430) buffer T3 {
    int i;
    int j;
    int k;
};

layout(buffer_reference, std430, buffer_reference_align = 32) buffer T4 {
    int i;
    int j;
    int k;
};

void main()
{
    T1 t1;
    T2 t2;
    T3 t3;
    T4 t4;

    t1.i = t1.k;
    t2.i = t2.k;
    t3.i = t3.k;
    t4.i = t4.k;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle15.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_scalar_block_layout : enable

layout(buffer_reference, scalar) buffer T1 {
    vec3 x[];
};

layout(buffer_reference, scalar) buffer T2 {
	vec3 x[][4][2];
};

struct S
{
	highp ivec3 a;
	mediump mat3 b[4];
	highp vec4 c;
};

layout(buffer_reference, scalar) buffer T3 {
    S s;
};
layout(std430) buffer T4 {
    T1 t1;
    T2 t2;
    T3 t3;
} t4;

layout(location = 0) flat in int i;

void main()
{
    vec3 y;
    y = t4.t1.x[i];
    y = t4.t2.x[i][i][i];
    mat3 z = t4.t3.s.b[0];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle16.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_scalar_block_layout : enable

layout(buffer_reference) buffer T1 {
    int x;
    bool y;
};
layout(buffer_reference) buffer T2 {
    int x;
};

const int s = int(uint64_t(T1(T2(uint64_t(3)))));
int x[s];
const uint64_t t = uint64_t(true ? T2(uint64_t(10)) : T2(uint64_t(11)));

void main()
{
    T1 a = T1(uint64_t(4)), b = T1(uint64_t(5));
    T1 c = true ? a : b;
    T1 d = (a,b);
    T1 e = true ? T1(uint64_t(6)) : T1(uint64_t(7));
    T1 f = a.y ? T1(uint64_t(8)) : T1(uint64_t(9));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle17_Errors.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_scalar_block_layout : enable

layout(buffer_reference) buffer T1 {
    int x;
};

const T1 a = T1(uint64_t(2));

void main()
{
    T1 b, c;
    const T1 d = b;

    b == c;
    b != c;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle18.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable

layout(buffer_reference, buffer_reference_align = 8) buffer T1 {
    int x;
    bool y;
};
layout(buffer_reference, buffer_reference_align = 64) buffer T2 {
    int x;
};

const int s = int(uint64_t(T1(T2(uint64_t(3)))));
int x[s];
const uint64_t t = uint64_t(true ? T2(uint64_t(10)) : T2(uint64_t(11)));
.
.
#define sizeof(T) (uint64_t(T(uint64_t(0))+1))

const uint64_t s2 = sizeof(T1);
uint buf[int(s2)];
.
.
void main()
{
    T1 a = T1(uint64_t(4)), b = T1(uint64_t(5));
    T1 c = true ? a : b;
    T1 d = (a,b);
    T1 e = true ? T1(uint64_t(6)) : T1(uint64_t(7));
    T1 f = a.y ? T1(uint64_t(8)) : T1(uint64_t(9));

    f[3].x = 1;
    (f+5).x = 1;

    T1 arr[2] = {a, f};
    arr[1][7].x = 1;
    int i;
    arr[i][i].x = 1;
    // Since we don't distinguish between "pointer" and "reference" type,
    // a reference type can have [] applied to it repeatedly and it has
    // the effect of adding up the indices.
    arr[i][i][i][i][i][i][i].x = 1;

    T1 j;
    j = j+1;
    j = j-2;
    j += 3;
    j -= 4;
    j = 5+j;
    T1 k = j + 6;
    int64_t x = k - j;
    uint64_t y = sizeof(T1);
    k = k + (-1);

    T2 m;
    m = m+1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle19_Errors.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable

layout(buffer_reference) buffer T1 {
    int x[];
};

layout(buffer_reference) buffer T2 {
    int x[2];
};

void main()
{
    T1 a;
    a+1;
    a-1;
    1+a;
    a-a;
    a+=1;
    a-=1;
    a+=a;
    a-=a;

    T2 b;
    b+=b;
    b-=b;
    b+b;
    1-b;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle2.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
};

layout(std430) buffer t2 {
    blockType f;
    blockType g;
} t;

void main() {

    blockType b1[2] = blockType[2](t.f, t.g);
    b1[0].a = b1[1].b;
    blockType b2 = t.f;
    blockType b3 = t.g;
    b2.a = b3.b;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle3.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer t3 {
    int h;
};

layout(set = 1, binding = 2, buffer_reference, std430) buffer t4 {
    layout(offset = 0)  int j;
    t3 k;
} x;

layout(std430) buffer t5 {
    t4 m;
} s5;

flat in t4 k;

t4 foo(t4 y) { return y; }

void main() {
    foo(s5.m).j = s5.m.k.h;
    x.j = k.k.h;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle4.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference) buffer t4;

layout(buffer_reference, std430) buffer t3 {
    int h;
    t4 i;
};

layout(set = 1, binding = 2, buffer_reference, std430) buffer t4 {
    layout(offset = 0)  int j;
    t3 k;
} x;

layout(std430) buffer t5 {
    t4 m;
} s5;

void main() {
    x.k.h = s5.m.k.i.k.i.k.h;

    bool b = true;
    s5.m = b ? s5.m : s5.m.k.i;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle5.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std140) buffer t3 {
    int h;
};

layout(set = 1, binding = 2, std140) uniform t4 {
    layout(offset = 0)  int j;
    t3 k;
} x;

void main() {
    x.k.h = x.j;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle6.frag]=[
#version 450 core

#extension GL_EXT_buffer_reference : enable
layout (push_constant, std430) uniform Block { int identity[32]; } pc;
layout(r32ui, set = 3, binding = 0) uniform uimage2D image0_0;
layout(buffer_reference) buffer T1;
layout(set = 3, binding = 1, buffer_reference) buffer T1 {
   layout(offset = 0) int a[2]; // stride = 4 for std430, 16 for std140
   layout(offset = 32) int b;
   layout(offset = 48) T1  c[2]; // stride = 8 for std430, 16 for std140
   layout(offset = 80) T1  d;
} x;
void main()
{
  int accum = 0, temp;
   accum |= x.a[0] - 0;
   accum |= x.a[pc.identity[1]] - 1;
   accum |= x.b - 2;
   accum |= x.c[0].a[0] - 3;
   accum |= x.c[0].a[pc.identity[1]] - 4;
   accum |= x.c[0].b - 5;
   accum |= x.c[pc.identity[1]].a[0] - 6;
   accum |= x.c[pc.identity[1]].a[pc.identity[1]] - 7;
   accum |= x.c[pc.identity[1]].b - 8;
   accum |= x.d.a[0] - 9;
   accum |= x.d.a[pc.identity[1]] - 10;
   accum |= x.d.b - 11;
  uvec4 color = (accum != 0) ? uvec4(0,0,0,0) : uvec4(1,0,0,1);
  imageStore(image0_0, ivec2(gl_FragCoord.x, gl_FragCoord.y), color);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle7.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
};

layout(std430, buffer_reference) buffer t2 {
    blockType f;
    blockType g;
} t;

layout(std430) buffer t3 {
    t2 f;
} u;

void main() {
    t.f = blockType(u.f);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle8.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
};

layout(std430) buffer t2 {
    blockType f;
    blockType g;
} t;

layout(std430, buffer_reference) buffer T2 { int x; };
layout(std430, buffer_reference) buffer T1 { int x; };

struct Blah {
    T1 t1;
    T2 t2;
};

layout(set=0, binding=0) buffer T3 {
  Blah Bindings[];
} t3;

void main() {
    t3.Bindings[0] = t3.Bindings[1];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle9.frag]=[
#version 450

#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_buffer_reference : enable

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
};

layout(std430) buffer t2 {
    blockType f;
    blockType g;
} t;

flat in uint64_t h, i;

void main() {

    blockType b1[2] = blockType[2](blockType(h), blockType(i));
    b1[0].a = b1[1].b;
    blockType b2 = blockType(h);
    blockType b3 = blockType(i);
    b2.a = b3.b;
    uint64_t j = uint64_t(b2);
    b2 = blockType(j+256);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandleUvec2.frag]=[
#version 450

#extension GL_EXT_buffer_reference_uvec2 : enable

layout(buffer_reference, std430) buffer blockType {
    layout(offset = 0)  int a;
    layout(offset = 4)  int b;
    layout(offset = 8)  int c;
    layout(offset = 12) int d;
    layout(offset = 16) int e;
};

layout(std430) buffer t2 {
    blockType f;
    blockType g;
} t;

flat in uvec2 h, i;

void main() {

    blockType b1[2] = blockType[2](blockType(h), blockType(i));
    b1[0].a = b1[1].b;
    blockType b2 = blockType(h);
    blockType b3 = blockType(i);
    b2.a = b3.b;
    uvec2 j = uvec2(b2);
    uint carry;
    j.x = uaddCarry(j.x, 256, carry);
    j.y += carry;
    b2 = blockType(j);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.bufferhandle_Error.frag]=[
#version 450

#extension GL_EXT_buffer_reference : enable

layout(buffer_reference) buffer bufType1 { int x; };
layout(buffer_reference) buffer bufType2 { int x; };
layout(buffer_reference) uniform bufType3 { int x; };

layout(buffer_reference) buffer;
layout(buffer_reference) uniform;
layout(buffer_reference) in;
layout(buffer_reference) out;
layout(buffer_reference) in badin { float x; } badin2;
layout(buffer_reference) out badout { float x; } badout2;

layout(buffer_reference) buffer bufType5;

layout(buffer_reference) buffer bufType6 { int x[]; };

buffer bufType4 {
    bufType1 b1;
    bufType2 b2;
    bufType3 b3;
    bufType6 b6;
} b4;

void f()
{
    bufType6 b;
    b.x.length();
    b4.b6.x.length();
    b[2];               // ERROR, can't index due to unsized array
}

void main() {
    bufType2 x1 = b4.b1;
    bufType2 x2 = bufType2(b4.b1);
    bufType2 x3 = bufType2(b4.b2);
    bufType2 x4 = bufType2(b4.b3);

    b4.b1 = b4.b2;
    b4.b1 = b4.b3;
    b4.b3 = b4.b2;
}

layout(buffer_reference) uniform bufType5 { int x; };

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.builtInXFB.vert]=[
#version 450

layout(xfb_buffer = 1, xfb_stride = 64) out;

layout (xfb_buffer = 1, xfb_offset = 16) out gl_PerVertex
{
    float gl_PointSize;
    vec4 gl_Position;
};

void main()
{
    gl_Position = vec4(1.0);
    gl_PointSize = 2.0;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.builtin.PrimitiveShadingRateEXT.vert]=[
#version 450

#extension GL_EXT_fragment_shading_rate : enable

layout(location = 0) in int id;

void main()
{
    switch (id)
    {
    case 0:
        // V2 | H2 => 5
        gl_PrimitiveShadingRateEXT = gl_ShadingRateFlag2VerticalPixelsEXT | gl_ShadingRateFlag2HorizontalPixelsEXT;
        break;
    case 1:
        // V2 | H4 => 9
        gl_PrimitiveShadingRateEXT = gl_ShadingRateFlag2VerticalPixelsEXT | gl_ShadingRateFlag4HorizontalPixelsEXT;
        break;
    case 2:
        // V4 | H2 => 6
        gl_PrimitiveShadingRateEXT = gl_ShadingRateFlag4VerticalPixelsEXT | gl_ShadingRateFlag2HorizontalPixelsEXT;
        break;
    case 3:
        // V4 | H4 => 10
        gl_PrimitiveShadingRateEXT = gl_ShadingRateFlag4VerticalPixelsEXT | gl_ShadingRateFlag4HorizontalPixelsEXT;
        break;
    }
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.builtin.ShadingRateEXT.frag]=[
#version 450

#extension GL_EXT_fragment_shading_rate : enable

out highp int val;
void main () {
    val = gl_ShadingRateEXT;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.computeShaderDerivatives.comp]=[
#version 450
#extension GL_NV_compute_shader_derivatives : require

layout (local_size_x = 2, local_size_y = 4) in;
layout(derivative_group_quadsNV) in;

buffer block {
  float fDerivativeX;
  float fDerivativeY;
  float fDerivativeWidth;
  float fCoarseDerivativeX;
  float fCoarseDerivativeY;
  float fCoarseDerivativeWidth;
  float fFineDerivativeX;
  float fFineDerivativeY;
  float fFineDerivativeWidth;
  
  float fX;
  float fY;
  
  
  vec2 v2DerivativeX;
  vec2 v2DerivativeY;
  vec2 v2DerivativeWidth;
  vec2 v2CoarseDerivativeX;
  vec2 v2CoarseDerivativeY;
  vec2 v2CoarseDerivativeWidth;
  vec2 v2FineDerivativeX;
  vec2 v2FineDerivativeY;
  vec2 v2FineDerivativeWidth;
  
  vec2 v2X;
  vec2 v2Y;
  
  
  vec3 v3DerivativeX;
  vec3 v3DerivativeY;
  vec3 v3DerivativeWidth;
  vec3 v3CoarseDerivativeX;
  vec3 v3CoarseDerivativeY;
  vec3 v3CoarseDerivativeWidth;
  vec3 v3FineDerivativeX;
  vec3 v3FineDerivativeY;
  vec3 v3FineDerivativeWidth;
  
  vec3 v3X;
  vec3 v3Y;
  
  
  vec4 v4DerivativeX;
  vec4 v4DerivativeY;
  vec4 v4DerivativeWidth;
  vec4 v4CoarseDerivativeX;
  vec4 v4CoarseDerivativeY;
  vec4 v4CoarseDerivativeWidth;
  vec4 v4FineDerivativeX;
  vec4 v4FineDerivativeY;
  vec4 v4FineDerivativeWidth;
  
  vec4 v4X;
  vec4 v4Y;
};

void main(){
    fDerivativeX = dFdx(fX);
    fDerivativeY = dFdy(fY);
    fDerivativeWidth = fwidth(fX);
    fCoarseDerivativeX = dFdxCoarse(fX);
    fCoarseDerivativeY = dFdyCoarse(fY);
    fCoarseDerivativeWidth = fwidthCoarse(fX);
    fFineDerivativeX = dFdxFine(fX);
    fFineDerivativeY = dFdyFine(fY);
    fFineDerivativeWidth = fwidthFine(fX);

    v2DerivativeX = dFdx(v2X);
    v2DerivativeY = dFdy(v2Y);
    v2DerivativeWidth = fwidth(v2X);
    v2CoarseDerivativeX = dFdxCoarse(v2X);
    v2CoarseDerivativeY = dFdyCoarse(v2Y);
    v2CoarseDerivativeWidth = fwidthCoarse(v2X);
    v2FineDerivativeX = dFdxFine(v2X);
    v2FineDerivativeY = dFdyFine(v2Y);
    v2FineDerivativeWidth = fwidthFine(v2X);
.
.
    v3DerivativeX = dFdx(v3X);
    v3DerivativeY = dFdy(v3Y);
    v3DerivativeWidth = fwidth(v3X);
    v3CoarseDerivativeX = dFdxCoarse(v3X);
    v3CoarseDerivativeY = dFdyCoarse(v3Y);
    v3CoarseDerivativeWidth = fwidthCoarse(v3X);
    v3FineDerivativeX = dFdxFine(v3X);
    v3FineDerivativeY = dFdyFine(v3Y);
    v3FineDerivativeWidth = fwidthFine(v3X);
.
.
    v4DerivativeX = dFdx(v4X);
    v4DerivativeY = dFdy(v4Y);
    v4DerivativeWidth = fwidth(v4X);
    v4CoarseDerivativeX = dFdxCoarse(v4X);
    v4CoarseDerivativeY = dFdyCoarse(v4Y);
    v4CoarseDerivativeWidth = fwidthCoarse(v4X);
    v4FineDerivativeX = dFdxFine(v4X);
    v4FineDerivativeY = dFdyFine(v4Y);
    v4FineDerivativeWidth = fwidthFine(v4X);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.computeShaderDerivatives2.comp]=[
#version 320 es
#extension GL_NV_compute_shader_derivatives : require

layout (local_size_x = 2, local_size_y = 4) in;
layout(derivative_group_linearNV) in;

buffer block {
  float fDerivativeX;
  float fDerivativeY;
  float fDerivativeWidth;
  float fCoarseDerivativeX;
  float fCoarseDerivativeY;
  float fCoarseDerivativeWidth;
  float fFineDerivativeX;
  float fFineDerivativeY;
  float fFineDerivativeWidth;
  
  float fX;
  float fY;
  
  
  vec2 v2DerivativeX;
  vec2 v2DerivativeY;
  vec2 v2DerivativeWidth;
  vec2 v2CoarseDerivativeX;
  vec2 v2CoarseDerivativeY;
  vec2 v2CoarseDerivativeWidth;
  vec2 v2FineDerivativeX;
  vec2 v2FineDerivativeY;
  vec2 v2FineDerivativeWidth;
  
  vec2 v2X;
  vec2 v2Y;
  
  
  vec3 v3DerivativeX;
  vec3 v3DerivativeY;
  vec3 v3DerivativeWidth;
  vec3 v3CoarseDerivativeX;
  vec3 v3CoarseDerivativeY;
  vec3 v3CoarseDerivativeWidth;
  vec3 v3FineDerivativeX;
  vec3 v3FineDerivativeY;
  vec3 v3FineDerivativeWidth;
  
  vec3 v3X;
  vec3 v3Y;
  
  
  vec4 v4DerivativeX;
  vec4 v4DerivativeY;
  vec4 v4DerivativeWidth;
  vec4 v4CoarseDerivativeX;
  vec4 v4CoarseDerivativeY;
  vec4 v4CoarseDerivativeWidth;
  vec4 v4FineDerivativeX;
  vec4 v4FineDerivativeY;
  vec4 v4FineDerivativeWidth;
  
  vec4 v4X;
  vec4 v4Y;
};

void main(){
    fDerivativeX = dFdx(fX);
    fDerivativeY = dFdy(fY);
    fDerivativeWidth = fwidth(fX);
    fCoarseDerivativeX = dFdxCoarse(fX);
    fCoarseDerivativeY = dFdyCoarse(fY);
    fCoarseDerivativeWidth = fwidthCoarse(fX);
    fFineDerivativeX = dFdxFine(fX);
    fFineDerivativeY = dFdyFine(fY);
    fFineDerivativeWidth = fwidthFine(fX);

    v2DerivativeX = dFdx(v2X);
    v2DerivativeY = dFdy(v2Y);
    v2DerivativeWidth = fwidth(v2X);
    v2CoarseDerivativeX = dFdxCoarse(v2X);
    v2CoarseDerivativeY = dFdyCoarse(v2Y);
    v2CoarseDerivativeWidth = fwidthCoarse(v2X);
    v2FineDerivativeX = dFdxFine(v2X);
    v2FineDerivativeY = dFdyFine(v2Y);
    v2FineDerivativeWidth = fwidthFine(v2X);
.
.
    v3DerivativeX = dFdx(v3X);
    v3DerivativeY = dFdy(v3Y);
    v3DerivativeWidth = fwidth(v3X);
    v3CoarseDerivativeX = dFdxCoarse(v3X);
    v3CoarseDerivativeY = dFdyCoarse(v3Y);
    v3CoarseDerivativeWidth = fwidthCoarse(v3X);
    v3FineDerivativeX = dFdxFine(v3X);
    v3FineDerivativeY = dFdyFine(v3Y);
    v3FineDerivativeWidth = fwidthFine(v3X);
.
.
    v4DerivativeX = dFdx(v4X);
    v4DerivativeY = dFdy(v4Y);
    v4DerivativeWidth = fwidth(v4X);
    v4CoarseDerivativeX = dFdxCoarse(v4X);
    v4CoarseDerivativeY = dFdyCoarse(v4Y);
    v4CoarseDerivativeWidth = fwidthCoarse(v4X);
    v4FineDerivativeX = dFdxFine(v4X);
    v4FineDerivativeY = dFdyFine(v4Y);
    v4FineDerivativeWidth = fwidthFine(v4X);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.conditionalDemote.frag]=[
#version 460 core
#extension GL_EXT_demote_to_helper_invocation : enable

layout(set = 0, binding = 0) uniform sampler2D tex;
layout(location = 0) in vec2 coord;
layout(location = 0) out vec4 o;

void main (void)
{
    vec4 v = texture(tex, coord);

    if (v == vec4(0.1,0.2,0.3,0.4))
        demote;

    bool x = helperInvocationEXT();

    o = v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.conditionalDiscard.frag]=[
#version 400

uniform sampler2D tex;
in vec2 coord;

void main (void)
{
    vec4 v = texture(tex, coord);

    if (v == vec4(0.1,0.2,0.3,0.4))
        discard;

    gl_FragColor = v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.constConstruct.vert]=[
#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

precision highp float;

void main()
{
    float16_t(float16_t(0x1));
    float16_t(float32_t(0x2));
    float16_t(float64_t(0x3));
    float16_t(int8_t   (0x4));
    float16_t(int16_t  (0x5));
    float16_t(int32_t  (0x6));
    float16_t(int64_t  (0x7));
    float16_t(uint8_t  (0x8));
    float16_t(uint16_t (0x9));
    float16_t(uint32_t (0xA));
    float16_t(uint64_t (0xB));
    float16_t(bool     (0xC));
    float32_t(float16_t(0x11));
    float32_t(float32_t(0x12));
    float32_t(float64_t(0x13));
    float32_t(int8_t   (0x14));
    float32_t(int16_t  (0x15));
    float32_t(int32_t  (0x16));
    float32_t(int64_t  (0x17));
    float32_t(uint8_t  (0x18));
    float32_t(uint16_t (0x19));
    float32_t(uint32_t (0x1A));
    float32_t(uint64_t (0x1B));
    float32_t(bool     (0x1C));
    float64_t(float16_t(0x21));
    float64_t(float32_t(0x22));
    float64_t(float64_t(0x23));
    float64_t(int8_t   (0x24));
    float64_t(int16_t  (0x25));
    float64_t(int32_t  (0x26));
    float64_t(int64_t  (0x27));
    float64_t(uint8_t  (0x28));
    float64_t(uint16_t (0x29));
    float64_t(uint32_t (0x2A));
    float64_t(uint64_t (0x2B));
    float64_t(bool     (0x2C));
    int8_t(float16_t(0x31));
    int8_t(float32_t(0x32));
    int8_t(float64_t(0x33));
    int8_t(int8_t   (0x34));
    int8_t(int16_t  (0x35));
    int8_t(int32_t  (0x36));
    int8_t(int64_t  (0x37));
    int8_t(uint8_t  (0x38));
    int8_t(uint16_t (0x39));
    int8_t(uint32_t (0x3A));
    int8_t(uint64_t (0x3B));
    int8_t(bool     (0x3C));
    int16_t(float16_t(0x41));
    int16_t(float32_t(0x42));
    int16_t(float64_t(0x43));
    int16_t(int8_t   (0x44));
    int16_t(int16_t  (0x45));
    int16_t(int32_t  (0x46));
    int16_t(int64_t  (0x47));
    int16_t(uint8_t  (0x48));
    int16_t(uint16_t (0x49));
    int16_t(uint32_t (0x4A));
    int16_t(uint64_t (0x4B));
    int16_t(bool     (0x4C));
    int32_t(float16_t(0x51));
    int32_t(float32_t(0x52));
    int32_t(float64_t(0x53));
    int32_t(int8_t   (0x54));
    int32_t(int16_t  (0x55));
    int32_t(int32_t  (0x56));
    int32_t(int64_t  (0x57));
    int32_t(uint8_t  (0x58));
    int32_t(uint16_t (0x59));
    int32_t(uint32_t (0x5A));
    int32_t(uint64_t (0x5B));
    int32_t(bool     (0x5C));
    int64_t(float16_t(0x61));
    int64_t(float32_t(0x62));
    int64_t(float64_t(0x63));
    int64_t(int8_t   (0x64));
    int64_t(int16_t  (0x65));
    int64_t(int32_t  (0x66));
    int64_t(int64_t  (0x67));
    int64_t(uint8_t  (0x68));
    int64_t(uint16_t (0x69));
    int64_t(uint32_t (0x6A));
    int64_t(uint64_t (0x6B));
    int64_t(bool     (0x6C));
    uint8_t(float16_t(0x71));
    uint8_t(float32_t(0x72));
    uint8_t(float64_t(0x73));
    uint8_t(int8_t   (0x74));
    uint8_t(int16_t  (0x75));
    uint8_t(int32_t  (0x76));
    uint8_t(int64_t  (0x77));
    uint8_t(uint8_t  (0x78));
    uint8_t(uint16_t (0x79));
    uint8_t(uint32_t (0x7A));
    uint8_t(uint64_t (0x7B));
    uint8_t(bool     (0x7C));
    uint16_t(float16_t(0x81));
    uint16_t(float32_t(0x82));
    uint16_t(float64_t(0x83));
    uint16_t(int8_t   (0x84));
    uint16_t(int16_t  (0x85));
    uint16_t(int32_t  (0x86));
    uint16_t(int64_t  (0x87));
    uint16_t(uint8_t  (0x88));
    uint16_t(uint16_t (0x89));
    uint16_t(uint32_t (0x8A));
    uint16_t(uint64_t (0x8B));
    uint16_t(bool     (0x8C));
    uint32_t(float16_t(0x91));
    uint32_t(float32_t(0x92));
    uint32_t(float64_t(0x93));
    uint32_t(int8_t   (0x94));
    uint32_t(int16_t  (0x95));
    uint32_t(int32_t  (0x96));
    uint32_t(int64_t  (0x97));
    uint32_t(uint8_t  (0x98));
    uint32_t(uint16_t (0x99));
    uint32_t(uint32_t (0x9A));
    uint32_t(uint64_t (0x9B));
    uint32_t(bool     (0x9C));
    uint64_t(float16_t(0xA1));
    uint64_t(float32_t(0xA2));
    uint64_t(float64_t(0xA3));
    uint64_t(int8_t   (0xA4));
    uint64_t(int16_t  (0xA5));
    uint64_t(int32_t  (0xA6));
    uint64_t(int64_t  (0xA7));
    uint64_t(uint8_t  (0xA8));
    uint64_t(uint16_t (0xA9));
    uint64_t(uint32_t (0xAA));
    uint64_t(uint64_t (0xAB));
    uint64_t(bool     (0xAC));
    bool(float16_t(0xB1));
    bool(float32_t(0xB2));
    bool(float64_t(0xB3));
    bool(int8_t   (0xB4));
    bool(int16_t  (0xB5));
    bool(int32_t  (0xB6));
    bool(int64_t  (0xB7));
    bool(uint8_t  (0xB8));
    bool(uint16_t (0xB9));
    bool(uint32_t (0xBA));
    bool(uint64_t (0xBB));
    bool(bool     (0xBC));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.constStruct.vert]=[
#version 450

precision highp float;

struct U {
    mat2 m;
};

struct T {
    mat2 m;
};

struct S {
    T t;
    U u;
};

void main()
{
    S s1 = S(T(mat2(1.0)), U(mat2(1.0)));
    S s2 = S(T(mat2(1.0)), U(mat2(1.0)));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.constructComposite.comp]=[
#version 460 core

layout(local_size_x=64) in;

struct sA {
  int x, y;
};

struct sB {
  sA a;
};

layout(binding=0,set=0) uniform ubo {
  sB  b;
};

struct sC {
  sA state;
} c = {
  b.a,
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.controlFlowAttributes.frag]=[
#version 450

#extension GL_EXT_control_flow_attributes : enable

bool cond;

void f0() {
        [[loop]]                   for (;;) { }
}

void f1() {
        [[dont_unroll]]            while(true) {  }
}

void main()
{
        [[unroll]]                 for (int i = 0; i < 8; ++i) { }
	f0();
        [[dependency_infinite]]    do {  } while(true);
        [[dependency_length(1+3)]] for (int i = 0; i < 8; ++i) { }
        [[flatten]]                if (cond) { } else { }
        [[branch]]                 if (cond) cond = false;
        [[dont_flatten]]           switch(3) {  }                      // dropped
        [[dont_flatten]]           switch(3) { case 3: break; }

        // warnings on all these
        [[unroll(2)]]              for (int i = 0; i < 8; ++i) { }
        [[dont_unroll(-2)]]        while(true) {  }
        [[dependency_infinite(3)]] do {  } while(true);
        [[dependency_length]]      for (int i = 0; i < 8; ++i) { }
        [[flatten(3)]]             if (cond) { } else { }
        [[branch(5.2)]]            if (cond) cond = false;
        [[dont_flatten(3 + 7)]]    switch(3) { case 3: break; }

        // other valid uses
        [[ unroll, dont_unroll, dependency_length(2) ]]  while(cond) {  }
        [ [ dont_flatten , branch ] ]                    switch(3) { case 3: break; }
        [
            // attribute
            [
                // here
                flatten
            ]
        ]                       if (cond) { } else { }
        [[ dependency_length(2), dependency_infinite ]]  while(cond) {  }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.conversion.frag]=[
#version 140

bool  u_b;
bvec2 u_b2;
bvec3 u_b3;
bvec4 u_b4;

int   u_i;
ivec2 u_i2;
ivec3 u_i3;
ivec4 u_i4;

float u_f;
vec2 u_f2;
vec3 u_f3;
vec4 u_f4;

bool  i_b;
bvec2 i_b2;
bvec3 i_b3;
bvec4 i_b4;

flat in int   i_i;
flat in ivec2 i_i2;
flat in ivec3 i_i3;
flat in ivec4 i_i4;

in float i_f;
in vec2 i_f2;
in vec3 i_f3;
in vec4 i_f4;

void main()
{
    bool   b = bool(u_i) ^^ bool(u_f);
    bvec2 b2 = bvec2(u_i, u_f);
    bvec3 b3 = bvec3(u_i, u_f, i_i);
    bvec4 b4 = bvec4(u_i, u_f, i_i, i_f);

    int    i = int(u_f)    + int(b);
    ivec2 i2 = ivec2(u_f2) + ivec2(b2);
    ivec3 i3 = ivec3(u_f3) + ivec3(b3);
    ivec4 i4 = ivec4(u_f4) + ivec4(b4);

    float f = i;
    vec2 f2 = i2;
    vec3 f3 = i3;
    vec4 f4 = i4;

    f  += (float(i) + float(b));
    f2 -= vec2(i2) + vec2(b2);
    f3 /= vec3(i3) + vec3(b3);
    f4 += vec4(i4) + vec4(b4);

    f4 += vec4(bvec4(i_i4));
    f4 += vec4(bvec4(u_f4));
    
    f  += f                 - i;
    f2 += vec2(f, i)       + i2;
    f3 += i3 + vec3(f, i, f);
    f4 += vec4(b, i, f, i) + i4;
    
    f2 += vec2(f, i)       * i;
    f3 += vec3(f, i, f)    + i;
    f4 += i - vec4(b, i, f, i);

    i2 += ivec2(f, i);
    i3 += ivec3(f, i, f);
    i4 += ivec4(b, i, f, i);

    if (f < i || i < f ||
        f2 == i2 ||
        i3 != f3)
        f = (b ? i : f2.x) + (b2.x ? f3.x : i2.y);

    gl_FragColor = 
        b || 
        b2.x ||
        b2.y ||
        b3.x ||
        b3.y ||
        b3.z ||
        b4.x ||
        b4.y ||
        b4.z ||
        b4.w ? vec4(
        i  +
        i2.x +
        i2.y +
        i3.x +
        i3.y +
        i3.z +
        i4.x +
        i4.y +
        i4.z +
        i4.w +
        f  +
        f2.x +
        f2.y +
        f3.x +
        f3.y +
        f3.z +
        f4.x +
        f4.y +
        f4.z +
        f4.w) : vec4(1.0);

    // with constants...
    ivec4 cv2 = ivec4(1.0);
    bvec4 cv5 = bvec4(cv2);
    gl_FragColor += float(cv5);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dataOut.frag]=[
#version 140 

in vec4 Color;

void main()
{
    gl_FragData[1] = Color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dataOutIndirect.frag]=[
#version 140 

in vec4 Color;

out vec4 fcolor[4];

uniform b { int i; } bName;

void main()
{
    fcolor[bName.i] = Color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dataOutIndirect.vert]=[
#version 140

attribute vec4 color;
out vec4 colorOut[6];

void main()
{
    for (int i = 1; i < 5; ++i)
        colorOut[i] = color;

    gl_Position = colorOut[2];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-after-continue.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  int i;
  for (i=0; i < 5; i++) {
    o = 1;
    continue;
    o = 2;
  }
  o = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-after-discard.frag]=[
#version 450

layout(location =0 ) in float c;
layout(location =0 ) out int o;

void main() {
  o = 1;
  discard;
  o = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-after-loop-break.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  int i;
  o = 1;
  for (i=0; i < 5; i++) {
    o = 2;
    if (i==c) {
      o = 3;
      break;
      o = 4;
    }
    o = 5;
  }
  o = 6;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-after-return.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  o = 1;
  return;
  o = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-after-switch-break.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  int i;
  switch(c) {
    case 0: o=1;
      break;
      o=2;
   default: break;
  }
  o = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-complex-continue-after-return.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  int i = 0;
  o = 1;
  // This has non-trivial continue target.
  for (i=0; i < 5; ++i, o=99) {
    o = 2;
    return;
    o = 3;
  }
  // This is considered reachable since Glslang codegen will
  // create a conditional branch in the header, and one arm
  // of that branch reaches this merge block.
  o = 4;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.dead-complex-merge-after-return.vert]=[
#version 450

layout(location =0 ) in int c;
layout(location =0 ) out int o;

void main() {
  int i = 0;
  o = 1;
  do {
    o = 2;
    return;
    o = 3;
  } while(i++ < 5);

  // All this is a dead merge block.
  o = 4;
  if (c==4) {
     o = 100;
  } else {
     o = 200;
  }
  o = 300;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.debugInfo.frag]=[
#version 450

struct S {
    int a;
};

uniform ubuf {
    S s;
};

uniform sampler2D s2d;

layout(location = 0) in vec4 inv;
layout(location = 0) out vec4 outv;

vec4 foo(S s)
{
    vec4 r = s.a * inv;
    ++r;
    if (r.x > 3.0)
        --r;
    else
        r *= 2;

    return r;
}

void main()
{
    outv = foo(s);
    outv += texture(s2d, vec2(0.5));

    switch (s.a) {
    case 10:
        ++outv;
        break;
    case 20:
        outv = 2 * outv;
        ++outv;
        break;
    default:
        --outv;
        break;
    }

    for (int i = 0; i < 10; ++i)
        outv *= 3.0;

    outv.x < 10.0 ?
        outv = sin(outv) :
        outv = cos(outv);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.debugPrintf.frag]=[
#version 450
#extension GL_EXT_debug_printf : enable

void main()
{
    debugPrintfEXT("ASDF \\ \? \x5C %d %d %d", 1, 2, 3);

    // ABA{backspace}Z
    debugPrintfEXT("\x41\x000042\x41\x8Z");

    // B#${bell, aka \a}B1Z
    debugPrintfEXT("\102\043\44\7\1021Z");
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
6:19; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
6:25; <no symbol>; token recognition error at: '\\'; LexerNoViableAltException:null
6:28; <no symbol>; token recognition error at: '\?'; LexerNoViableAltException:null
6:31; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
6:44; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
9:19; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
9:20; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
9:24; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
9:32; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
9:36; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
9:40; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
12:19; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
12:20; <no symbol>; token recognition error at: '\1'; LexerNoViableAltException:null
12:24; <no symbol>; token recognition error at: '\0'; LexerNoViableAltException:null
12:28; <no symbol>; token recognition error at: '\4'; LexerNoViableAltException:null
12:31; <no symbol>; token recognition error at: '\7'; LexerNoViableAltException:null
12:33; <no symbol>; token recognition error at: '\1'; LexerNoViableAltException:null
12:39; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
6:33; [@30,106:106='5',<INT32CONSTANT>,6:33]; no viable alternative at input 'debugPrintfEXT(ASDF   5'; NoViableAltException:null
6:34; [@31,107:107='C',<IDENTIFIER>,6:34]; missing ';' at 'C'; <no exception>
6:54; [@50,127:127=')',<RPAREN>,6:54]; extraneous input ')' expecting ';'; <no exception>
9:26; [@60,183:188='000042',<INT32CONSTANT>,9:26]; no viable alternative at input 'debugPrintfEXT(41000042'; NoViableAltException:null
9:26; [@60,183:188='000042',<INT32CONSTANT>,9:26]; missing ';' at '000042'; <no exception>
9:34; [@61,191:192='41',<INT32CONSTANT>,9:34]; missing ';' at '41'; <no exception>
9:38; [@62,195:195='8',<INT32CONSTANT>,9:38]; missing ';' at '8'; <no exception>
9:39; [@63,196:196='Z',<IDENTIFIER>,9:39]; missing ';' at 'Z'; <no exception>
12:26; [@74,259:260='43',<INT32CONSTANT>,12:26]; no viable alternative at input 'debugPrintfEXT(0243'; NoViableAltException:null
12:26; [@74,259:260='43',<INT32CONSTANT>,12:26]; missing ';' at '43'; <no exception>
12:30; [@75,263:263='4',<INT32CONSTANT>,12:30]; missing ';' at '4'; <no exception>
12:35; [@76,268:270='021',<INT32CONSTANT>,12:35]; missing ';' at '021'; <no exception>
12:38; [@77,271:271='Z',<IDENTIFIER>,12:38]; missing ';' at 'Z'; <no exception>
]


testGlslangErrors[spv.debugPrintf_Error.frag]=[
#version 450
#extension GL_EXT_debug_printf : enable

void main()
{
    // invalid hex sequence
    debugPrintfEXT("\xZ");

    // not an octal sequence
    debugPrintfEXT("\8");
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
7:19; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
7:20; <no symbol>; token recognition error at: '\x'; LexerNoViableAltException:null
7:23; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
10:19; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
10:20; <no symbol>; token recognition error at: '\8'; LexerNoViableAltException:null
10:22; <no symbol>; token recognition error at: '"'; LexerNoViableAltException:null
]


testGlslangErrors[spv.deepRvalue.frag]=[
#version 330

uniform sampler2D samp2D;

vec4 v1 = vec4(2.0, 3.0, 5.0, 7.0);
vec4 v2 = vec4(11.0, 13.0, 17.0, 19.0);
vec4 v3 = vec4(23.0, 29.0, 31.0, 37.0);
vec4 v4 = vec4(41.0, 43.0, 47.0, 53.0);

struct str {
    int a;
    vec2 b[3];
    bool c;
};

void main()
{
    mat4 m = mat4(v1, v2, v3, v4);

    mat4 mm  = matrixCompMult(m, m);
    float f = mm[1].w; // should be 19 * 19 = 361

    // do a deep access to a spontaneous r-value
    float g = matrixCompMult(m, m)[2].y;  // should be 29 * 29 = 841

    float h = str(1, vec2[3](vec2(2.0, 3.0), vec2(4.0, 5.0), vec2(6.0, 7.0)), true).b[1][1];  // should be 5.0

    float i = texture(samp2D, vec2(0.5,0.5)).y;

    i += (i > 0.1 ? v1 : v2)[3];

    str t;
    i += (t = str(1, vec2[3](vec2(2.0, 3.0), vec2(4.0, 5.0), vec2(6.0, 7.0)), true)).b[2].y;  // should be 7.0

    gl_FragColor = vec4(f, g, h, i);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.demoteDisabled.frag]=[
#version 460 core

void main (void)
{
    {
        int demote = 0;
        demote;
    }
    demote;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
6:12; [@24,61:66='demote',<'demote'>,6:12]; no viable alternative at input 'int demote'; NoViableAltException:null
6:19; [@26,68:68='=',<'='>,6:19]; mismatched input '=' expecting ';'; InputMismatchException:null
]


testGlslangErrors[spv.depthOut.frag]=[
#version 450

in vec4 Color;
in float Depth;

layout(depth_greater) out float gl_FragDepth;

void main()
{
    gl_FragDepth = Depth;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.depthUnchanged.frag]=[
#version 430
layout(location = 0) out vec4 outColor;
layout(depth_unchanged) out float gl_FragDepth;
void main() {
  outColor = vec4(1.0, 0.0, 0.0, 1.0);
  gl_FragDepth = gl_FragCoord.y;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.deviceGroup.frag]=[
#version 450

#extension GL_EXT_device_group : enable

out vec4 color;

void main() {
    color = vec4(gl_DeviceIndex, 0, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.discard-dce.frag]=[
#version 140
in vec2 tex_coord;

void main (void)
{
    vec4 white = vec4(1.0);
    vec4 black = vec4(0.2);
    vec4 color = white;

    // First, cut out our circle
    float x = tex_coord.x*2.0 - 1.0;
    float y = tex_coord.y*2.0 - 1.0;

    float radius = sqrt(x*x + y*y);
    if (radius > 1.0) {
        if (radius > 1.1) {
            ++color;
        }

        gl_FragColor = color;

        if (radius > 1.2) {
            ++color;
        }

        discard;
    }

    // If we're near an edge, darken us a tiny bit
    if (radius >= 0.75)
        color -= abs(pow(radius, 16.0)/2.0);

    gl_FragColor = color;

}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.do-simple.vert]=[
#version 310 es
void main() {
  int i = 0;
  do {
    i++;
  } while(i<10);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.do-while-continue-break.vert]=[
#version 310 es
void main() {
  int i = 0;
  int A, B, C, D, E, F, G;
  do {
    A = 0;
    if (i == 2) {
      B = 1;
      continue;
      C = 2;
    }
    if (i == 5) {
      D = 3;
      break;
      E = 42;
    }
    F = 99;
  }  while (++i < 19);
  G = 12;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.doWhileLoop.frag]=[
#version 140

in vec4 bigColor;
in vec4 BaseColor;
in float d;

void main()
{
    vec4 color = BaseColor;

    do {
        color += bigColor;
    } while (color.x < d);

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.double.comp]=[
#version 430

const double d1 = 3.1415926535897932384626433832795LF;
const double d2 = 3.1415;
const double d3 = 3.1415926535897932384626433832795LF;
const double d4 = 3.1415926535897932384626433832795;

buffer bufName {
    float f;
    double d;
} bufInst;
.
.
uniform writeonly image2D destTex;

void main()
{
    bufInst.d = float(d1);
    bufInst.f = float(d1 + d2 + d3 + d4);

    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    double localCoef = length(vec2(ivec2(gl_LocalInvocationID.xy)-8)/8.0);
    dvec4 aa = dvec4(0.4, 0.2, 0.3, 0.4);
    double globalCoef = 1.0;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.drawParams.vert]=[
#version 450

#extension GL_ARB_shader_draw_parameters : enable

out vec3 pos;

void main()
{
    int a = gl_BaseVertexARB;
    int b = gl_BaseInstanceARB;
    int c = gl_DrawIDARB;
    pos = vec3(a, b, c);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.earlyReturnDiscard.frag]=[
#version 140

in float d;
in vec4 bigColor, smallColor;
in vec4 otherColor;

in float c;

in float threshhold;
in float threshhold2;
in float threshhold3;

in float minimum;

in vec4 BaseColor;

bool b;

void main()
{
    vec4 color = BaseColor;
    vec4 color2;

    color2 = otherColor;

    if (c > d)
        color += bigColor;
    else
        color += smallColor;

    if (color.z < minimum)
        return;

    color.z++;

    if (color.z > threshhold)
        discard;

    color++;

    // Two path, different rest
    if (color.w > threshhold2) {
        if (color.z > threshhold2)
            return;
        else if (b)
            color.z++;
        else {
            if (color.x < minimum) {
                discard;
            } else {
                color++;
            }
        }
    } else {
        if (b)
            discard;
        else
            return;
    }
.
.
    // // Two path, shared rest
    // if (color.w > threshhold2) {
    //     if (color.z > threshhold2)
    //         return;
    //     else if (b)
    //         color++;
    //     else {
    //         if (color.x < minimum) {
    //             discard;
    //         } else {
    //             color++;
    //         }
    //     }
    // } else {
    //     if (b)
    //         discard;
    //     else
    //         return;
    // }
.
.
    // // One path
    // if (color.w > threshhold2) {
    //     if (color.z > threshhold2)
    //         return;
    //     else {
    //         if (color.x < minimum) {
    //             discard;
    //         } else {
    //             color++;
    //         }
    //     }
    // } else {
    //     if (b)
    //         discard;
    //     else
    //         return;
    // }

    gl_FragColor = color * color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.explicittypes.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    int16_t   i16;
    i16vec2   i16v2;
    i16vec3   i16v3;
    i16vec4   i16v4;
    uint16_t  u16;
    u16vec2   u16v2;
    u16vec3   u16v3;
    u16vec4   u16v4;

    int32_t   i32;
    i32vec2   i32v2;
    i32vec3   i32v3;
    i32vec4   i32v4;
    uint32_t  u32;
    u32vec2   u32v2;
    u32vec3   u32v3;
    u32vec4   u32v4;
} block;

void main()
{
}

void literal()
{
    const int64_t i64Const[3] =
    {
        -0x1111111111111111l,   // Hex
        -1l,                    // Dec
        040000000000l,          // Oct
    };

    int64_t i64 = i64Const[index];

    const uint64_t u64Const[] =
    {
        0xFFFFFFFFFFFFFFFFul,   // Hex
        4294967296UL,           // Dec
        077777777777ul,         // Oct
    };

    uint64_t u64 = u64Const[index];

    const int32_t i32Const[3] =
    {
        -0x11111111,           // Hex
        -1,                    // Dec
        04000000000,           // Oct
    };

    int32_t i32 = i32Const[index];

    const uint32_t u32Const[] =
    {
        0xFFFFFFFF,             // Hex
        4294967295,             // Dec
        017777777777,           // Oct
    };

    uint32_t u32 = u32Const[index];

    const int16_t i16Const[3] =
    {
        int16_t(-0x1111),           // Hex
        int16_t(-1),                // Dec
        int16_t(040000),            // Oct
    };

    int16_t i16 = i16Const[index];

    const uint16_t u16Const[] =
    {
        uint16_t(0xFFFF),             // Hex
        uint16_t(65535),              // Dec
        uint16_t(077777),             // Oct
    };

    uint16_t u16 = u16Const[index];

    const int8_t i8Const[3] =
    {
        int8_t(-0x11),           // Hex
        int8_t(-1),              // Dec
        int8_t(0400),            // Oct
    };

    int8_t i8 = i8Const[index];

    const uint8_t u8Const[] =
    {
        uint8_t(0xFF),             // Hex
        uint8_t(255),              // Dec
        uint8_t(0177),             // Oct
    };

    uint8_t u8 = u8Const[index];
}

void typeCast8()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    u8v = i8v;      // int8_t  ->  uint8_t
    i16v = i8v;     // int8_t  ->   int16_t
    i16v = u8v;     // uint8_t ->   int16_t
    i32v = i8v;     // int8_t  ->   int32_t
    i32v = u8v;     // uint8_t ->   int32_t
    u32v = i8v;     // int8_t  ->  uint32_t
    i64v = i8v;     // int8_t  ->   int64_t
    u64v = i8v;     // int8_t  ->  uint64_t
    u32v = u8v;     // uint8_t ->  uint32_t
    i64v = u8v;     // uint8_t ->   int64_t
    u64v = u8v;     // uint8_t ->  uint64_t
    f16v = i8v;     // int8_t  ->  float16_t
    f32v = i8v;     // int8_t  ->  float32_t
    f64v = i8v;     // int8_t  ->  float64_t
    f16v = u8v;     // uint8_t ->  float16_t
    f32v = u8v;     // uint8_t ->  float32_t
    f64v = u8v;     // uint8_t ->  float64_t

    i8v =  i8vec2(u8v);       // uint8_t  ->   int8_t
    i16v = i16vec2(i8v);      // int8_t   ->   int16_t
    i16v = i16vec2(u8v);      // uint8_t  ->   int16_t
    i32v = i32vec2(i8v);      // int8_t   ->   int32_t
    i32v = i32vec2(u8v);      // uint8_t  ->   int32_t
    i64v = i64vec2(i8v);      // int8_t   ->   int64_t
    u64v = i64vec2(i8v);      // int8_t   ->  uint64_t
    u16v = u16vec2(i8v);      // int8_t   ->  uint16_t
    u16v = u16vec2(u8v);      // uint8_t  ->  uint16_t
    u32v = u32vec2(u8v);      // uint8_t  ->  uint32_t
    i64v = i64vec2(u8v);      // uint8_t  ->   int64_t
    u64v = i64vec2(u8v);      // uint8_t  ->  uint64_t
    f16v = f16vec2(i8v);      // int8_t   ->  float16_t
    f32v = f32vec2(i8v);      // int8_t   ->  float32_t
    f64v = f64vec2(i8v);      // int8_t   ->  float64_t
    f16v = f16vec2(u8v);      // uint8_t  ->  float16_t
    f32v = f32vec2(u8v);      // uint8_t  ->  float32_t
    f64v = f64vec2(u8v);      // uint8_t  ->  float64_t

    i8v = i8vec2(bv);       // bool     ->   int8
    u8v = u8vec2(bv);       // bool     ->   uint8
    bv  = bvec2(i8v);       // int8    ->   bool
    bv  = bvec2(u8v);       // uint8   ->   bool
}

void typeCast16()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    i32v = i16v;     // int16_t  ->   int32_t
    i32v = u16v;     // uint16_t ->   int32_t
    u16v = i16v;     // int16_t  ->  uint16_t
    u32v = i16v;     // int16_t  ->  uint32_t
    i64v = i16v;     // int16_t  ->   int64_t
    u64v = i16v;     // int16_t  ->  uint64_t
    u32v = u16v;     // uint16_t ->  uint32_t
    i64v = u16v;     // uint16_t ->   int64_t
    u64v = u16v;     // uint16_t ->  uint64_t
    f16v = i16v;     // int16_t  ->  float16_t
    f32v = i16v;     // int16_t  ->  float32_t
    f64v = i16v;     // int16_t  ->  float64_t
    f16v = u16v;     // uint16_t ->  float16_t
    f32v = u16v;     // uint16_t ->  float32_t
    f64v = u16v;     // uint16_t ->  float64_t

    i32v = i32vec2(i16v);     // int16_t  ->   int32_t
    i32v = i32vec2(u16v);     // uint16_t ->   int32_t
    u16v = u16vec2(i16v);     // int16_t  ->  uint16_t
    u32v = u32vec2(i16v);     // int16_t  ->  uint32_t
    i64v = i64vec2(i16v);     // int16_t  ->   int64_t
    u64v = i64vec2(i16v);     // int16_t  ->  uint64_t
    u32v = u32vec2(u16v);     // uint16_t ->  uint32_t
    i64v = i64vec2(u16v);     // uint16_t ->   int64_t
    u64v = i64vec2(u16v);     // uint16_t ->  uint64_t
    f16v = f16vec2(i16v);     // int16_t  ->  float16_t
    f32v = f32vec2(i16v);     // int16_t  ->  float32_t
    f64v = f64vec2(i16v);     // int16_t  ->  float64_t
    f16v = f16vec2(u16v);     // uint16_t ->  float16_t
    f32v = f32vec2(u16v);     // uint16_t ->  float32_t
    f64v = f64vec2(u16v);     // uint16_t ->  float64_t

    i8v  = i8vec2(i16v);      // int16_t  ->   int8_t
    i8v  = i8vec2(u16v);      // uint16_t ->   int8_t
    u8v  = u8vec2(i16v);      // int16_t  ->  uint8_t
    u8v  = u8vec2(u16v);      // uint16_t ->  uint8_t
    i16v = u8vec2(u16v);      // uint16_t ->   int16_t
    i16v = i16vec2(bv);       // bool     ->   int16
    u16v = u16vec2(bv);       // bool     ->   uint16
    bv   = bvec2(i16v);       // int16    ->   bool
    bv   = bvec2(u16v);       // uint16   ->   bool
}

void typeCast32()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    u32v = i32v;     // int32_t  ->  uint32_t
    i64v = i32v;     // int32_t  ->   int64_t
    u64v = i32v;     // int32_t  ->  uint64_t
    i64v = u32v;     // uint32_t ->   int64_t
    u64v = u32v;     // uint32_t ->  uint64_t
    f32v = i32v;     // int32_t  ->  float32_t
    f64v = i32v;     // int32_t  ->  float64_t
    f32v = u32v;     // uint32_t ->  float32_t
    f64v = u32v;     // uint32_t ->  float64_t

    i8v =  i8vec2(i32v);       // int32_t   ->   int8_t
    i8v =  i8vec2(u32v);       // uint32_t  ->   int8_t
    i16v = i16vec2(i32v);      // int32_t   ->   int16_t
    i16v = i16vec2(u32v);      // uint32_t  ->   int16_t
    i32v = i32vec2(i32v);      // int32_t   ->   int32_t
    i32v = i32vec2(u32v);      // uint32_t  ->   int32_t
    i64v = i64vec2(i32v);      // int32_t   ->   int64_t
	i64v = i64vec2(u32v);      // uint32_t  ->   int64_t
	u8v =  u8vec2(i32v);       // int32_t   ->   uint8_t
    u8v =  u8vec2(u32v);       // uint32_t  ->   uint8_t
    u16v = u16vec2(i32v);      // int32_t   ->   uint16_t
    u16v = u16vec2(u32v);      // uint32_t  ->   uint16_t
    u32v = u32vec2(i32v);      // int32_t   ->   uint32_t
    u32v = u32vec2(u32v);      // uint32_t  ->   uint32_t
    u64v = u64vec2(i32v);      // int32_t   ->   uint64_t
    u64v = u64vec2(u32v);      // uint32_t  ->   uint64_t

    f16v = f16vec2(i32v);      // int32_t   ->  float16_t
    f32v = f32vec2(i32v);      // int32_t   ->  float32_t
    f64v = f64vec2(i32v);      // int32_t   ->  float64_t
    f16v = f16vec2(u32v);      // uint32_t  ->  float16_t
    f32v = f32vec2(u32v);      // uint32_t  ->  float32_t
    f64v = f64vec2(u32v);      // uint32_t  ->  float64_t

    i32v = i32vec2(bv);       // bool     ->   int32
    u32v = u32vec2(bv);       // bool     ->   uint32
    bv   = bvec2(i32v);       // int32    ->   bool
    bv   = bvec2(u32v);       // uint32   ->   bool
}

void typeCast64()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    u64v = i64v;     // int64_t  ->  uint64_t
    f64v = i64v;     // int64_t  ->  float64_t
    f64v = u64v;     // uint64_t ->  float64_t

    i8v =  i8vec2(i64v);       // int64_t   ->   int8_t
    i8v =  i8vec2(u64v);       // uint64_t  ->   int8_t
    i16v = i16vec2(i64v);      // int64_t   ->   int16_t
    i16v = i16vec2(u64v);      // uint64_t  ->   int16_t
    i32v = i32vec2(i64v);      // int64_t   ->   int32_t
    i32v = i32vec2(u64v);      // uint64_t  ->   int32_t
	i64v = i64vec2(u64v);      // uint64_t  ->   int64_t
	u8v =  u8vec2(i64v);       // int64_t   ->   uint8_t
    u8v =  u8vec2(u64v);       // uint64_t  ->   uint8_t
    u16v = u16vec2(i64v);      // int64_t   ->   uint16_t
    u16v = u16vec2(u64v);      // uint64_t  ->   uint16_t
    u32v = u32vec2(i64v);      // int64_t   ->   uint32_t
    u32v = u32vec2(u64v);      // uint64_t  ->   uint32_t
    u64v = u64vec2(i64v);      // int64_t   ->   uint64_t
    u64v = u64vec2(u64v);      // uint64_t  ->   uint64_t

    f16v = f16vec2(i64v);      // int64_t   ->  float16_t
    f32v = f32vec2(i64v);      // int64_t   ->  float32_t
    f64v = f64vec2(i64v);      // int64_t   ->  float64_t
    f16v = f16vec2(u64v);      // uint64_t  ->  float16_t
    f32v = f32vec2(u64v);      // uint64_t  ->  float32_t
    f64v = f64vec2(u64v);      // uint64_t  ->  float64_t

    i64v = i64vec2(bv);       // bool     ->   int64
    u64v = u64vec2(bv);       // bool     ->   uint64
    bv   = bvec2(i64v);       // int64    ->   bool
    bv   = bvec2(u64v);       // uint64   ->   bool
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.extPostDepthCoverage.frag]=[
#version 310 es

#extension GL_EXT_post_depth_coverage : enable

layout(post_depth_coverage) in;
layout(early_fragment_tests) in;

void main () {
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.extPostDepthCoverage_Error.frag]=[
#version 450

#extension GL_EXT_post_depth_coverage : enable

layout(post_depth_coverage) in; // should fail since for GL_EXT_post_depth_coverage
                                // explicit declaration of early_fragment_tests is required

void main () {
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float16.frag]=[
#version 450 core

#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_ARB_gpu_shader_int64: enable

void main()
{
}

// Half float literals
void literal()
{
    const float16_t f16c  = 0.000001hf;
    const f16vec2   f16cv = f16vec2(-0.25HF, 0.03HF);

    f16vec2 f16v;
    f16v.x  = f16c;
    f16v   += f16cv;
}

// Block memory layout
struct S
{
    float16_t  x;   // rule 1: align = 2, takes offsets 0-1
    f16vec2    y;   // rule 2: align = 4, takes offsets 4-7
    f16vec3    z;   // rule 3: align = 8, takes offsets 8-13
};

layout(column_major, std140) uniform B1
{
    float16_t  a;     // rule 1:  align = 2, takes offsets 0-1
    f16vec2    b;     // rule 2:  align = 4, takes offsets 4-7
    f16vec3    c;     // rule 3:  align = 8, takes offsets 8-15
    float16_t  d[2];  // rule 4:  align = 16, array stride = 16,
                      //          takes offsets 16-47
    f16mat2x3  e;     // rule 5:  align = 16, matrix stride = 16,
                      //          takes offsets 48-79
    f16mat2x3  f[2];  // rule 6:  align = 16, matrix stride = 16,
                      //          array stride = 32, f[0] takes
                      //          offsets 80-111, f[1] takes offsets
                      //          112-143
    S          g;     // rule 9:  align = 16, g.x takes offsets
                      //          144-145, g.y takes offsets 148-151,
                      //          g.z takes offsets 152-159
    S          h[2];  // rule 10: align = 16, array stride = 16, h[0]
                      //          takes offsets 160-175, h[1] takes
                      //          offsets 176-191
};

layout(row_major, std430) buffer B2
{
    float16_t  o;     // rule 1:  align = 2, takes offsets 0-1
    f16vec2    p;     // rule 2:  align = 4, takes offsets 4-7
    f16vec3    q;     // rule 3:  align = 8, takes offsets 8-13
    float16_t  r[2];  // rule 4:  align = 2, array stride = 2, takes
                      //          offsets 14-17
    f16mat2x3  s;     // rule 7:  align = 4, matrix stride = 4, takes
                      //          offsets 20-31
    f16mat2x3  t[2];  // rule 8:  align = 4, matrix stride = 4, array
                      //          stride = 12, t[0] takes offsets
                      //          32-43, t[1] takes offsets 44-55
    S          u;     // rule 9:  align = 8, u.x takes offsets
                      //          56-57, u.y takes offsets 60-63, u.z
                      //          takes offsets 64-69
    S          v[2];  // rule 10: align = 8, array stride = 16, v[0]
                      //          takes offsets 72-87, v[1] takes
                      //          offsets 88-103
};

// Specialization constant
layout(constant_id = 100) const float16_t sf16 = 0.125hf;
layout(constant_id = 101) const float     sf   = 0.25;
layout(constant_id = 102) const double    sd   = 0.5lf;

const float  f16_to_f = float(sf16);
const double f16_to_d = float(sf16);

const float16_t f_to_f16 = float16_t(sf);
const float16_t d_to_f16 = float16_t(sd);

void operators()
{
    float16_t f16;
    f16vec2   f16v;
    f16mat2x2 f16m;
    bool      b;

    // Arithmetic
    f16v += f16v;
    f16v -= f16v;
    f16v *= f16v;
    f16v /= f16v;
    f16v++;
    f16v--;
    ++f16m;
    --f16m;
    f16v = -f16v;
    f16m = -f16m;

    f16 = f16v.x + f16v.y;
    f16 = f16v.x - f16v.y;
    f16 = f16v.x * f16v.y;
    f16 = f16v.x / f16v.y;

    // Relational
    b = (f16v.x != f16);
    b = (f16v.y == f16);
    b = (f16v.x >  f16);
    b = (f16v.y <  f16);
    b = (f16v.x >= f16);
    b = (f16v.y <= f16);

    // Vector/matrix operations
    f16v = f16v * f16;
    f16m = f16m * f16;
    f16v = f16m * f16v;
    f16v = f16v * f16m;
    f16m = f16m * f16m;
}

void typeCast()
{
    bvec3   bv;
    vec3    fv;
    dvec3   dv;
    ivec3   iv;
    uvec3   uv;
    i64vec3 i64v;
    u64vec3 u64v;

    f16vec3 f16v;

    f16v = f16vec3(bv);     // bool -> float16
    bv   = bvec3(f16v);     // float16 -> bool

    f16v = f16vec3(fv);     // float -> float16
    fv   = vec3(f16v);      // float16 -> float

    f16v = f16vec3(dv);     // double -> float16
    dv   = dvec3(dv);       // float16 -> double

    f16v = f16vec3(iv);     // int -> float16
    iv   = ivec3(f16v);     // float16 -> int

    f16v = f16vec3(uv);     // uint -> float16
    uv   = uvec3(f16v);     // float16 -> uint

    f16v = f16vec3(i64v);   // int64 -> float16
    i64v = i64vec3(f16v);   // float16 -> int64

    f16v = f16vec3(u64v);   // uint64 -> float16
    u64v = u64vec3(f16v);   // float16 -> uint64
}

void builtinAngleTrigFuncs()
{
    f16vec4 f16v1, f16v2;

    f16v2 = radians(f16v1);
    f16v2 = degrees(f16v1);
    f16v2 = sin(f16v1);
    f16v2 = cos(f16v1);
    f16v2 = tan(f16v1);
    f16v2 = asin(f16v1);
    f16v2 = acos(f16v1);
    f16v2 = atan(f16v1, f16v2);
    f16v2 = atan(f16v1);
    f16v2 = sinh(f16v1);
    f16v2 = cosh(f16v1);
    f16v2 = tanh(f16v1);
    f16v2 = asinh(f16v1);
    f16v2 = acosh(f16v1);
    f16v2 = atanh(f16v1);
}

void builtinExpFuncs()
{
    f16vec2 f16v1, f16v2;

    f16v2 = pow(f16v1, f16v2);
    f16v2 = exp(f16v1);
    f16v2 = log(f16v1);
    f16v2 = exp2(f16v1);
    f16v2 = log2(f16v1);
    f16v2 = sqrt(f16v1);
    f16v2 = inversesqrt(f16v1);
}

void builtinCommonFuncs()
{
    f16vec3   f16v1, f16v2, f16v3;
    float16_t f16;
    bool  b;
    bvec3 bv;
    ivec3 iv;

    f16v2 = abs(f16v1);
    f16v2 = sign(f16v1);
    f16v2 = floor(f16v1);
    f16v2 = trunc(f16v1);
    f16v2 = round(f16v1);
    f16v2 = roundEven(f16v1);
    f16v2 = ceil(f16v1);
    f16v2 = fract(f16v1);
    f16v2 = mod(f16v1, f16v2);
    f16v2 = mod(f16v1, f16);
    f16v3 = modf(f16v1, f16v2);
    f16v3 = min(f16v1, f16v2);
    f16v3 = min(f16v1, f16);
    f16v3 = max(f16v1, f16v2);
    f16v3 = max(f16v1, f16);
    f16v3 = clamp(f16v1, f16, f16v2.x);
    f16v3 = clamp(f16v1, f16v2, f16vec3(f16));
    f16v3 = mix(f16v1, f16v2, f16);
    f16v3 = mix(f16v1, f16v2, f16v3);
    f16v3 = mix(f16v1, f16v2, bv);
    f16v3 = step(f16v1, f16v2);
    f16v3 = step(f16, f16v3);
    f16v3 = smoothstep(f16v1, f16v2, f16v3);
    f16v3 = smoothstep(f16, f16v1.x, f16v2);
    b     = isnan(f16);
    bv    = isinf(f16v1);
    f16v3 = fma(f16v1, f16v2, f16v3);
    f16v2 = frexp(f16v1, iv);
    f16v2 = ldexp(f16v1, iv);
}

void builtinPackUnpackFuncs()
{
    uint u;
    f16vec2 f16v;

    u    = packFloat2x16(f16v);
    f16v = unpackFloat2x16(u);
}

void builtinGeometryFuncs()
{
    float16_t f16;
    f16vec3   f16v1, f16v2, f16v3;

    f16   = length(f16v1);
    f16   = distance(f16v1, f16v2);
    f16   = dot(f16v1, f16v2);
    f16v3 = cross(f16v1, f16v2);
    f16v2 = normalize(f16v1);
    f16v3 = faceforward(f16v1, f16v2, f16v3);
    f16v3 = reflect(f16v1, f16v2);
    f16v3 = refract(f16v1, f16v2, f16);
}

void builtinMatrixFuncs()
{
    f16mat2x3 f16m1, f16m2, f16m3;
    f16mat3x2 f16m4;
    f16mat3   f16m5;
    f16mat4   f16m6, f16m7;

    f16vec3 f16v1;
    f16vec2 f16v2;

    float16_t f16;

    f16m3 = matrixCompMult(f16m1, f16m2);
    f16m1 = outerProduct(f16v1, f16v2);
    f16m4 = transpose(f16m1);
    f16   = determinant(f16m5);
    f16m6 = inverse(f16m7);
}

void builtinVecRelFuncs()
{
    f16vec3 f16v1, f16v2;
    bvec3   bv;

    bv = lessThan(f16v1, f16v2);
    bv = lessThanEqual(f16v1, f16v2);
    bv = greaterThan(f16v1, f16v2);
    bv = greaterThanEqual(f16v1, f16v2);
    bv = equal(f16v1, f16v2);
    bv = notEqual(f16v1, f16v2);
}

in f16vec3 if16v;

void builtinFragProcFuncs()
{
    f16vec3 f16v;

    // Derivative
    f16v.x  = dFdx(if16v.x);
    f16v.y  = dFdy(if16v.y);
    f16v.xy = dFdxFine(if16v.xy);
    f16v.xy = dFdyFine(if16v.xy);
    f16v    = dFdxCoarse(if16v);
    f16v    = dFdxCoarse(if16v);

    f16v.x  = fwidth(if16v.x);
    f16v.xy = fwidthFine(if16v.xy);
    f16v    = fwidthCoarse(if16v);

    // Interpolation
    f16v.x  = interpolateAtCentroid(if16v.x);
    f16v.xy = interpolateAtSample(if16v.xy, 1);
    f16v    = interpolateAtOffset(if16v, f16vec2(0.5hf));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float16Fetch.frag]=[
#version 450 core

#extension GL_ARB_sparse_texture2: enable
#extension GL_ARB_sparse_texture_clamp: enable
#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_AMD_gpu_shader_half_float_fetch: enable
#extension GL_AMD_texture_gather_bias_lod: enable

layout(set = 0, binding =  0) uniform f16sampler1D            s1D;
layout(set = 0, binding =  1) uniform f16sampler2D            s2D;
layout(set = 0, binding =  2) uniform f16sampler3D            s3D;
layout(set = 0, binding =  3) uniform f16sampler2DRect        s2DRect;
layout(set = 0, binding =  4) uniform f16samplerCube          sCube;
layout(set = 0, binding =  5) uniform f16samplerBuffer        sBuffer;
layout(set = 0, binding =  6) uniform f16sampler2DMS          s2DMS;
layout(set = 0, binding =  7) uniform f16sampler1DArray       s1DArray;
layout(set = 0, binding =  8) uniform f16sampler2DArray       s2DArray;
layout(set = 0, binding =  9) uniform f16samplerCubeArray     sCubeArray;
layout(set = 0, binding = 10) uniform f16sampler2DMSArray     s2DMSArray;

layout(set = 0, binding = 11) uniform f16sampler1DShadow          s1DShadow;
layout(set = 0, binding = 12) uniform f16sampler2DShadow          s2DShadow;
layout(set = 0, binding = 13) uniform f16sampler2DRectShadow      s2DRectShadow;
layout(set = 0, binding = 14) uniform f16samplerCubeShadow        sCubeShadow;
layout(set = 0, binding = 15) uniform f16sampler1DArrayShadow     s1DArrayShadow;
layout(set = 0, binding = 16) uniform f16sampler2DArrayShadow     s2DArrayShadow;
layout(set = 0, binding = 17) uniform f16samplerCubeArrayShadow   sCubeArrayShadow;

layout(set = 1, binding =  0) layout(rgba16f) uniform f16image1D          i1D;
layout(set = 1, binding =  1) layout(rgba16f) uniform f16image2D          i2D;
layout(set = 1, binding =  2) layout(rgba16f) uniform f16image3D          i3D;
layout(set = 1, binding =  3) layout(rgba16f) uniform f16image2DRect      i2DRect;
layout(set = 1, binding =  4) layout(rgba16f) uniform f16imageCube        iCube;
layout(set = 1, binding =  5) layout(rgba16f) uniform f16image1DArray     i1DArray;
layout(set = 1, binding =  6) layout(rgba16f) uniform f16image2DArray     i2DArray;
layout(set = 1, binding =  7) layout(rgba16f) uniform f16imageCubeArray   iCubeArray;
layout(set = 1, binding =  8) layout(rgba16f) uniform f16imageBuffer      iBuffer;
layout(set = 1, binding =  9) layout(rgba16f) uniform f16image2DMS        i2DMS;
layout(set = 1, binding = 10) layout(rgba16f) uniform f16image2DMSArray   i2DMSArray;

layout(set = 2, binding =  0) uniform f16texture1D           t1D;
layout(set = 2, binding =  1) uniform f16texture2D           t2D;
layout(set = 2, binding =  2) uniform f16texture3D           t3D;
layout(set = 2, binding =  3) uniform f16texture2DRect       t2DRect;
layout(set = 2, binding =  4) uniform f16textureCube         tCube;
layout(set = 2, binding =  5) uniform f16texture1DArray      t1DArray;
layout(set = 2, binding =  6) uniform f16texture2DArray      t2DArray;
layout(set = 2, binding =  7) uniform f16textureCubeArray    tCubeArray;
layout(set = 2, binding =  8) uniform f16textureBuffer       tBuffer;
layout(set = 2, binding =  9) uniform f16texture2DMS         t2DMS;
layout(set = 2, binding = 10) uniform f16texture2DMSArray    t2DMSArray;

layout(set = 2, binding = 11) uniform sampler s;
layout(set = 2, binding = 12) uniform samplerShadow sShadow;

layout(set = 3, binding = 0, input_attachment_index = 0) uniform f16subpassInput   subpass;
layout(set = 3, binding = 1, input_attachment_index = 0) uniform f16subpassInputMS subpassMS;

layout(location =  0) in float c1;
layout(location =  1) in vec2  c2;
layout(location =  2) in vec3  c3;
layout(location =  3) in vec4  c4;

layout(location =  4) in float compare;
layout(location =  5) in float lod;
layout(location =  6) in float bias;
layout(location =  7) in float lodClamp;

layout(location =  8) in float dPdxy1;
layout(location =  9) in vec2  dPdxy2;
layout(location = 10) in vec3  dPdxy3;

layout(location = 11) in float16_t f16c1;
layout(location = 12) in f16vec2   f16c2;
layout(location = 13) in f16vec3   f16c3;
layout(location = 14) in f16vec4   f16c4;

layout(location = 15) in float16_t f16lod;
layout(location = 16) in float16_t f16bias;
layout(location = 17) in float16_t f16lodClamp;

layout(location = 18) in float16_t f16dPdxy1;
layout(location = 19) in f16vec2   f16dPdxy2;
layout(location = 20) in f16vec3   f16dPdxy3;

const int   offset1 = 1;
const ivec2 offset2 = ivec2(1);
const ivec3 offset3 = ivec3(1);
const ivec2 offsets[4] = { offset2, offset2, offset2, offset2 };

layout(location = 0) out vec4 fragColor;

f16vec4 testTexture()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += texture(s1D, c1);
    texel   += texture(s1D, f16c1, f16bias);
    texel   += texture(s2D, c2);
    texel   += texture(s2D, f16c2, f16bias);
    texel   += texture(s3D, c3);
    texel   += texture(s3D, f16c3, f16bias);
    texel   += texture(sCube, c3);
    texel   += texture(sCube, f16c3, f16bias);
    texel.x += texture(s1DShadow, c3);
    texel.x += texture(s1DShadow, f16c2, compare, f16bias);
    texel.x += texture(s2DShadow, c3);
    texel.x += texture(s2DShadow, f16c2, compare, f16bias);
    texel.x += texture(sCubeShadow, c4);
    texel.x += texture(sCubeShadow, f16c3, compare, f16bias);
    texel   += texture(s1DArray, c2);
    texel   += texture(s1DArray, f16c2, f16bias);
    texel   += texture(s2DArray, c3);
    texel   += texture(s2DArray, f16c3, f16bias);
    texel   += texture(sCubeArray, c4);
    texel   += texture(sCubeArray, f16c4, f16bias);
    texel.x += texture(s1DArrayShadow, c3);
    texel.x += texture(s1DArrayShadow, f16c2, compare, f16bias);
    texel.x += texture(s2DArrayShadow, c4);
    texel.x += texture(s2DArrayShadow, f16c3, compare);
    texel   += texture(s2DRect, c2);
    texel   += texture(s2DRect, f16c2);
    texel.x += texture(s2DRectShadow, c3);
    texel.x += texture(s2DRectShadow, f16c2, compare);
    texel.x += texture(sCubeArrayShadow, c4, compare);
    texel.x += texture(sCubeArrayShadow, f16c4, compare);

    return texel;
}

f16vec4 testTextureProj()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureProj(s1D, c2);
    texel   += textureProj(s1D, f16c2, f16bias);
    texel   += textureProj(s1D, c4);
    texel   += textureProj(s1D, f16c4, f16bias);
    texel   += textureProj(s2D, c3);
    texel   += textureProj(s2D, f16c3, f16bias);
    texel   += textureProj(s2D, c4);
    texel   += textureProj(s2D, f16c4, f16bias);
    texel   += textureProj(s3D, c4);
    texel   += textureProj(s3D, f16c4, f16bias);
    texel.x += textureProj(s1DShadow, c4);
    texel.x += textureProj(s1DShadow, f16c3, compare, f16bias);
    texel.x += textureProj(s2DShadow, c4);
    texel.x += textureProj(s2DShadow, f16c3, compare, f16bias);
    texel   += textureProj(s2DRect, c3);
    texel   += textureProj(s2DRect, f16c3);
    texel   += textureProj(s2DRect, c4);
    texel   += textureProj(s2DRect, f16c4);
    texel.x += textureProj(s2DRectShadow, c4);
    texel.x += textureProj(s2DRectShadow, f16c3, compare);

    return texel;
}

f16vec4 testTextureLod()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureLod(s1D, c1, lod);
    texel   += textureLod(s1D, f16c1, f16lod);
    texel   += textureLod(s2D, c2, lod);
    texel   += textureLod(s2D, f16c2, f16lod);
    texel   += textureLod(s3D, c3, lod);
    texel   += textureLod(s3D, f16c3, f16lod);
    texel   += textureLod(sCube, c3, lod);
    texel   += textureLod(sCube, f16c3, f16lod);
    texel.x += textureLod(s1DShadow, c3, lod);
    texel.x += textureLod(s1DShadow, f16c2, compare, f16lod);
    texel.x += textureLod(s2DShadow, c3, lod);
    texel.x += textureLod(s2DShadow, f16c2, compare, f16lod);
    texel   += textureLod(s1DArray, c2, lod);
    texel   += textureLod(s1DArray, f16c2, f16lod);
    texel   += textureLod(s2DArray, c3, lod);
    texel   += textureLod(s2DArray, f16c3, f16lod);
    texel.x += textureLod(s1DArrayShadow, c3, lod);
    texel.x += textureLod(s1DArrayShadow, f16c2, compare, f16lod);
    texel   += textureLod(sCubeArray, c4, lod);
    texel   += textureLod(sCubeArray, f16c4, f16lod);

    return texel;
}

f16vec4 testTextureOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureOffset(s1D, c1, offset1);
    texel   += textureOffset(s1D, f16c1, offset1, f16bias);
    texel   += textureOffset(s2D, c2, offset2);
    texel   += textureOffset(s2D, f16c2, offset2, f16bias);
    texel   += textureOffset(s3D, c3, offset3);
    texel   += textureOffset(s3D, f16c3, offset3, f16bias);
    texel   += textureOffset(s2DRect, c2, offset2);
    texel   += textureOffset(s2DRect, f16c2, offset2);
    texel.x += textureOffset(s2DRectShadow, c3, offset2);
    texel.x += textureOffset(s2DRectShadow, f16c2, compare, offset2);
    texel.x += textureOffset(s1DShadow, c3, offset1);
    texel.x += textureOffset(s1DShadow, f16c2, compare, offset1, f16bias);
    texel.x += textureOffset(s2DShadow, c3, offset2);
    texel.x += textureOffset(s2DShadow, f16c2, compare, offset2, f16bias);
    texel   += textureOffset(s1DArray, c2, offset1);
    texel   += textureOffset(s1DArray, f16c2, offset1, f16bias);
    texel   += textureOffset(s2DArray, c3, offset2);
    texel   += textureOffset(s2DArray, f16c3, offset2, f16bias);
    texel.x += textureOffset(s1DArrayShadow, c3, offset1);
    texel.x += textureOffset(s1DArrayShadow, f16c2, compare, offset1, f16bias);
    texel.x += textureOffset(s2DArrayShadow, c4, offset2);
    texel.x += textureOffset(s2DArrayShadow, f16c3, compare, offset2);

    return texel;
}

f16vec4 testTextureProjOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureProjOffset(s1D, c2, offset1);
    texel   += textureProjOffset(s1D, f16c2, offset1, f16bias);
    texel   += textureProjOffset(s1D, c4, offset1);
    texel   += textureProjOffset(s1D, f16c4, offset1, f16bias);
    texel   += textureProjOffset(s2D, c3, offset2);
    texel   += textureProjOffset(s2D, f16c3, offset2, f16bias);
    texel   += textureProjOffset(s2D, c4, offset2);
    texel   += textureProjOffset(s2D, f16c4, offset2, f16bias);
    texel   += textureProjOffset(s3D, c4, offset3);
    texel   += textureProjOffset(s3D, f16c4, offset3, f16bias);
    texel   += textureProjOffset(s2DRect, c3, offset2);
    texel   += textureProjOffset(s2DRect, f16c3, offset2);
    texel   += textureProjOffset(s2DRect, c4, offset2);
    texel   += textureProjOffset(s2DRect, f16c4, offset2);
    texel.x += textureProjOffset(s2DRectShadow, c4, offset2);
    texel.x += textureProjOffset(s2DRectShadow, f16c3, compare, offset2);
    texel.x += textureProjOffset(s1DShadow, c4, offset1);
    texel.x += textureProjOffset(s1DShadow, f16c3, compare, offset1, f16bias);
    texel.x += textureProjOffset(s2DShadow, c4, offset2);
    texel.x += textureProjOffset(s2DShadow, f16c3, compare, offset2, f16bias); 

    return texel;
}

f16vec4 testTextureLodOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureLodOffset(s1D, c1, lod, offset1);
    texel   += textureLodOffset(s1D, f16c1, f16lod, offset1);
    texel   += textureLodOffset(s2D, c2, lod, offset2);
    texel   += textureLodOffset(s2D, f16c2, f16lod, offset2);
    texel   += textureLodOffset(s3D, c3, lod, offset3);
    texel   += textureLodOffset(s3D, f16c3, f16lod, offset3);
    texel.x += textureLodOffset(s1DShadow, c3, lod, offset1);
    texel.x += textureLodOffset(s1DShadow, f16c2, compare, f16lod, offset1);
    texel.x += textureLodOffset(s2DShadow, c3, lod, offset2);
    texel.x += textureLodOffset(s2DShadow, f16c2, compare, f16lod, offset2);
    texel   += textureLodOffset(s1DArray, c2, lod, offset1);
    texel   += textureLodOffset(s1DArray, f16c2, f16lod, offset1);
    texel   += textureLodOffset(s2DArray, c3, lod, offset2);
    texel   += textureLodOffset(s2DArray, f16c3, f16lod, offset2);
    texel.x += textureLodOffset(s1DArrayShadow, c3, lod, offset1);
    texel.x += textureLodOffset(s1DArrayShadow, f16c2, compare, f16lod, offset1);

    return texel;
}

f16vec4 testTextureProjLodOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureProjLodOffset(s1D, c2, lod, offset1);
    texel   += textureProjLodOffset(s1D, f16c2, f16lod, offset1);
    texel   += textureProjLodOffset(s1D, c4, lod, offset1);
    texel   += textureProjLodOffset(s1D, f16c4, f16lod, offset1);
    texel   += textureProjLodOffset(s2D, c3, lod, offset2);
    texel   += textureProjLodOffset(s2D, f16c3, f16lod, offset2);
    texel   += textureProjLodOffset(s2D, c4, lod, offset2);
    texel   += textureProjLodOffset(s2D, f16c4, f16lod, offset2);
    texel   += textureProjLodOffset(s3D, c4, lod, offset3);
    texel   += textureProjLodOffset(s3D, f16c4, f16lod, offset3);
    texel.x += textureProjLodOffset(s1DShadow, c4, lod, offset1);
    texel.x += textureProjLodOffset(s1DShadow, f16c3, compare, f16lod, offset1);
    texel.x += textureProjLodOffset(s2DShadow, c4, lod, offset2);
    texel.x += textureProjLodOffset(s2DShadow, f16c3, compare, f16lod, offset2);

    return texel;
}

f16vec4 testTexelFetch()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += texelFetch(s1D, int(c1), int(lod));
    texel   += texelFetch(s2D, ivec2(c2), int(lod));
    texel   += texelFetch(s3D, ivec3(c3), int(lod));
    texel   += texelFetch(s2DRect, ivec2(c2));
    texel   += texelFetch(s1DArray, ivec2(c2), int(lod));
    texel   += texelFetch(s2DArray, ivec3(c3), int(lod));
    texel   += texelFetch(sBuffer, int(c1));
    texel   += texelFetch(s2DMS, ivec2(c2), 1);
    texel   += texelFetch(s2DMSArray, ivec3(c3), 2);

    return texel;
}

f16vec4 testTexelFetchOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += texelFetchOffset(s1D, int(c1), int(lod), offset1);
    texel   += texelFetchOffset(s2D, ivec2(c2), int(lod), offset2);
    texel   += texelFetchOffset(s3D, ivec3(c3), int(lod), offset3);
    texel   += texelFetchOffset(s2DRect, ivec2(c2), offset2);
    texel   += texelFetchOffset(s1DArray, ivec2(c2), int(lod), offset1);
    texel   += texelFetchOffset(s2DArray, ivec3(c3), int(lod), offset2);

    return texel;
}

f16vec4 testTextureGrad()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGrad(s1D, c1, dPdxy1, dPdxy1);
    texel   += textureGrad(s1D, f16c1, f16dPdxy1, f16dPdxy1);
    texel   += textureGrad(s2D, c2, dPdxy2, dPdxy2);
    texel   += textureGrad(s2D, f16c2, f16dPdxy2, f16dPdxy2);
    texel   += textureGrad(s3D, c3, dPdxy3, dPdxy3);
    texel   += textureGrad(s3D, f16c3, f16dPdxy3, f16dPdxy3);
    texel   += textureGrad(sCube, c3, dPdxy3, dPdxy3);
    texel   += textureGrad(sCube, f16c3, f16dPdxy3, f16dPdxy3);
    texel   += textureGrad(s2DRect, c2, dPdxy2, dPdxy2);
    texel   += textureGrad(s2DRect, f16c2, f16dPdxy2, f16dPdxy2);
    texel.x += textureGrad(s2DRectShadow, c3, dPdxy2, dPdxy2);
    texel.x += textureGrad(s2DRectShadow, f16c2, compare, f16dPdxy2, f16dPdxy2);
    texel.x += textureGrad(s1DShadow, c3, dPdxy1, dPdxy1);
    texel.x += textureGrad(s1DShadow, f16c2, compare, f16dPdxy1, f16dPdxy1);
    texel.x += textureGrad(s2DShadow, c3, dPdxy2, dPdxy2);
    texel.x += textureGrad(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2);
    texel.x += textureGrad(sCubeShadow, c4, dPdxy3, dPdxy3);
    texel.x += textureGrad(sCubeShadow, f16c3, compare, f16dPdxy3, f16dPdxy3);
    texel   += textureGrad(s1DArray, c2, dPdxy1, dPdxy1);
    texel   += textureGrad(s1DArray, f16c2, f16dPdxy1, f16dPdxy1);
    texel   += textureGrad(s2DArray, c3, dPdxy2, dPdxy2);
    texel   += textureGrad(s2DArray, f16c3, f16dPdxy2, f16dPdxy2);
    texel.x += textureGrad(s1DArrayShadow, c3, dPdxy1, dPdxy1);
    texel.x += textureGrad(s1DArrayShadow, f16c2, compare, f16dPdxy1, f16dPdxy1);
    texel.x += textureGrad(s2DArrayShadow, c4, dPdxy2, dPdxy2);
    texel.x += textureGrad(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2);
    texel   += textureGrad(sCubeArray, c4, dPdxy3, dPdxy3);
    texel   += textureGrad(sCubeArray, f16c4, f16dPdxy3, f16dPdxy3);

    return texel;
}

f16vec4 testTextureGradOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGradOffset(s1D, c1, dPdxy1, dPdxy1, offset1);
    texel   += textureGradOffset(s1D, f16c1, f16dPdxy1, f16dPdxy1, offset1);
    texel   += textureGradOffset(s2D, c2, dPdxy2, dPdxy2, offset2);
    texel   += textureGradOffset(s2D, f16c2, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureGradOffset(s3D, c3, dPdxy3, dPdxy3, offset3);
    texel   += textureGradOffset(s3D, f16c3, f16dPdxy3, f16dPdxy3, offset3);
    texel   += textureGradOffset(s2DRect, c2, dPdxy2, dPdxy2, offset2);
    texel   += textureGradOffset(s2DRect, f16c2, f16dPdxy2, f16dPdxy2, offset2);
    texel.x += textureGradOffset(s2DRectShadow, c3, dPdxy2, dPdxy2, offset2);
    texel.x += textureGradOffset(s2DRectShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2);
    texel.x += textureGradOffset(s1DShadow, c3, dPdxy1, dPdxy1, offset1);
    texel.x += textureGradOffset(s1DShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, offset1);
    texel.x += textureGradOffset(s2DShadow, c3, dPdxy2, dPdxy2, offset2);
    texel.x += textureGradOffset(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureGradOffset(s1DArray, c2, dPdxy1, dPdxy1, offset1);
    texel   += textureGradOffset(s1DArray, f16c2, f16dPdxy1, f16dPdxy1, offset1);
    texel   += textureGradOffset(s2DArray, c3, dPdxy2, dPdxy2, offset2);
    texel   += textureGradOffset(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, offset2);
    texel.x += textureGradOffset(s1DArrayShadow, c3, dPdxy1, dPdxy1, offset1);
    texel.x += textureGradOffset(s1DArrayShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, offset1);
    texel.x += textureGradOffset(s2DArrayShadow, c4, dPdxy2, dPdxy2, offset2);
    texel.x += textureGradOffset(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2);

    return texel;
}

f16vec4 testTextureProjGrad()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureProjGrad(s1D, c2, dPdxy1, dPdxy1);
    texel   += textureProjGrad(s1D, f16c2, f16dPdxy1, f16dPdxy1);
    texel   += textureProjGrad(s1D, c4, dPdxy1, dPdxy1);
    texel   += textureProjGrad(s1D, f16c4, f16dPdxy1, f16dPdxy1);
    texel   += textureProjGrad(s2D, c3, dPdxy2, dPdxy2);
    texel   += textureProjGrad(s2D, f16c3, f16dPdxy2, f16dPdxy2);
    texel   += textureProjGrad(s2D, c4, dPdxy2, dPdxy2);
    texel   += textureProjGrad(s2D, f16c4, f16dPdxy2, f16dPdxy2);
    texel   += textureProjGrad(s3D, c4, dPdxy3, dPdxy3);
    texel   += textureProjGrad(s3D, f16c4, f16dPdxy3, f16dPdxy3);
    texel   += textureProjGrad(s2DRect, c3, dPdxy2, dPdxy2);
    texel   += textureProjGrad(s2DRect, f16c3, f16dPdxy2, f16dPdxy2);
    texel   += textureProjGrad(s2DRect, c4, dPdxy2, dPdxy2);
    texel   += textureProjGrad(s2DRect, f16c4, f16dPdxy2, f16dPdxy2);
    texel.x += textureProjGrad(s2DRectShadow, c4, dPdxy2, dPdxy2);
    texel.x += textureProjGrad(s2DRectShadow, f16c3, compare, f16dPdxy2, f16dPdxy2);
    texel.x += textureProjGrad(s1DShadow, c4, dPdxy1, dPdxy1);
    texel.x += textureProjGrad(s1DShadow, f16c3, compare, f16dPdxy1, f16dPdxy1);
    texel.x += textureProjGrad(s2DShadow, c4, dPdxy2, dPdxy2);
    texel.x += textureProjGrad(s2DShadow, f16c3, compare, f16dPdxy2, f16dPdxy2);

    return texel;
}

f16vec4 testTextureProjGradoffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureProjGradOffset(s1D, c2, dPdxy1, dPdxy1, offset1);
    texel   += textureProjGradOffset(s1D, f16c2, f16dPdxy1, f16dPdxy1, offset1);
    texel   += textureProjGradOffset(s1D, c4, dPdxy1, dPdxy1, offset1);
    texel   += textureProjGradOffset(s1D, f16c4, f16dPdxy1, f16dPdxy1, offset1);
    texel   += textureProjGradOffset(s2D, c3, dPdxy2, dPdxy2, offset2);
    texel   += textureProjGradOffset(s2D, f16c3, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureProjGradOffset(s2D, c4, dPdxy2, dPdxy2, offset2);
    texel   += textureProjGradOffset(s2D, f16c4, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureProjGradOffset(s2DRect, c3, dPdxy2, dPdxy2, offset2);
    texel   += textureProjGradOffset(s2DRect, f16c3, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureProjGradOffset(s2DRect, c4, dPdxy2, dPdxy2, offset2);
    texel   += textureProjGradOffset(s2DRect, f16c4, f16dPdxy2, f16dPdxy2, offset2);
    texel.x += textureProjGradOffset(s2DRectShadow, c4, dPdxy2, dPdxy2, offset2);
    texel.x += textureProjGradOffset(s2DRectShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2);
    texel   += textureProjGradOffset(s3D, c4, dPdxy3, dPdxy3, offset3);
    texel   += textureProjGradOffset(s3D, f16c4, f16dPdxy3, f16dPdxy3, offset3);
    texel.x += textureProjGradOffset(s1DShadow, c4, dPdxy1, dPdxy1, offset1);
    texel.x += textureProjGradOffset(s1DShadow, f16c3, compare, f16dPdxy1, f16dPdxy1, offset1);
    texel.x += textureProjGradOffset(s2DShadow, c4, dPdxy2, dPdxy2, offset2);
    texel.x += textureProjGradOffset(s2DShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2);

    return texel;
}

f16vec4 testTextureGather()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGather(s2D, c2, 0);
    texel   += textureGather(s2D, f16c2, 0, f16bias);
    texel   += textureGather(s2DArray, c3, 0);
    texel   += textureGather(s2DArray, f16c3, 0, f16bias);
    texel   += textureGather(sCube, c3, 0);
    texel   += textureGather(sCube, f16c3, 0, f16bias);
    texel   += textureGather(sCubeArray, c4, 0);
    texel   += textureGather(sCubeArray, f16c4, 0, f16bias);
    texel   += textureGather(s2DRect, c2, 0);
    texel   += textureGather(s2DRect, f16c2, 0);
    texel   += textureGather(s2DShadow, c2, compare);
    texel   += textureGather(s2DShadow, f16c2, compare);
    texel   += textureGather(s2DArrayShadow, c3, compare);
    texel   += textureGather(s2DArrayShadow, f16c3, compare);
    texel   += textureGather(sCubeShadow, c3, compare);
    texel   += textureGather(sCubeShadow, f16c3, compare);
    texel   += textureGather(sCubeArrayShadow, c4, compare);
    texel   += textureGather(sCubeArrayShadow, f16c4, compare);
    texel   += textureGather(s2DRectShadow, c2, compare);
    texel   += textureGather(s2DRectShadow, f16c2, compare);

    return texel;
}

f16vec4 testTextureGatherOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGatherOffset(s2D, c2, offset2, 0);
    texel   += textureGatherOffset(s2D, f16c2, offset2, 0, f16bias);
    texel   += textureGatherOffset(s2DArray, c3, offset2, 0);
    texel   += textureGatherOffset(s2DArray, f16c3, offset2, 0, f16bias);
    texel   += textureGatherOffset(s2DRect, c2, offset2, 0);
    texel   += textureGatherOffset(s2DRect, f16c2, offset2, 0);
    texel   += textureGatherOffset(s2DShadow, c2, compare, offset2);
    texel   += textureGatherOffset(s2DShadow, f16c2, compare, offset2);
    texel   += textureGatherOffset(s2DArrayShadow, c3, compare, offset2);
    texel   += textureGatherOffset(s2DArrayShadow, f16c3, compare, offset2);
    texel   += textureGatherOffset(s2DRectShadow, c2, compare, offset2);
    texel   += textureGatherOffset(s2DRectShadow, f16c2, compare, offset2);

    return texel;
}

f16vec4 testTextureGatherOffsets()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGatherOffsets(s2D, c2, offsets, 0);
    texel   += textureGatherOffsets(s2D, f16c2, offsets, 0, f16bias);
    texel   += textureGatherOffsets(s2DArray, c3, offsets, 0);
    texel   += textureGatherOffsets(s2DArray, f16c3, offsets, 0, f16bias);
    texel   += textureGatherOffsets(s2DRect, c2, offsets, 0);
    texel   += textureGatherOffsets(s2DRect, f16c2, offsets, 0);
    texel   += textureGatherOffsets(s2DShadow, c2, compare, offsets);
    texel   += textureGatherOffsets(s2DShadow, f16c2, compare, offsets);
    texel   += textureGatherOffsets(s2DArrayShadow, c3, compare, offsets);
    texel   += textureGatherOffsets(s2DArrayShadow, f16c3, compare, offsets);
    texel   += textureGatherOffsets(s2DRectShadow, c2, compare, offsets);
    texel   += textureGatherOffsets(s2DRectShadow, f16c2, compare, offsets);

    return texel;
}

f16vec4 testTextureGatherLod()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGatherLodAMD(s2D, c2, lod, 0);
    texel   += textureGatherLodAMD(s2D, f16c2, f16lod, 0);
    texel   += textureGatherLodAMD(s2DArray, c3, lod, 0);
    texel   += textureGatherLodAMD(s2DArray, f16c3, f16lod, 0);
    texel   += textureGatherLodAMD(sCube, c3, lod, 0);
    texel   += textureGatherLodAMD(sCube, f16c3, f16lod, 0);
    texel   += textureGatherLodAMD(sCubeArray, c4, lod, 0);
    texel   += textureGatherLodAMD(sCubeArray, f16c4, f16lod, 0);

    return texel;
}

f16vec4 testTextureGatherLodOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGatherLodOffsetAMD(s2D, c2, lod, offset2, 0);
    texel   += textureGatherLodOffsetAMD(s2D, f16c2, f16lod, offset2, 0);
    texel   += textureGatherLodOffsetAMD(s2DArray, c3, lod, offset2, 0);
    texel   += textureGatherLodOffsetAMD(s2DArray, f16c3, f16lod, offset2, 0);

    return texel;
}

f16vec4 testTextureGatherLodOffsets()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGatherLodOffsetsAMD(s2D, c2, lod, offsets, 0);
    texel   += textureGatherLodOffsetsAMD(s2D, f16c2, f16lod, offsets, 0);
    texel   += textureGatherLodOffsetsAMD(s2DArray, c3, lod, offsets, 0);
    texel   += textureGatherLodOffsetsAMD(s2DArray, f16c3, f16lod, offsets, 0);

    return texel;
}

ivec4 testTextureSize()
{
    ivec4 size = ivec4(0);

    size.x      += textureSize(s1D, int(lod));
    size.xy     += textureSize(s2D, int(lod));
    size.xyz    += textureSize(s3D, int(lod));
    size.xy     += textureSize(sCube, int(lod));
    size.x      += textureSize(s1DShadow, int(lod));
    size.xy     += textureSize(s2DShadow, int(lod));
    size.xy     += textureSize(sCubeShadow, int(lod));
    size.xyz    += textureSize(sCubeArray, int(lod));
    size.xyz    += textureSize(sCubeArrayShadow, int(lod));
    size.xy     += textureSize(s2DRect);
    size.xy     += textureSize(s2DRectShadow);
    size.xy     += textureSize(s1DArray, int(lod));
    size.xyz    += textureSize(s2DArray, int(lod));
    size.xy     += textureSize(s1DArrayShadow, int(lod));
    size.xyz    += textureSize(s2DArrayShadow, int(lod));
    size.x      += textureSize(sBuffer);
    size.xy     += textureSize(s2DMS);
    size.xyz    += textureSize(s2DMSArray);

    return size;
}

vec2 testTextureQueryLod()
{
    vec2 lod = vec2(0.0);

    lod  += textureQueryLod(s1D, c1);
    lod  += textureQueryLod(s1D, f16c1);
    lod  += textureQueryLod(s2D, c2);
    lod  += textureQueryLod(s2D, f16c2);
    lod  += textureQueryLod(s3D, c3);
    lod  += textureQueryLod(s3D, f16c3);
    lod  += textureQueryLod(sCube, c3);
    lod  += textureQueryLod(sCube, f16c3);
    lod  += textureQueryLod(s1DArray, c1);
    lod  += textureQueryLod(s1DArray, f16c1);
    lod  += textureQueryLod(s2DArray, c2);
    lod  += textureQueryLod(s2DArray, f16c2);
    lod  += textureQueryLod(sCubeArray, c3);
    lod  += textureQueryLod(sCubeArray, f16c3);
    lod  += textureQueryLod(s1DShadow, c1);
    lod  += textureQueryLod(s1DShadow, f16c1);
    lod  += textureQueryLod(s2DShadow, c2);
    lod  += textureQueryLod(s2DShadow, f16c2);
    lod  += textureQueryLod(sCubeArrayShadow, c3);
    lod  += textureQueryLod(sCubeArrayShadow, f16c3);
    lod  += textureQueryLod(s1DArrayShadow, c1);
    lod  += textureQueryLod(s1DArrayShadow, f16c1);
    lod  += textureQueryLod(s2DArrayShadow, c2);
    lod  += textureQueryLod(s2DArrayShadow, f16c2);
    lod  += textureQueryLod(sCubeArrayShadow, c3);
    lod  += textureQueryLod(sCubeArrayShadow, f16c3);

    return lod;
}

int testTextureQueryLevels()
{
    int levels = 0;

    levels  += textureQueryLevels(s1D);
    levels  += textureQueryLevels(s2D);
    levels  += textureQueryLevels(s3D);
    levels  += textureQueryLevels(sCube);
    levels  += textureQueryLevels(s1DShadow);
    levels  += textureQueryLevels(s2DShadow);
    levels  += textureQueryLevels(sCubeShadow);
    levels  += textureQueryLevels(sCubeArray);
    levels  += textureQueryLevels(sCubeArrayShadow);
    levels  += textureQueryLevels(s1DArray);
    levels  += textureQueryLevels(s2DArray);
    levels  += textureQueryLevels(s1DArrayShadow);
    levels  += textureQueryLevels(s2DArrayShadow);

    return levels;
}

int testTextureSamples()
{
    int samples = 0;

    samples += textureSamples(s2DMS);
    samples += textureSamples(s2DMSArray);

    return samples;
}

f16vec4 testImageLoad()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel += imageLoad(i1D, int(c1));
    texel += imageLoad(i2D, ivec2(c2));
    texel += imageLoad(i3D, ivec3(c3));
    texel += imageLoad(i2DRect, ivec2(c2));
    texel += imageLoad(iCube, ivec3(c3));
    texel += imageLoad(iBuffer, int(c1));
    texel += imageLoad(i1DArray, ivec2(c2));
    texel += imageLoad(i2DArray, ivec3(c3));
    texel += imageLoad(iCubeArray, ivec3(c3));
    texel += imageLoad(i2DMS, ivec2(c2), 1);
    texel += imageLoad(i2DMSArray, ivec3(c3), 1);

    return texel;
}

void testImageStore(f16vec4 data)
{
    imageStore(i1D, int(c1), data);
    imageStore(i2D, ivec2(c2), data);
    imageStore(i3D, ivec3(c3), data);
    imageStore(i2DRect, ivec2(c2), data);
    imageStore(iCube, ivec3(c3), data);
    imageStore(iBuffer, int(c1), data);
    imageStore(i1DArray, ivec2(c2), data);
    imageStore(i2DArray, ivec3(c3), data);
    imageStore(iCubeArray, ivec3(c3), data);
    imageStore(i2DMS, ivec2(c2), 1, data);
    imageStore(i2DMSArray, ivec3(c3), 1, data);
}

f16vec4 testSparseTexture()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureARB(s2D, c2, texel);
    sparseTextureARB(s2D, f16c2, texel, f16bias);
    sparseTextureARB(s3D, c3, texel);
    sparseTextureARB(s3D, f16c3, texel, f16bias);
    sparseTextureARB(sCube, c3, texel);
    sparseTextureARB(sCube, f16c3, texel, f16bias);
    sparseTextureARB(s2DShadow, c3, texel.x);
    sparseTextureARB(s2DShadow, f16c2, compare, texel.x, f16bias);
    sparseTextureARB(sCubeShadow, c4, texel.x);
    sparseTextureARB(sCubeShadow, f16c3, compare, texel.x, f16bias);
    sparseTextureARB(s2DArray, c3, texel);
    sparseTextureARB(s2DArray, f16c3, texel, f16bias);
    sparseTextureARB(sCubeArray, c4, texel);
    sparseTextureARB(sCubeArray, f16c4, texel, f16bias);
    sparseTextureARB(s2DArrayShadow, c4, texel.x);
    sparseTextureARB(s2DArrayShadow, f16c3, compare, texel.x);
    sparseTextureARB(s2DRect, c2, texel);
    sparseTextureARB(s2DRect, f16c2, texel);
    sparseTextureARB(s2DRectShadow, c3, texel.x);
    sparseTextureARB(s2DRectShadow, f16c2, compare, texel.x);
    sparseTextureARB(sCubeArrayShadow, c4, compare, texel.x);
    sparseTextureARB(sCubeArrayShadow, f16c4, compare, texel.x);

    return texel;
}

f16vec4 testSparseTextureLod()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureLodARB(s2D, c2, lod, texel);
    sparseTextureLodARB(s2D, f16c2, f16lod, texel);
    sparseTextureLodARB(s3D, c3, lod, texel);
    sparseTextureLodARB(s3D, f16c3, f16lod, texel);
    sparseTextureLodARB(sCube, c3, lod, texel);
    sparseTextureLodARB(sCube, f16c3, f16lod, texel);
    sparseTextureLodARB(s2DShadow, c3, lod, texel.x);
    sparseTextureLodARB(s2DShadow, f16c2, compare, f16lod, texel.x);
    sparseTextureLodARB(s2DArray, c3, lod, texel);
    sparseTextureLodARB(s2DArray, f16c3, f16lod, texel);
    sparseTextureLodARB(sCubeArray, c4, lod, texel);
    sparseTextureLodARB(sCubeArray, f16c4, f16lod, texel);

    return texel;
}

f16vec4 testSparseTextureOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureOffsetARB(s2D, c2, offset2, texel);
    sparseTextureOffsetARB(s2D, f16c2, offset2, texel, f16bias);
    sparseTextureOffsetARB(s3D, c3, offset3, texel);
    sparseTextureOffsetARB(s3D, f16c3, offset3, texel, f16bias);
    sparseTextureOffsetARB(s2DRect, c2, offset2, texel);
    sparseTextureOffsetARB(s2DRect, f16c2, offset2, texel);
    sparseTextureOffsetARB(s2DRectShadow, c3, offset2, texel.x);
    sparseTextureOffsetARB(s2DRectShadow, f16c2, compare, offset2, texel.x);
    sparseTextureOffsetARB(s2DShadow, c3, offset2, texel.x);
    sparseTextureOffsetARB(s2DShadow, f16c2, compare, offset2, texel.x, f16bias);
    sparseTextureOffsetARB(s2DArray, c3, offset2, texel);
    sparseTextureOffsetARB(s2DArray, f16c3, offset2, texel, f16bias);
    sparseTextureOffsetARB(s2DArrayShadow, c4, offset2, texel.x);
    sparseTextureOffsetARB(s2DArrayShadow, f16c3, compare, offset2, texel.x);

    return texel;
}

f16vec4 testSparseTextureLodOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureLodOffsetARB(s2D, c2, lod, offset2, texel);
    sparseTextureLodOffsetARB(s2D, f16c2, f16lod, offset2, texel);
    sparseTextureLodOffsetARB(s3D, c3, lod, offset3, texel);
    sparseTextureLodOffsetARB(s3D, f16c3, f16lod, offset3, texel);
    sparseTextureLodOffsetARB(s2DShadow, c3, lod, offset2, texel.x);
    sparseTextureLodOffsetARB(s2DShadow, f16c2, compare, f16lod, offset2, texel.x);
    sparseTextureLodOffsetARB(s2DArray, c3, lod, offset2, texel);
    sparseTextureLodOffsetARB(s2DArray, f16c3, f16lod, offset2, texel);

    return texel;
}

f16vec4 testSparseTextureGrad()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGradARB(s2D, c2, dPdxy2, dPdxy2, texel);
    sparseTextureGradARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, texel);
    sparseTextureGradARB(s3D, c3, dPdxy3, dPdxy3, texel);
    sparseTextureGradARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, texel);
    sparseTextureGradARB(sCube, c3, dPdxy3, dPdxy3, texel);
    sparseTextureGradARB(sCube, f16c3, f16dPdxy3, f16dPdxy3, texel);
    sparseTextureGradARB(s2DRect, c2, dPdxy2, dPdxy2, texel);
    sparseTextureGradARB(s2DRect, f16c2, f16dPdxy2, f16dPdxy2, texel);
    sparseTextureGradARB(s2DRectShadow, c3, dPdxy2, dPdxy2, texel.x);
    sparseTextureGradARB(s2DRectShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, texel.x);
    sparseTextureGradARB(s2DShadow, c3, dPdxy2, dPdxy2, texel.x);
    sparseTextureGradARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, texel.x);
    sparseTextureGradARB(sCubeShadow, c4, dPdxy3, dPdxy3, texel.x);
    sparseTextureGradARB(sCubeShadow, f16c3, compare, f16dPdxy3, f16dPdxy3, texel.x);
    sparseTextureGradARB(s2DArray, c3, dPdxy2, dPdxy2, texel);
    sparseTextureGradARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, texel);
    sparseTextureGradARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, texel.x);
    sparseTextureGradARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, texel.x);
    sparseTextureGradARB(sCubeArray, c4, dPdxy3, dPdxy3, texel);
    sparseTextureGradARB(sCubeArray, f16c4, f16dPdxy3, f16dPdxy3, texel);

    return texel;
}

f16vec4 testSparseTextureGradOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGradOffsetARB(s2D, c2, dPdxy2, dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s3D, c3, dPdxy3, dPdxy3, offset3, texel);
    sparseTextureGradOffsetARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, offset3, texel);
    sparseTextureGradOffsetARB(s2DRect, c2, dPdxy2, dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s2DRect, f16c2, f16dPdxy2, f16dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s2DRectShadow, c3, dPdxy2, dPdxy2, offset2, texel.x);
    sparseTextureGradOffsetARB(s2DRectShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2, texel.x);
    sparseTextureGradOffsetARB(s2DShadow, c3, dPdxy2, dPdxy2, offset2, texel.x);
    sparseTextureGradOffsetARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2, texel.x);
    sparseTextureGradOffsetARB(s2DArray, c3, dPdxy2, dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, offset2, texel);
    sparseTextureGradOffsetARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, offset2, texel.x);
    sparseTextureGradOffsetARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2, texel.x);

    return texel;
}

f16vec4 testSparseTexelFetch()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTexelFetchARB(s2D, ivec2(c2), int(lod), texel);
    sparseTexelFetchARB(s3D, ivec3(c3), int(lod), texel);
    sparseTexelFetchARB(s2DRect, ivec2(c2), texel);
    sparseTexelFetchARB(s2DArray, ivec3(c3), int(lod), texel);
    sparseTexelFetchARB(s2DMS, ivec2(c2), 1, texel);
    sparseTexelFetchARB(s2DMSArray, ivec3(c3), 2, texel);

    return texel;
}

f16vec4 testSparseTexelFetchOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTexelFetchOffsetARB(s2D, ivec2(c2), int(lod), offset2, texel);
    sparseTexelFetchOffsetARB(s3D, ivec3(c3), int(lod), offset3, texel);
    sparseTexelFetchOffsetARB(s2DRect, ivec2(c2), offset2, texel);
    sparseTexelFetchOffsetARB(s2DArray, ivec3(c3), int(lod), offset2, texel);

    return texel;
}

f16vec4 testSparseTextureGather()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGatherARB(s2D, c2, texel, 0);
    sparseTextureGatherARB(s2D, f16c2, texel, 0, f16bias);
    sparseTextureGatherARB(s2DArray, c3, texel, 0);
    sparseTextureGatherARB(s2DArray, f16c3, texel, 0, f16bias);
    sparseTextureGatherARB(sCube, c3, texel, 0);
    sparseTextureGatherARB(sCube, f16c3, texel, 0, f16bias);
    sparseTextureGatherARB(sCubeArray, c4, texel, 0);
    sparseTextureGatherARB(sCubeArray, f16c4, texel, 0, f16bias);
    sparseTextureGatherARB(s2DRect, c2, texel, 0);
    sparseTextureGatherARB(s2DRect, f16c2, texel, 0);
    sparseTextureGatherARB(s2DShadow, c2, compare, texel);
    sparseTextureGatherARB(s2DShadow, f16c2, compare, texel);
    sparseTextureGatherARB(s2DArrayShadow, c3, compare, texel);
    sparseTextureGatherARB(s2DArrayShadow, f16c3, compare, texel);
    sparseTextureGatherARB(sCubeShadow, c3, compare, texel);
    sparseTextureGatherARB(sCubeShadow, f16c3, compare, texel);
    sparseTextureGatherARB(sCubeArrayShadow, c4, compare, texel);
    sparseTextureGatherARB(sCubeArrayShadow, f16c4, compare, texel);
    sparseTextureGatherARB(s2DRectShadow, c2, compare, texel);
    sparseTextureGatherARB(s2DRectShadow, f16c2, compare, texel);

    return texel;
}

f16vec4 testSparseTextureGatherOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGatherOffsetARB(s2D, c2, offset2, texel, 0);
    sparseTextureGatherOffsetARB(s2D, f16c2, offset2, texel, 0, f16bias);
    sparseTextureGatherOffsetARB(s2DArray, c3, offset2, texel, 0);
    sparseTextureGatherOffsetARB(s2DArray, f16c3, offset2, texel, 0, f16bias);
    sparseTextureGatherOffsetARB(s2DRect, c2, offset2, texel, 0);
    sparseTextureGatherOffsetARB(s2DRect, f16c2, offset2, texel, 0);
    sparseTextureGatherOffsetARB(s2DShadow, c2, compare, offset2, texel);
    sparseTextureGatherOffsetARB(s2DShadow, f16c2, compare, offset2, texel);
    sparseTextureGatherOffsetARB(s2DArrayShadow, c3, compare, offset2, texel);
    sparseTextureGatherOffsetARB(s2DArrayShadow, f16c3, compare, offset2, texel);
    sparseTextureGatherOffsetARB(s2DRectShadow, c2, compare, offset2, texel);
    sparseTextureGatherOffsetARB(s2DRectShadow, f16c2, compare, offset2, texel);

    return texel;
}

f16vec4 testSparseTextureGatherOffsets()
{
    f16vec4 texel = f16vec4(0.0hf);
    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));

    sparseTextureGatherOffsetsARB(s2D, c2, constOffsets, texel, 0);
    sparseTextureGatherOffsetsARB(s2D, f16c2, constOffsets, texel, 0, f16bias);
    sparseTextureGatherOffsetsARB(s2DArray, c3, constOffsets, texel, 0);
    sparseTextureGatherOffsetsARB(s2DArray, f16c3, constOffsets, texel, 0, f16bias);
    sparseTextureGatherOffsetsARB(s2DRect, c2, constOffsets, texel, 0);
    sparseTextureGatherOffsetsARB(s2DRect, f16c2, constOffsets, texel, 0);
    sparseTextureGatherOffsetsARB(s2DShadow, c2, compare, constOffsets, texel);
    sparseTextureGatherOffsetsARB(s2DShadow, f16c2, compare, constOffsets, texel);
    sparseTextureGatherOffsetsARB(s2DArrayShadow, c3, compare, constOffsets, texel);
    sparseTextureGatherOffsetsARB(s2DArrayShadow, f16c3, compare, constOffsets, texel);
    sparseTextureGatherOffsetsARB(s2DRectShadow, c2, compare, constOffsets, texel);
    sparseTextureGatherOffsetsARB(s2DRectShadow, f16c2, compare, constOffsets, texel);

    return texel;
}

f16vec4 testSparseTextureGatherLod()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGatherLodAMD(s2D, c2, lod, texel, 0);
    sparseTextureGatherLodAMD(s2D, f16c2, f16lod, texel, 0);
    sparseTextureGatherLodAMD(s2DArray, c3, lod, texel, 0);
    sparseTextureGatherLodAMD(s2DArray, f16c3, f16lod, texel, 0);
    sparseTextureGatherLodAMD(sCube, c3, lod, texel, 0);
    sparseTextureGatherLodAMD(sCube, f16c3, f16lod, texel, 0);
    sparseTextureGatherLodAMD(sCubeArray, c4, lod, texel, 0);
    sparseTextureGatherLodAMD(sCubeArray, f16c4, f16lod, texel, 0);

    return texel;
}

f16vec4 testSparseTextureGatherLodOffset()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGatherLodOffsetAMD(s2D, c2, lod, offset2, texel, 0);
    sparseTextureGatherLodOffsetAMD(s2D, f16c2, f16lod, offset2, texel, 0);
    sparseTextureGatherLodOffsetAMD(s2DArray, c3, lod, offset2, texel, 0);
    sparseTextureGatherLodOffsetAMD(s2DArray, f16c3, f16lod, offset2, texel, 0);

    return texel;
}

f16vec4 testSparseTextureGatherLodOffsets()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGatherLodOffsetsAMD(s2D, c2, lod, offsets, texel, 0);
    sparseTextureGatherLodOffsetsAMD(s2D, f16c2, f16lod, offsets, texel, 0);
    sparseTextureGatherLodOffsetsAMD(s2DArray, c3, lod, offsets, texel, 0);
    sparseTextureGatherLodOffsetsAMD(s2DArray, f16c3, f16lod, offsets, texel, 0);

    return texel;
}

f16vec4 testSparseImageLoad()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseImageLoadARB(i2D, ivec2(c2), texel);
    sparseImageLoadARB(i3D, ivec3(c3), texel);
    sparseImageLoadARB(i2DRect, ivec2(c2), texel);
    sparseImageLoadARB(iCube, ivec3(c3), texel);
    sparseImageLoadARB(i2DArray, ivec3(c3), texel);
    sparseImageLoadARB(iCubeArray, ivec3(c3), texel);
    sparseImageLoadARB(i2DMS, ivec2(c2), 1, texel);
    sparseImageLoadARB(i2DMSArray, ivec3(c3), 2, texel);

    return texel;
}

f16vec4 testSparseTextureClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureClampARB(s2D, c2, lodClamp, texel);
    sparseTextureClampARB(s2D, f16c2, f16lodClamp, texel, f16bias);
    sparseTextureClampARB(s3D, c3, lodClamp, texel);
    sparseTextureClampARB(s3D, f16c3, f16lodClamp, texel, f16bias);
    sparseTextureClampARB(sCube, c3, lodClamp, texel);
    sparseTextureClampARB(sCube, f16c3, f16lodClamp, texel, f16bias);
    sparseTextureClampARB(s2DShadow, c3, lodClamp, texel.x);
    sparseTextureClampARB(s2DShadow, f16c2, compare, f16lodClamp, texel.x, f16bias);
    sparseTextureClampARB(sCubeShadow, c4, lodClamp, texel.x);
    sparseTextureClampARB(sCubeShadow, f16c3, compare, f16lodClamp, texel.x, f16bias);
    sparseTextureClampARB(s2DArray, c3, lodClamp, texel);
    sparseTextureClampARB(s2DArray, f16c3, f16lodClamp, texel, f16bias);
    sparseTextureClampARB(sCubeArray, c4, lodClamp, texel);
    sparseTextureClampARB(sCubeArray, f16c4, f16lodClamp, texel, f16bias);
    sparseTextureClampARB(s2DArrayShadow, c4, lodClamp, texel.x);
    sparseTextureClampARB(s2DArrayShadow, f16c3, compare, f16lodClamp, texel.x);
    sparseTextureClampARB(sCubeArrayShadow, c4, compare, lodClamp, texel.x);
    sparseTextureClampARB(sCubeArrayShadow, f16c4, compare, f16lodClamp, texel.x);

    return texel;
}

f16vec4 testTextureClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureClampARB(s1D, c1, lodClamp);
    texel   += textureClampARB(s1D, f16c1, f16lodClamp, f16bias);
    texel   += textureClampARB(s2D, c2, lodClamp);
    texel   += textureClampARB(s2D, f16c2, f16lodClamp, f16bias);
    texel   += textureClampARB(s3D, c3, lodClamp);
    texel   += textureClampARB(s3D, f16c3, f16lodClamp, f16bias);
    texel   += textureClampARB(sCube, c3, lodClamp);
    texel   += textureClampARB(sCube, f16c3, f16lodClamp, f16bias);
    texel.x += textureClampARB(s1DShadow, c3, lodClamp);
    texel.x += textureClampARB(s1DShadow, f16c2, compare, f16lodClamp, f16bias);
    texel.x += textureClampARB(s2DShadow, c3, lodClamp);
    texel.x += textureClampARB(s2DShadow, f16c2, compare, f16lodClamp, f16bias);
    texel.x += textureClampARB(sCubeShadow, c4, lodClamp);
    texel.x += textureClampARB(sCubeShadow, f16c3, compare, f16lodClamp, f16bias);
    texel   += textureClampARB(s1DArray, c2, lodClamp);
    texel   += textureClampARB(s1DArray, f16c2, f16lodClamp, f16bias);
    texel   += textureClampARB(s2DArray, c3, lodClamp);
    texel   += textureClampARB(s2DArray, f16c3, f16lodClamp, f16bias);
    texel   += textureClampARB(sCubeArray, c4, lodClamp);
    texel   += textureClampARB(sCubeArray, f16c4, f16lodClamp, f16bias);
    texel.x += textureClampARB(s1DArrayShadow, c3, lodClamp);
    texel.x += textureClampARB(s1DArrayShadow, f16c2, compare, f16lodClamp, f16bias);
    texel.x += textureClampARB(s2DArrayShadow, c4, lodClamp);
    texel.x += textureClampARB(s2DArrayShadow, f16c3, compare, f16lodClamp);
    texel.x += textureClampARB(sCubeArrayShadow, c4, compare, lodClamp);
    texel.x += textureClampARB(sCubeArrayShadow, f16c4, compare, f16lodClamp);

    return texel;
}

f16vec4 testSparseTextureOffsetClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureOffsetClampARB(s2D, c2, offset2, lodClamp, texel);
    sparseTextureOffsetClampARB(s2D, f16c2, offset2, f16lodClamp, texel, f16bias);
    sparseTextureOffsetClampARB(s3D, c3, offset3, lodClamp, texel);
    sparseTextureOffsetClampARB(s3D, f16c3, offset3, f16lodClamp, texel, f16bias);
    sparseTextureOffsetClampARB(s2DShadow, c3, offset2, lodClamp, texel.x);
    sparseTextureOffsetClampARB(s2DShadow, f16c2, compare, offset2, f16lodClamp, texel.x, f16bias);
    sparseTextureOffsetClampARB(s2DArray, c3, offset2, lodClamp, texel);
    sparseTextureOffsetClampARB(s2DArray, f16c3, offset2, f16lodClamp, texel, f16bias);
    sparseTextureOffsetClampARB(s2DArrayShadow, c4, offset2, lodClamp, texel.x);
    sparseTextureOffsetClampARB(s2DArrayShadow, f16c3, compare, offset2, f16lodClamp, texel.x);

    return texel;
}

f16vec4 testTextureOffsetClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureOffsetClampARB(s1D, c1, offset1, lodClamp);
    texel   += textureOffsetClampARB(s1D, f16c1, offset1, f16lodClamp, f16bias);
    texel   += textureOffsetClampARB(s2D, c2, offset2, lodClamp);
    texel   += textureOffsetClampARB(s2D, f16c2, offset2, f16lodClamp, f16bias);
    texel   += textureOffsetClampARB(s3D, c3, offset3, lodClamp);
    texel   += textureOffsetClampARB(s3D, f16c3, offset3, f16lodClamp, f16bias);
    texel.x += textureOffsetClampARB(s1DShadow, c3, offset1, lodClamp);
    texel.x += textureOffsetClampARB(s1DShadow, f16c2, compare, offset1, f16lodClamp, f16bias);
    texel.x += textureOffsetClampARB(s2DShadow, c3, offset2, lodClamp);
    texel.x += textureOffsetClampARB(s2DShadow, f16c2, compare, offset2, f16lodClamp, f16bias);
    texel   += textureOffsetClampARB(s1DArray, c2, offset1, lodClamp);
    texel   += textureOffsetClampARB(s1DArray, f16c2, offset1, f16lodClamp, f16bias);
    texel   += textureOffsetClampARB(s2DArray, c3, offset2, lodClamp);
    texel   += textureOffsetClampARB(s2DArray, f16c3, offset2, f16lodClamp, f16bias);
    texel.x += textureOffsetClampARB(s1DArrayShadow, c3, offset1, lodClamp);
    texel.x += textureOffsetClampARB(s1DArrayShadow, f16c2, compare, offset1, f16lodClamp, f16bias);
    texel.x += textureOffsetClampARB(s2DArrayShadow, c4, offset2, lodClamp);
    texel.x += textureOffsetClampARB(s2DArrayShadow, f16c3, compare, offset2, f16lodClamp);
    
    return texel;
}

f16vec4 testSparseTextureGradClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGradClampARB(s2D, c2, dPdxy2, dPdxy2, lodClamp, texel);
    sparseTextureGradClampARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, f16lodClamp, texel);
    sparseTextureGradClampARB(s3D, c3, dPdxy3, dPdxy3, lodClamp, texel);
    sparseTextureGradClampARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, f16lodClamp, texel);
    sparseTextureGradClampARB(sCube, c3, dPdxy3, dPdxy3, lodClamp, texel);
    sparseTextureGradClampARB(sCube, f16c3, f16dPdxy3, f16dPdxy3, f16lodClamp, texel);
    sparseTextureGradClampARB(s2DShadow, c3, dPdxy2, dPdxy2, lodClamp, texel.x);
    sparseTextureGradClampARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, f16lodClamp, texel.x);
    sparseTextureGradClampARB(sCubeShadow, c4, dPdxy3, dPdxy3, lodClamp, texel.x);
    sparseTextureGradClampARB(sCubeShadow, f16c3, compare, f16dPdxy3, f16dPdxy3, f16lodClamp, texel.x);
    sparseTextureGradClampARB(s2DArray, c3, dPdxy2, dPdxy2, lodClamp, texel);
    sparseTextureGradClampARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, f16lodClamp, texel);
    sparseTextureGradClampARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, lodClamp, texel.x);
    sparseTextureGradClampARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, f16lodClamp, texel.x);
    sparseTextureGradClampARB(sCubeArray, c4, dPdxy3, dPdxy3, lodClamp, texel);
    sparseTextureGradClampARB(sCubeArray, f16c4, f16dPdxy3, f16dPdxy3, f16lodClamp, texel);

    return texel;
}

f16vec4 testTextureGradClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGradClampARB(s1D, c1, dPdxy1, dPdxy1, lodClamp);
    texel   += textureGradClampARB(s1D, f16c1, f16dPdxy1, f16dPdxy1, f16lodClamp);
    texel   += textureGradClampARB(s2D, c2, dPdxy2, dPdxy2, lodClamp);
    texel   += textureGradClampARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, f16lodClamp);
    texel   += textureGradClampARB(s3D, c3, dPdxy3, dPdxy3, lodClamp);
    texel   += textureGradClampARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, f16lodClamp);
    texel   += textureGradClampARB(sCube, c3, dPdxy3, dPdxy3, lodClamp);
    texel   += textureGradClampARB(sCube, f16c3, f16dPdxy3, f16dPdxy3, f16lodClamp);
    texel.x += textureGradClampARB(s1DShadow, c3, dPdxy1, dPdxy1, lodClamp);
    texel.x += textureGradClampARB(s1DShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, f16lodClamp);
    texel.x += textureGradClampARB(s2DShadow, c3, dPdxy2, dPdxy2, lodClamp);
    texel.x += textureGradClampARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, f16lodClamp);
    texel.x += textureGradClampARB(sCubeShadow, c4, dPdxy3, dPdxy3, lodClamp);
    texel.x += textureGradClampARB(sCubeShadow, f16c3, compare, f16dPdxy3, f16dPdxy3, f16lodClamp);
    texel   += textureGradClampARB(s1DArray, c2, dPdxy1, dPdxy1, lodClamp);
    texel   += textureGradClampARB(s1DArray, f16c2, f16dPdxy1, f16dPdxy1, f16lodClamp);
    texel   += textureGradClampARB(s2DArray, c3, dPdxy2, dPdxy2, lodClamp);
    texel   += textureGradClampARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, f16lodClamp);
    texel.x += textureGradClampARB(s1DArrayShadow, c3, dPdxy1, dPdxy1, lodClamp);
    texel.x += textureGradClampARB(s1DArrayShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, f16lodClamp);
    texel.x += textureGradClampARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, lodClamp);
    texel.x += textureGradClampARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, f16lodClamp);
    texel   += textureGradClampARB(sCubeArray, c4, dPdxy3, dPdxy3, lodClamp);
    texel   += textureGradClampARB(sCubeArray, f16c4, f16dPdxy3, f16dPdxy3, f16lodClamp);

    return texel;
}

f16vec4 testSparseTextureGradOffsetClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    sparseTextureGradOffsetClampARB(s2D, c2, dPdxy2, dPdxy2, offset2, lodClamp, texel);
    sparseTextureGradOffsetClampARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp, texel);
    sparseTextureGradOffsetClampARB(s3D, c3, dPdxy3, dPdxy3, offset3, lodClamp, texel);
    sparseTextureGradOffsetClampARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, offset3, f16lodClamp, texel);
    sparseTextureGradOffsetClampARB(s2DShadow, c3, dPdxy2, dPdxy2, offset2, lodClamp, texel.x);
    sparseTextureGradOffsetClampARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp, texel.x);
    sparseTextureGradOffsetClampARB(s2DArray, c3, dPdxy2, dPdxy2, offset2, lodClamp, texel);
    sparseTextureGradOffsetClampARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp, texel);
    sparseTextureGradOffsetClampARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, offset2, lodClamp, texel.x);
    sparseTextureGradOffsetClampARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp, texel.x);

    return texel;
}

f16vec4 testTextureGradOffsetClamp()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += textureGradOffsetClampARB(s1D, c1, dPdxy1, dPdxy1, offset1, lodClamp);
    texel   += textureGradOffsetClampARB(s1D, f16c1, f16dPdxy1, f16dPdxy1, offset1, f16lodClamp);
    texel   += textureGradOffsetClampARB(s2D, c2, dPdxy2, dPdxy2, offset2, lodClamp);
    texel   += textureGradOffsetClampARB(s2D, f16c2, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp);
    texel   += textureGradOffsetClampARB(s3D, c3, dPdxy3, dPdxy3, offset3, lodClamp);
    texel   += textureGradOffsetClampARB(s3D, f16c3, f16dPdxy3, f16dPdxy3, offset3, f16lodClamp);
    texel.x += textureGradOffsetClampARB(s1DShadow, c3, dPdxy1, dPdxy1, offset1, lodClamp);
    texel.x += textureGradOffsetClampARB(s1DShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, offset1, f16lodClamp);
    texel.x += textureGradOffsetClampARB(s2DShadow, c3, dPdxy2, dPdxy2, offset2, lodClamp);
    texel.x += textureGradOffsetClampARB(s2DShadow, f16c2, compare, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp);
    texel   += textureGradOffsetClampARB(s1DArray, c2, dPdxy1, dPdxy1, offset1, lodClamp);
    texel   += textureGradOffsetClampARB(s1DArray, f16c2, f16dPdxy1, f16dPdxy1, offset1, f16lodClamp);
    texel   += textureGradOffsetClampARB(s2DArray, c3, dPdxy2, dPdxy2, offset2, lodClamp);
    texel   += textureGradOffsetClampARB(s2DArray, f16c3, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp);
    texel.x += textureGradOffsetClampARB(s1DArrayShadow, c3, dPdxy1, dPdxy1, offset1, lodClamp);
    texel.x += textureGradOffsetClampARB(s1DArrayShadow, f16c2, compare, f16dPdxy1, f16dPdxy1, offset1, f16lodClamp);
    texel.x += textureGradOffsetClampARB(s2DArrayShadow, c4, dPdxy2, dPdxy2, offset2, lodClamp);
    texel.x += textureGradOffsetClampARB(s2DArrayShadow, f16c3, compare, f16dPdxy2, f16dPdxy2, offset2, f16lodClamp);

    return texel;
}

f16vec4 testCombinedTextureSampler()
{
    f16vec4 texel = f16vec4(0.0hf);

    texel   += texture(f16sampler1D(t1D, s), c1);
    texel   += texture(f16sampler1D(t1D, s), f16c1, f16bias);
    texel   += texture(f16sampler2D(t2D, s), c2);
    texel   += texture(f16sampler2D(t2D, s), f16c2, f16bias);
    texel   += texture(f16sampler3D(t3D, s), c3);
    texel   += texture(f16sampler3D(t3D, s), f16c3, f16bias);
    texel   += texture(f16samplerCube(tCube, s), c3);
    texel   += texture(f16samplerCube(tCube, s), f16c3, f16bias);
    texel.x += texture(f16sampler1DShadow(t1D, sShadow), c3);
    texel.x += texture(f16sampler1DShadow(t1D, sShadow), f16c2, compare, f16bias);
    texel.x += texture(f16sampler2DShadow(t2D, sShadow), c3);
    texel.x += texture(f16sampler2DShadow(t2D, sShadow), f16c2, compare, f16bias);
    texel.x += texture(f16samplerCubeShadow(tCube, sShadow), c4);
    texel.x += texture(f16samplerCubeShadow(tCube, sShadow), f16c3, compare, f16bias);
    texel   += texture(f16sampler1DArray(t1DArray, s), c2);
    texel   += texture(f16sampler1DArray(t1DArray, s), f16c2, f16bias);
    texel   += texture(f16sampler2DArray(t2DArray, s), c3);
    texel   += texture(f16sampler2DArray(t2DArray, s), f16c3, f16bias);
    texel   += texture(f16samplerCubeArray(tCubeArray, s), c4);
    texel   += texture(f16samplerCubeArray(tCubeArray, s), f16c4, f16bias);
    texel.x += texture(f16sampler1DArrayShadow(t1DArray, sShadow), c3);
    texel.x += texture(f16sampler1DArrayShadow(t1DArray, sShadow), f16c2, compare, f16bias);
    texel.x += texture(f16sampler2DArrayShadow(t2DArray, sShadow), c4);
    texel.x += texture(f16sampler2DArrayShadow(t2DArray, sShadow), f16c3, compare);
    texel   += texture(f16sampler2DRect(t2DRect, s), c2);
    texel   += texture(f16sampler2DRect(t2DRect, s), f16c2);
    texel.x += texture(f16sampler2DRectShadow(t2DRect, sShadow), c3);
    texel.x += texture(f16sampler2DRectShadow(t2DRect, sShadow), f16c2, compare);
    texel.x += texture(f16samplerCubeArrayShadow(tCubeArray, sShadow), c4, compare);
    texel.x += texture(f16samplerCubeArrayShadow(tCubeArray, sShadow), f16c4, compare);

    return texel;
}

f16vec4 testSubpassLoad()
{
    return subpassLoad(subpass) + subpassLoad(subpassMS, 2);
}

void main()
{
    f16vec4 result = f16vec4(0.0hf);

    result  += testTexture();
    result  += testTextureProj();
    result  += testTextureLod();
    result  += testTextureOffset();
    result  += testTextureLodOffset();
    result  += testTextureProjLodOffset();
    result  += testTexelFetch();
    result  += testTexelFetchOffset();
    result  += testTextureGrad();
    result  += testTextureGradOffset();
    result  += testTextureProjGrad();
    result  += testTextureProjGradoffset();
    result  += testTextureGather();
    result  += testTextureGatherOffset();
    result  += testTextureGatherOffsets();
    result  += testTextureGatherLod();
    result  += testTextureGatherLodOffset();
    result  += testTextureGatherLodOffsets();

    result    += f16vec4(testTextureSize());
    result.xy += f16vec2(testTextureQueryLod());
    result.x  += float16_t(testTextureQueryLevels());
    result.x  += float16_t(testTextureSamples());

    result  += testImageLoad();
    testImageStore(result);

    result += testSparseTexture();
    result += testSparseTextureLod();
    result += testSparseTextureOffset();
    result += testSparseTextureLodOffset();
    result += testSparseTextureGrad();
    result += testSparseTextureGradOffset();
    result += testSparseTexelFetch();
    result += testSparseTexelFetchOffset();
    result += testSparseTextureGather();
    result += testSparseTextureGatherOffset();
    result += testSparseTextureGatherOffsets();
    result += testSparseTextureGatherLod();
    result += testSparseTextureGatherLodOffset();
    result += testSparseTextureGatherLodOffsets();

    result += testSparseImageLoad();

    result += testSparseTextureClamp();
    result += testTextureClamp();
    result += testSparseTextureOffsetClamp();
    result += testTextureOffsetClamp();
    result += testSparseTextureGrad();
    result += testTextureGrad();
    result += testSparseTextureGradOffsetClamp();
    result += testTextureGradOffsetClamp();

    result += testCombinedTextureSampler();
    result += testSubpassLoad();

    fragColor = result;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float16convertonlyarith.comp]=[
#version 450 core

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
    vec4 v = vec4(0.0);
    vec4(f16vec4(v));
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float16convertonlystorage.comp]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage : require

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
    vec4 v = vec4(0.0);
    vec4(f16vec4(v));
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float32.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

void main()
{
}

// Single float literals
void literal()
{
    const float32_t f32c  = 0.000001f;
    const f32vec2   f32cv = f32vec2(-0.25F, 0.03f);

    f32vec2 f32v;
    f32v.x  = f32c;
    f32v   += f32cv;
}

// Block memory layout
struct S
{
    float32_t  x;
    f32vec2    y;
    f32vec3    z;
};

layout(column_major, std140) uniform B1
{
    float32_t  a;
    f32vec2    b;
    f32vec3    c;
    float32_t  d[2];
    f32mat2x3  e;
    f32mat2x3  f[2];
    S          g;
    S          h[2];
};

// Specialization constant
layout(constant_id = 100) const float16_t sf16 = 0.125hf;
layout(constant_id = 101) const float32_t sf   = 0.25;
layout(constant_id = 102) const float64_t sd   = 0.5lf;

const float  f16_to_f = float(sf16);
const double f16_to_d = float(sf16);

const float16_t f_to_f16 = float16_t(sf);
const float16_t d_to_f16 = float16_t(sd);

void operators()
{
    float32_t f32;
    f32vec2   f32v;
    f32mat2x2 f32m;
    bool      b;

    // Arithmetic
    f32v += f32v;
    f32v -= f32v;
    f32v *= f32v;
    f32v /= f32v;
    f32v++;
    f32v--;
    ++f32m;
    --f32m;
    f32v = -f32v;
    f32m = -f32m;

    f32 = f32v.x + f32v.y;
    f32 = f32v.x - f32v.y;
    f32 = f32v.x * f32v.y;
    f32 = f32v.x / f32v.y;

    // Relational
    b = (f32v.x != f32);
    b = (f32v.y == f32);
    b = (f32v.x >  f32);
    b = (f32v.y <  f32);
    b = (f32v.x >= f32);
    b = (f32v.y <= f32);

    // Vector/matrix operations
    f32v = f32v * f32;
    f32m = f32m * f32;
    f32v = f32m * f32v;
    f32v = f32v * f32m;
    f32m = f32m * f32m;
}

void typeCast()
{
    bvec3   bv;
    f32vec3   f32v;
    f64vec3   f64v;
    i8vec3    i8v;
    u8vec3    u8v;
    i16vec3   i16v;
    u16vec3   u16v;
    i32vec3   i32v;
    u32vec3   u32v;
    i64vec3   i64v;
    u64vec3   u64v;
    f16vec3   f16v;

    f64v = f32v;            // float32_t -> float64_t

    f32v = f32vec3(bv);     // bool -> float32
    bv   = bvec3(f32v);     // float32 -> bool

    f32v = f32vec3(f64v);   // double -> float32
    f64v = f64vec3(f32v);   // float32 -> double

    f32v = f32vec3(f16v);   // float16 -> float32
    f16v = f16vec3(f32v);   // float32 -> float16

    i8v  = i8vec3(f32v);    //  float32 -> int8
    i16v = i16vec3(f32v);    // float32 -> int16
    i32v = i32vec3(f32v);    // float32 -> int32
    i64v = i64vec3(f32v);    // float32 -> int64

    u8v  = u8vec3(f32v);    //  float32 -> uint8
    u16v = u16vec3(f32v);    // float32 -> uint16
    u32v = u32vec3(f32v);    // float32 -> uint32
    u64v = u64vec3(f32v);    // float32 -> uint64
}

void builtinAngleTrigFuncs()
{
    f32vec4 f32v1, f32v2;

    f32v2 = radians(f32v1);
    f32v2 = degrees(f32v1);
    f32v2 = sin(f32v1);
    f32v2 = cos(f32v1);
    f32v2 = tan(f32v1);
    f32v2 = asin(f32v1);
    f32v2 = acos(f32v1);
    f32v2 = atan(f32v1, f32v2);
    f32v2 = atan(f32v1);
    f32v2 = sinh(f32v1);
    f32v2 = cosh(f32v1);
    f32v2 = tanh(f32v1);
    f32v2 = asinh(f32v1);
    f32v2 = acosh(f32v1);
    f32v2 = atanh(f32v1);
}

void builtinExpFuncs()
{
    f32vec2 f32v1, f32v2;

    f32v2 = pow(f32v1, f32v2);
    f32v2 = exp(f32v1);
    f32v2 = log(f32v1);
    f32v2 = exp2(f32v1);
    f32v2 = log2(f32v1);
    f32v2 = sqrt(f32v1);
    f32v2 = inversesqrt(f32v1);
}

void builtinCommonFuncs()
{
    f32vec3   f32v1, f32v2, f32v3;
    float32_t f32;
    bool  b;
    bvec3 bv;
    ivec3 iv;

    f32v2 = abs(f32v1);
    f32v2 = sign(f32v1);
    f32v2 = floor(f32v1);
    f32v2 = trunc(f32v1);
    f32v2 = round(f32v1);
    f32v2 = roundEven(f32v1);
    f32v2 = ceil(f32v1);
    f32v2 = fract(f32v1);
    f32v2 = mod(f32v1, f32v2);
    f32v2 = mod(f32v1, f32);
    f32v3 = modf(f32v1, f32v2);
    f32v3 = min(f32v1, f32v2);
    f32v3 = min(f32v1, f32);
    f32v3 = max(f32v1, f32v2);
    f32v3 = max(f32v1, f32);
    f32v3 = clamp(f32v1, f32, f32v2.x);
    f32v3 = clamp(f32v1, f32v2, f32vec3(f32));
    f32v3 = mix(f32v1, f32v2, f32);
    f32v3 = mix(f32v1, f32v2, f32v3);
    f32v3 = mix(f32v1, f32v2, bv);
    f32v3 = step(f32v1, f32v2);
    f32v3 = step(f32, f32v3);
    f32v3 = smoothstep(f32v1, f32v2, f32v3);
    f32v3 = smoothstep(f32, f32v1.x, f32v2);
    b     = isnan(f32);
    bv    = isinf(f32v1);
    f32v3 = fma(f32v1, f32v2, f32v3);
    f32v2 = frexp(f32v1, iv);
    f32v2 = ldexp(f32v1, iv);
}

void builtinGeometryFuncs()
{
    float32_t f32;
    f32vec3   f32v1, f32v2, f32v3;

    f32   = length(f32v1);
    f32   = distance(f32v1, f32v2);
    f32   = dot(f32v1, f32v2);
    f32v3 = cross(f32v1, f32v2);
    f32v2 = normalize(f32v1);
    f32v3 = faceforward(f32v1, f32v2, f32v3);
    f32v3 = reflect(f32v1, f32v2);
    f32v3 = refract(f32v1, f32v2, f32);
}

void builtinMatrixFuncs()
{
    f32mat2x3 f32m1, f32m2, f32m3;
    f32mat3x2 f32m4;
    f32mat3   f32m5;
    f32mat4   f32m6, f32m7;

    f32vec3 f32v1;
    f32vec2 f32v2;

    float32_t f32;

    f32m3 = matrixCompMult(f32m1, f32m2);
    f32m1 = outerProduct(f32v1, f32v2);
    f32m4 = transpose(f32m1);
    f32   = determinant(f32m5);
    f32m6 = inverse(f32m7);
}

void builtinVecRelFuncs()
{
    f32vec3 f32v1, f32v2;
    bvec3   bv;

    bv = lessThan(f32v1, f32v2);
    bv = lessThanEqual(f32v1, f32v2);
    bv = greaterThan(f32v1, f32v2);
    bv = greaterThanEqual(f32v1, f32v2);
    bv = equal(f32v1, f32v2);
    bv = notEqual(f32v1, f32v2);
}

in f32vec3 if32v;

void builtinFragProcFuncs()
{
    f32vec3 f32v;

    // Derivative
    f32v.x  = dFdx(if32v.x);
    f32v.y  = dFdy(if32v.y);
    f32v.xy = dFdxFine(if32v.xy);
    f32v.xy = dFdyFine(if32v.xy);
    f32v    = dFdxCoarse(if32v);
    f32v    = dFdxCoarse(if32v);

    f32v.x  = fwidth(if32v.x);
    f32v.xy = fwidthFine(if32v.xy);
    f32v    = fwidthCoarse(if32v);

    // Interpolation
    f32v.x  = interpolateAtCentroid(if32v.x);
    f32v.xy = interpolateAtSample(if32v.xy, 1);
    f32v    = interpolateAtOffset(if32v, f32vec2(0.5f));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.float64.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

void main()
{
}

// Single float literals
void literal()
{
    const float64_t f64c  = 0.000001LF;
    const f64vec2   f64cv = f64vec2(-0.25lF, 0.03Lf);

    f64vec2 f64v;
    f64v.x  = f64c;
    f64v   += f64cv;
}

// Block memory layout
struct S
{
    float64_t  x;
    f64vec2    y;
    f64vec3    z;
};

layout(column_major, std140) uniform B1
{
    float64_t  a;
    f64vec2    b;
    f64vec3    c;
    float64_t  d[2];
    f64mat2x3  e;
    f64mat2x3  f[2];
    S          g;
    S          h[2];
};

// Specialization constant
layout(constant_id = 100) const float16_t sf16 = 0.125hf;
layout(constant_id = 101) const float32_t sf   = 0.25;
layout(constant_id = 102) const float64_t sd   = 0.5lf;

const float  f16_to_f = float(sf16);
const double f16_to_d = float(sf16);

const float16_t f_to_f16 = float16_t(sf);
const float16_t d_to_f16 = float16_t(sd);

void operators()
{
    float64_t f64;
    f64vec2   f64v;
    f64mat2x2 f64m;
    bool      b;

    // Arithmetic
    f64v += f64v;
    f64v -= f64v;
    f64v *= f64v;
    f64v /= f64v;
    f64v++;
    f64v--;
    ++f64m;
    --f64m;
    f64v = -f64v;
    f64m = -f64m;

    f64 = f64v.x + f64v.y;
    f64 = f64v.x - f64v.y;
    f64 = f64v.x * f64v.y;
    f64 = f64v.x / f64v.y;

    // Relational
    b = (f64v.x != f64);
    b = (f64v.y == f64);
    b = (f64v.x >  f64);
    b = (f64v.y <  f64);
    b = (f64v.x >= f64);
    b = (f64v.y <= f64);

    // Vector/matrix operations
    f64v = f64v * f64;
    f64m = f64m * f64;
    f64v = f64m * f64v;
    f64v = f64v * f64m;
    f64m = f64m * f64m;
}

void typeCast()
{
    bvec3   bv;
    f32vec3   f32v;
    f64vec3   f64v;
    i8vec3    i8v;
    u8vec3    u8v;
    i16vec3   i16v;
    u16vec3   u16v;
    i32vec3   i32v;
    u32vec3   u32v;
    i64vec3   i64v;
    u64vec3   u64v;
    f16vec3   f16v;

    f64v = f64vec3(bv);     // bool -> float64
    bv   = bvec3(f64v);     // float64 -> bool

    f64v = f64vec3(f16v);   // float16 -> float64
    f16v = f16vec3(f64v);   // float64 -> float16

    i8v  = i8vec3(f64v);    //  float64 -> int8
    i16v = i16vec3(f64v);    // float64 -> int16
    i32v = i32vec3(f64v);    // float64 -> int32
    i64v = i64vec3(f64v);    // float64 -> int64

    u8v  = u8vec3(f64v);    //  float64 -> uint8
    u16v = u16vec3(f64v);    // float64 -> uint16
    u32v = u32vec3(f64v);    // float64 -> uint32
    u64v = u64vec3(f64v);    // float64 -> uint64
}

// Trig, pow, exp and log are not supported for f64

void builtinTranscendentalFuncs()
{
    f64vec2 f64v1, f64v2;

    f64v2 = sqrt(f64v1);
    f64v2 = inversesqrt(f64v1);
}

void builtinCommonFuncs()
{
    f64vec3   f64v1, f64v2, f64v3;
    float64_t f64;
    bool  b;
    bvec3 bv;
    ivec3 iv;

    f64v2 = abs(f64v1);
    f64v2 = sign(f64v1);
    f64v2 = floor(f64v1);
    f64v2 = trunc(f64v1);
    f64v2 = round(f64v1);
    f64v2 = roundEven(f64v1);
    f64v2 = ceil(f64v1);
    f64v2 = fract(f64v1);
    f64v2 = mod(f64v1, f64v2);
    f64v2 = mod(f64v1, f64);
    f64v3 = modf(f64v1, f64v2);
    f64v3 = min(f64v1, f64v2);
    f64v3 = min(f64v1, f64);
    f64v3 = max(f64v1, f64v2);
    f64v3 = max(f64v1, f64);
    f64v3 = clamp(f64v1, f64, f64v2.x);
    f64v3 = clamp(f64v1, f64v2, f64vec3(f64));
    f64v3 = mix(f64v1, f64v2, f64);
    f64v3 = mix(f64v1, f64v2, f64v3);
    f64v3 = mix(f64v1, f64v2, bv);
    f64v3 = step(f64v1, f64v2);
    f64v3 = step(f64, f64v3);
    f64v3 = smoothstep(f64v1, f64v2, f64v3);
    f64v3 = smoothstep(f64, f64v1.x, f64v2);
    b     = isnan(f64);
    bv    = isinf(f64v1);
    f64v3 = fma(f64v1, f64v2, f64v3);
    f64v2 = frexp(f64v1, iv);
    f64v2 = ldexp(f64v1, iv);
}

void builtinGeometryFuncs()
{
    float64_t f64;
    f64vec3   f64v1, f64v2, f64v3;

    f64   = length(f64v1);
    f64   = distance(f64v1, f64v2);
    f64   = dot(f64v1, f64v2);
    f64v3 = cross(f64v1, f64v2);
    f64v2 = normalize(f64v1);
    f64v3 = faceforward(f64v1, f64v2, f64v3);
    f64v3 = reflect(f64v1, f64v2);
    f64v3 = refract(f64v1, f64v2, f64);
}

void builtinMatrixFuncs()
{
    f64mat2x3 f64m1, f64m2, f64m3;
    f64mat3x2 f64m4;
    f64mat3   f64m5;
    f64mat4   f64m6, f64m7;

    f64vec3 f64v1;
    f64vec2 f64v2;

    float64_t f64;

    f64m3 = matrixCompMult(f64m1, f64m2);
    f64m1 = outerProduct(f64v1, f64v2);
    f64m4 = transpose(f64m1);
    f64   = determinant(f64m5);
    f64m6 = inverse(f64m7);
}

void builtinVecRelFuncs()
{
    f64vec3 f64v1, f64v2;
    bvec3   bv;

    bv = lessThan(f64v1, f64v2);
    bv = lessThanEqual(f64v1, f64v2);
    bv = greaterThan(f64v1, f64v2);
    bv = greaterThanEqual(f64v1, f64v2);
    bv = equal(f64v1, f64v2);
    bv = notEqual(f64v1, f64v2);
}

in flat f64vec3 if64v;

void builtinFragProcFuncs()
{
    f64vec3 f64v;

    // Derivative
    f64v.x  = dFdx(if64v.x);
    f64v.y  = dFdy(if64v.y);
    f64v.xy = dFdxFine(if64v.xy);
    f64v.xy = dFdyFine(if64v.xy);
    f64v    = dFdxCoarse(if64v);
    f64v    = dFdxCoarse(if64v);

    f64v.x  = fwidth(if64v.x);
    f64v.xy = fwidthFine(if64v.xy);
    f64v    = fwidthCoarse(if64v);

    // Interpolation
    f64v.x  = interpolateAtCentroid(if64v.x);
    f64v.xy = interpolateAtSample(if64v.xy, 1);
    f64v    = interpolateAtOffset(if64v, f64vec2(0.5f));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.flowControl.frag]=[
#version 140

in float d;
in vec4 bigColor, smallColor;
in vec4 otherColor;

in float c;
in vec4 BaseColor;

void main()
{
    vec4 color = BaseColor;
    vec4 color2;

    color2 = otherColor;

    if (c > d)
        color += bigColor;
    else
        color += smallColor;

    gl_FragColor = color * color2;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.for-complex-condition.vert]=[
#version 450
layout(location=0) out highp int r;
layout(location=0) in lowp int flag;
void main() {
  int i;
  for (i=0; i < (flag==1 ? 10 : 15) ; i++) { r = i; }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.for-continue-break.vert]=[
#version 310 es
void main() {
  int i;
  int A, B, C, D, E, F, G;
  for (i=0; i < 10 ; i++) {
    A = 1;
    if (i%2 ==0) {
      B = 1;
      continue;
      C = 1;
    }
    if (i%3 == 0) {
      D = 1;
      break;
      E = 1;
    }
    F = 12;
  }
  G = 99;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.for-nobody.vert]=[
#version 450
layout(location=0) out highp int r;
void main() {
  int i;
  for (i=0; i<10; i++);
  r = i;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.for-notest.vert]=[
#version 450
layout(location=0) out highp int r;
void main() {
  int i;
  for (i=0; ; i++) { r = i; }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.for-simple.vert]=[
#version 310 es
void main() {
  int i;
  int j;
  for (i=0; i < 10 ; i++) {
    j = 12;
  }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.forLoop.frag]=[
#version 140

in vec4 bigColor;
in vec4 BaseColor;
in float f;

flat in int Count;
flat in uvec4 v4;

void main()
{
    vec4 color = BaseColor;

    for (int i = 0; i < Count; ++i) {
        color += bigColor;
    }

    gl_FragColor = color;

    float sum = 0.0;
    for (int i = 0; i < 4; ++i)
        sum += v4[i];

    vec4 tv4;

    for (int i = 0; i < 4; ++i)
        tv4[i] = v4[i] * 4u;

    gl_FragColor += vec4(sum) + tv4;

    vec4 r;
    r.xyz = BaseColor.xyz;

    for (int i = 0; i < Count; ++i)
        r.w = f;

    gl_FragColor.xyz += r.xyz;

    for (int i = 0; i < 16; i += 4)
        gl_FragColor *= f;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.forwardFun.frag]=[
#version 140

precision mediump float;

in vec4 bigColor;
in vec4 BaseColor;
in float d;

void bar();
float foo(vec4);
float unreachableReturn();

void main()
{
    vec4 color = vec4(foo(BaseColor));

    bar();
    float f = unreachableReturn();
    
    gl_FragColor = color * f;
}

void bar()
{
}

float unreachableReturn()
{
    bar();
    if (d < 4.2)
        return 1.2;
    else
        return 4.5;
}

float foo(vec4 bar)
{
    return bar.x + bar.y;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fragmentDensity-es.frag]=[
#version 310 es

#extension GL_EXT_fragment_invocation_density : require

layout (location = 0) out highp ivec2 FragSize;
layout (location = 2) out highp int FragInvocationCount;

void main () {
    FragSize = gl_FragSizeEXT;
    FragInvocationCount = gl_FragInvocationCountEXT;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fragmentDensity-neg.frag]=[
#version 450

//make sure the builtins don't exist if the extension isn't enabled.
//#extension GL_EXT_fragment_invocation_density : require

layout (location = 0) out vec2 FragSize;
layout (location = 2) out int FragInvocationCount;

void main () {
    FragSize = gl_FragSizeEXT;
    FragInvocationCount = gl_FragInvocationCountEXT;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fragmentDensity.frag]=[
#version 450

#extension GL_EXT_fragment_invocation_density : require

layout (location = 0) out vec2 FragSize;
layout (location = 2) out int FragInvocationCount;

void main () {
    FragSize = gl_FragSizeEXT;
    FragInvocationCount = gl_FragInvocationCountEXT;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fragmentDensity.vert]=[
#version 450

// try using a fragment-only extension in a vertex shader
#extension GL_EXT_fragment_invocation_density : require

layout (location = 0) out uvec2 FragSize;
layout (location = 2) out int FragInvocationCount;

void main () {
    FragSize = gl_FragSizeEXT;
    FragInvocationCount = gl_FragInvocationCountEXT;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fsi.frag]=[
#version 450
#extension GL_ARB_fragment_shader_interlock : enable

layout(set = 0, binding = 0) coherent buffer B1 {
    layout(offset = 0)  int x;
} b1;

layout(set = 0, binding = 1, rgba32f) coherent uniform image2D im;

layout(sample_interlock_ordered) in;

void main() {

    beginInvocationInterlockARB();

    b1.x = 1;
    imageStore(im, ivec2(0,0), vec4(0));

    endInvocationInterlockARB();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fsi_Error.frag]=[
#version 450
#extension GL_ARB_fragment_shader_interlock : enable

layout(pixel_interlock_ordered) out;

layout(pixel_interlock_ordered) in;
layout(pixel_interlock_unordered) in;

void foo()
{
    beginInvocationInterlockARB();
    endInvocationInterlockARB();
}

void main() {

    endInvocationInterlockARB();
    beginInvocationInterlockARB();

    return;

    endInvocationInterlockARB();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.fullyCovered.frag]=[
#version 450

#extension GL_NV_conservative_raster_underestimation : enable

out vec4 color;

void main() {
    color = vec4(gl_FragFullyCoveredNV, 0, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.functionCall.frag]=[
#version 140

varying vec4 bigColor;
varying vec4 BaseColor;
varying float d;

float h = 0.0;

float foo(vec4 bar)
{
    return bar.x + bar.y;
}

void bar()
{
}

float unreachableReturn()
{
    if (d < 4.2)
        return 1.2;
    else
        return 4.5;
    // might be another return inserted here by builders, has to be correct type
}

float missingReturn()
{
    if (d < 4.5) {
        h = d;
        return 3.9;
    }
}

void main()
{
    vec4 color = vec4(foo(BaseColor));

    bar();
    float f = unreachableReturn();
    float g = missingReturn();
    
    gl_FragColor = color * f * h;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.functionNestedOpaque.vert]=[
#version 450

uniform struct S {
     sampler2D s;
} si;

void foo(sampler2D t)
{
    texture(t, vec2(0.5));
}

void barc(const S p)
{
    foo(p.s);
}

void bar(S p)
{
    foo(p.s);
}

void main()
{
    barc(si);
    bar(si);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.functionParameterTypes.frag]=[
#version 460 core
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable

int f(int8_t i8,
       uint8_t u8,
       int16_t i16,
       uint16_t u16,
       int64_t i64,
       uint64_t u64,
       float16_t f16)
{
    return 0;
}

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.functionSemantics.frag]=[
#version 400

in float u;

int foo(int a, const int b, in int c, const in int d, out int e, inout int f)
{
    int sum = a + b + c + d + f; // no e, it is out only
	// sum should be 47 now

	a *= 64;
	// no b, it is read only
	c *= 64;
	// no d, it is read only
	e = 64 * 16; // e starts undefined
	f *= 64;

	sum += a + 64 * b + c + 64 * d + e + f; // everything has a value now, totaling of 64(1+2+4+8+16+32) = 64*63 = 4032
	// sum should be 4032 + 47  = 4079
	
	return sum;
}

int foo2(float a, vec3 b, out int r)
{
    r = int(3.0 * a);
    return int(5.0 * b.y);
}

int foo3()
{
    if (u > 3.2) {
        discard;
        return 1000000;
    }

    return 2000000;
}

void main()
{
    int e;
	int t = 2;
	struct s {
	    ivec4 t;
	} f;
	f.t.y = 32;

    // test the different qualifers
    int color = foo(1, 2, t+t, 8, e, f.t.y);

	color += 128 * (e + f.t.y); // right side should be 128(64(16 + 32)) = 393216
	// sum should be 4079 + 393216 = 397295
    
    // test conversions
    float arg;
    float ret;
    ret = foo2(4, ivec3(1,2,3), arg);  // ret = 10, param = 12.0
    color += int(ret + arg); // adds 22, for total of 397317

    color += foo3();         // theoretically, add 2000000, for total of 2397317

    gl_FragColor = vec4(color);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.glFragColor.frag]=[
#version 330

void main()
{
    gl_FragColor = vec4(1.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.glsl.register.autoassign.frag]=[
#version 450

uniform layout(binding=0) sampler       g_sSamp1;
uniform sampler       g_sSamp2;
uniform layout(binding=2) sampler       g_sSamp3[2];
uniform sampler       g_sSamp4[3];
uniform sampler       g_sSamp5;

uniform sampler       g_sSamp_unused1;
uniform sampler       g_sSamp_unused2;

uniform layout(binding=1) texture1D          g_tTex1;
uniform texture1D  g_tTex2;
uniform layout(binding=3) texture1D          g_tTex3[2];
uniform texture1D          g_tTex4[3];
uniform texture1D          g_tTex5;

uniform layout(binding=0)  texture1D          g_tTex_unused1;
uniform layout(binding=2)  texture1D          g_tTex_unused2;
uniform texture1D          g_tTex_unused3;

struct MyStruct_t {
    int a;
    float b;
    vec3 c;
};

uniform layout(binding=4) myblock {
    MyStruct_t mystruct;
    vec4 myvec4_a;
    vec4 myvec4_b;
    ivec4 myint4_a;
};

vec4 Func1()
{
    return
        texture(sampler1D(g_tTex1, g_sSamp1), 0.1) +
        texture(sampler1D(g_tTex2, g_sSamp2), 0.2) +
        texture(sampler1D(g_tTex3[0], g_sSamp3[0]), 0.3) +
        texture(sampler1D(g_tTex3[1], g_sSamp3[1]), 0.3) +
        texture(sampler1D(g_tTex4[1], g_sSamp4[1]), 0.4) +
        texture(sampler1D(g_tTex4[2], g_sSamp4[2]), 0.4) +
        texture(sampler1D(g_tTex5, g_sSamp5), 0.5) +
        mystruct.c[1];
}

vec4 Func2()
{
    return
        texture(sampler1D(g_tTex1, g_sSamp1), 0.1) +
        texture(sampler1D(g_tTex3[1], g_sSamp3[1]), 0.3);
}

// Not called from entry point:
vec4 Func2_unused()
{
    return
        texture(sampler1D(g_tTex_unused1, g_sSamp_unused1), 1.1) +
        texture(sampler1D(g_tTex_unused2, g_sSamp_unused2), 1.2);
}

out vec4 FragColor;

void main()
{
    FragColor = Func1() + Func2();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.glsl.register.noautoassign.frag]=[
#version 450

uniform layout(binding=0) sampler       g_sSamp1;
uniform layout(binding=1) sampler       g_sSamp2;
uniform layout(binding=2) sampler       g_sSamp3[2];
uniform layout(binding=3) sampler       g_sSamp4[3];
uniform layout(binding=4) sampler       g_sSamp5;

uniform layout(binding=5) sampler       g_sSamp_unused1;
uniform layout(binding=6) sampler       g_sSamp_unused2;

uniform layout(binding=7) texture1D          g_tTex1;
uniform layout(binding=8) texture1D          g_tTex2;
uniform layout(binding=9) texture1D          g_tTex3[2];
uniform layout(binding=10) texture1D          g_tTex4[3];
uniform layout(binding=11) texture1D          g_tTex5;

uniform layout(binding=12) texture1D          g_tTex_unused1;
uniform layout(binding=13) texture1D          g_tTex_unused2;
uniform layout(binding=14) texture1D          g_tTex_unused3;

struct MyStruct_t {
    int a;
    float b;
    vec3 c;
};

uniform layout(binding=4) myblock {
    MyStruct_t mystruct;
    vec4 myvec4_a;
    vec4 myvec4_b;
    ivec4 myint4_a;
};

vec4 Func1()
{
    return
        texture(sampler1D(g_tTex1, g_sSamp1), 0.1) +
        texture(sampler1D(g_tTex2, g_sSamp2), 0.2) +
        texture(sampler1D(g_tTex3[0], g_sSamp3[0]), 0.3) +
        texture(sampler1D(g_tTex3[1], g_sSamp3[1]), 0.3) +
        texture(sampler1D(g_tTex4[1], g_sSamp4[1]), 0.4) +
        texture(sampler1D(g_tTex4[2], g_sSamp4[2]), 0.4) +
        texture(sampler1D(g_tTex5, g_sSamp5), 0.5) +
        mystruct.c[1];
}

vec4 Func2()
{
    return
        texture(sampler1D(g_tTex1, g_sSamp1), 0.1) +
        texture(sampler1D(g_tTex3[1], g_sSamp3[1]), 0.3);
}

// Not called from entry point:
vec4 Func2_unused()
{
    return
        texture(sampler1D(g_tTex_unused1, g_sSamp_unused1), 1.1) +
        texture(sampler1D(g_tTex_unused2, g_sSamp_unused2), 1.2);
}

out vec4 FragColor;

void main()
{
    FragColor = Func1() + Func2();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.image.frag]=[
#version 450

layout(rgba32f, binding = 0)    uniform image1D         i1D;
layout(rgba32f, binding = 1)    uniform image2D         i2D;
layout(rgba32f, binding = 2)    uniform image3D         i3D;
layout(rgba32f, binding = 3)    uniform imageCube       iCube;
layout(rgba32f, binding = 4)    uniform imageCubeArray  iCubeArray;
layout(rgba32f, binding = 5)    uniform image2DRect     i2DRect;
layout(rgba32f, binding = 6)    uniform image1DArray    i1DArray;
layout(rg16, binding = 7)       uniform image2DArray    i2DArray;
layout(rgba32f, binding = 8)    uniform imageBuffer     iBuffer;
layout(rgba32f, binding = 9)    uniform image2DMS       i2DMS;
layout(rgba32f, binding = 10)   uniform image2DMSArray  i2DMSArray;

layout(r32i,    binding = 11)   uniform iimage1D        ii1D;
layout(r32ui,   binding = 12)   uniform uimage2D        ui2D;
layout(r32i,    binding = 13)   uniform iimage2DMS      ii2DMS;
layout(r32ui,   binding = 14)   uniform uimage2DMSArray ui2DMSArray;

flat in int     ic1D;
flat in ivec2   ic2D;
flat in ivec3   ic3D;
flat in ivec4   ic4D;

writeonly layout(binding = 1)   uniform image2D         wo2D;

flat in uint value;

out vec4 fragData;

void main()
{
    ivec3 iv = ivec3(0);
    iv.x    += imageSize(i1D);
    iv.xy   += imageSize(i2D);
    iv.xyz  += imageSize(i3D);
    iv.xy   += imageSize(iCube);
    iv.xyz  += imageSize(iCubeArray);
    iv.xy   += imageSize(i2DRect);
    iv.xy   += imageSize(i1DArray);
    iv.xyz  += imageSize(i2DArray);
    iv.x    += imageSize(iBuffer);
    iv.xy   += imageSize(i2DMS);
    iv.xyz  += imageSize(i2DMSArray);

    iv.x    += imageSamples(i2DMS);
    iv.x    += imageSamples(i2DMSArray);

    vec4 v = vec4(0.0);
    v += imageLoad(i1D, ic1D);
    imageStore(i1D, ic1D, v);
    v += imageLoad(i2D, ic2D);
    imageStore(i2D, ic2D, v);
    v += imageLoad(i3D, ic3D);
    imageStore(i3D, ic3D, v);
    v += imageLoad(iCube, ic3D);
    imageStore(iCube, ic3D, v);
    v += imageLoad(iCubeArray, ic3D);
    imageStore(iCubeArray, ic3D, v);
    v += imageLoad(i2DRect, ic2D);
    imageStore(i2DRect, ic2D, v);
    v += imageLoad(i1DArray, ic2D);
    imageStore(i1DArray, ic2D, v);
    v += imageLoad(i2DArray, ic3D);
    imageStore(i2DArray, ic3D, v);
    v += imageLoad(iBuffer, ic1D);
    imageStore(iBuffer, ic1D, v);
    v += imageLoad(i2DMS, ic2D, 1);
    imageStore(i2DMS, ic2D, 2, v);
    v += imageLoad(i2DMSArray, ic3D, 3);
    imageStore(i2DMSArray, ic3D, 4, v);

    uint ui = 0;
    iv.x    += imageAtomicAdd(ii1D, ic1D, 10);
    ui      += imageAtomicAdd(ui2D, ic2D, value);
    iv.x    += imageAtomicMin(ii1D, ic1D, 11);
    ui      += imageAtomicMin(ui2D, ic2D, value);
    iv.x    += imageAtomicMax(ii1D, ic1D, 12);
    ui      += imageAtomicMax(ui2D, ic2D, value);
    iv.x    += imageAtomicAnd(ii1D, ic1D, 13);
    ui      += imageAtomicAnd(ui2D, ic2D, value);
    iv.x    += imageAtomicOr(ii1D, ic1D, 14);
    ui      += imageAtomicOr(ui2D, ic2D, value);
    iv.x    += imageAtomicXor(ii1D, ic1D, 15);
    ui      += imageAtomicXor(ui2D, ic2D, value);
    iv.x    += imageAtomicExchange(ii1D, ic1D, 16);
    ui      += imageAtomicExchange(ui2D, ic2D, value);
    iv.x    += imageAtomicCompSwap(ii1D, ic1D, 18, 17);
    ui      += imageAtomicCompSwap(ui2D, ic2D, 19u, value);
    iv.x    += imageAtomicCompSwap(ii2DMS, ic2D, 2, 18, 17);
    ui      += imageAtomicCompSwap(ui2DMSArray, ic3D, 3, 19u, value);

    imageStore(wo2D, ic2D, v);

    fragData = ui != iv.y ? v : vec4(0.0); 
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.image.load-formatted.frag]=[
#version 450

#extension GL_EXT_shader_image_load_formatted : require

layout(binding = 0)    uniform image1D         i1D;
layout(binding = 1)    uniform image2D         i2D;
layout(binding = 2)    uniform image3D         i3D;
layout(binding = 3)    uniform imageCube       iCube;
layout(binding = 4)    uniform imageCubeArray  iCubeArray;
layout(binding = 5)    uniform image2DRect     i2DRect;
layout(binding = 6)    uniform image1DArray    i1DArray;
layout(binding = 7)       uniform image2DArray    i2DArray;
layout(binding = 8)    uniform imageBuffer     iBuffer;
layout(binding = 9)    uniform image2DMS       i2DMS;
layout(binding = 10)   uniform image2DMSArray  i2DMSArray;

flat in int     ic1D;
flat in ivec2   ic2D;
flat in ivec3   ic3D;
flat in ivec4   ic4D;

writeonly layout(binding = 1)   uniform image2D         wo2D;

flat in uint value;

out vec4 fragData;

void main()
{
    ivec3 iv = ivec3(0);
    iv.x    += imageSize(i1D);
    iv.xy   += imageSize(i2D);
    iv.xyz  += imageSize(i3D);
    iv.xy   += imageSize(iCube);
    iv.xyz  += imageSize(iCubeArray);
    iv.xy   += imageSize(i2DRect);
    iv.xy   += imageSize(i1DArray);
    iv.xyz  += imageSize(i2DArray);
    iv.x    += imageSize(iBuffer);
    iv.xy   += imageSize(i2DMS);
    iv.xyz  += imageSize(i2DMSArray);

    iv.x    += imageSamples(i2DMS);
    iv.x    += imageSamples(i2DMSArray);

    vec4 v = vec4(0.0);
    v += imageLoad(i1D, ic1D);
    imageStore(i1D, ic1D, v);
    v += imageLoad(i2D, ic2D);
    imageStore(i2D, ic2D, v);
    v += imageLoad(i3D, ic3D);
    imageStore(i3D, ic3D, v);
    v += imageLoad(iCube, ic3D);
    imageStore(iCube, ic3D, v);
    v += imageLoad(iCubeArray, ic3D);
    imageStore(iCubeArray, ic3D, v);
    v += imageLoad(i2DRect, ic2D);
    imageStore(i2DRect, ic2D, v);
    v += imageLoad(i1DArray, ic2D);
    imageStore(i1DArray, ic2D, v);
    v += imageLoad(i2DArray, ic3D);
    imageStore(i2DArray, ic3D, v);
    v += imageLoad(iBuffer, ic1D);
    imageStore(iBuffer, ic1D, v);
    v += imageLoad(i2DMS, ic2D, 1);
    imageStore(i2DMS, ic2D, 2, v);
    v += imageLoad(i2DMSArray, ic3D, 3);
    imageStore(i2DMSArray, ic3D, 4, v);

    imageStore(wo2D, ic2D, v);

    fragData = v;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.imageAtomic64.frag]=[
#version 450 core

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_EXT_shader_image_int64: enable
#extension GL_KHR_memory_scope_semantics: enable
#extension GL_ARB_sparse_texture2: enable
 
layout(binding = 0, r64i)  uniform i64image1D i1D;
layout(binding = 1, r64ui) uniform u64image2D u2D;
layout(binding = 2, r64i)  uniform i64image3D i3D;
layout(binding = 3, r64ui) uniform u64imageCube uCube;
layout(binding = 4, r64i)  uniform i64imageBuffer iBuf;
layout(binding = 5, r64ui) uniform u64image1DArray u1DArray;
layout(binding = 6, r64i)  uniform i64image2DArray i2DArray;
layout(binding = 7, r64ui) uniform u64imageCubeArray uCubeArray;
layout(binding = 8, r64i)  uniform i64image2DRect i2DRect;
layout(binding = 9, r64ui) uniform u64image2DMS u2DMS;
layout(binding = 10, r64i) uniform i64image2DMSArray i2DMSArray;

layout(binding = 11) buffer Buf
{
    int64_t i64;
    uint64_t u64;
    i64vec4 i64v4;
    u64vec4 u64v4;
    ivec4 i32v4;
};

void main()
{
    i64 = imageAtomicAdd(i1D, i32v4.x, i64);
    i64 = imageAtomicMin(i3D, i32v4.xyz, i64);
    i64 = imageAtomicMax(iBuf, i32v4.x, i64);
    i64 = imageAtomicAnd(i2DArray, i32v4.xyz, i64);
    i64 = imageAtomicOr(i2DRect, i32v4.xy, i64);
    i64 = imageAtomicXor(i2DMSArray, i32v4.xyz, i32v4.w, i64);
    i64 = imageAtomicExchange(i1D, i32v4.x, i64);
    i64 = imageAtomicCompSwap(i3D, i32v4.xyz, i64, i64 + 1);

    i64 = imageAtomicAdd(i1D, i32v4.x, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicMin(i3D, i32v4.xyz, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicMax(iBuf, i32v4.x, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicAnd(i2DArray, i32v4.xyz, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicOr(i2DRect, i32v4.xy, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicXor(i2DMSArray, i32v4.xyz, i32v4.w, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicExchange(i1D, i32v4.x, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicCompSwap(i3D, i32v4.xyz, i64, i64 + 1, gl_ScopeDevice,
            gl_StorageSemanticsImage, gl_SemanticsRelaxed, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    i64 = imageAtomicLoad(iBuf, i32v4.x, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(i2DArray, i32v4.xyz, i64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);

    u64 = imageAtomicAdd(u2D, i32v4.xy, u64);
    u64 = imageAtomicMin(uCube, i32v4.xyz, u64);
    u64 = imageAtomicMax(u1DArray, i32v4.xy, u64);
    u64 = imageAtomicAnd(uCubeArray, i32v4.xyz, u64);
    u64 = imageAtomicOr(u2DMS, i32v4.xy, i32v4.z, u64);
    u64 = imageAtomicXor(u2D, i32v4.xy, u64);
    u64 = imageAtomicExchange(uCube, i32v4.xyz, u64);
    u64 = imageAtomicCompSwap(u1DArray, i32v4.xy, u64, u64 + 1);

    u64 = imageAtomicAdd(u2D, i32v4.xy, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicMin(uCube, i32v4.xyz, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicMax(u1DArray, i32v4.xy, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicAnd(uCubeArray, i32v4.xyz, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicOr(u2DMS, i32v4.xy, i32v4.z, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicXor(u2D, i32v4.xy, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicExchange(uCube, i32v4.xyz, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicCompSwap(u1DArray, i32v4.xy, u64, u64 + 1, gl_ScopeDevice,
            gl_StorageSemanticsImage, gl_SemanticsRelaxed, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    u64 = imageAtomicLoad(uCubeArray, i32v4.xyz, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);
    imageAtomicStore(u2DMS, i32v4.xy, i32v4.z, u64, gl_ScopeDevice, gl_StorageSemanticsImage, gl_SemanticsRelaxed);

    i64v4 += imageLoad(i1D, i32v4.x);
    i64v4 += imageLoad(i3D, i32v4.xyz);
    i64v4 += imageLoad(iBuf, i32v4.x);
    i64v4 += imageLoad(i2DArray, i32v4.xyz);
    i64v4 += imageLoad(i2DRect, i32v4.xy);
    i64v4 += imageLoad(i2DMSArray, i32v4.xyz, i32v4.w);

    imageStore(u2D, i32v4.xy, u64v4);
    imageStore(uCube, i32v4.xyz, u64v4);
    imageStore(u1DArray, i32v4.xy, u64v4);
    imageStore(uCubeArray, i32v4.xyz, u64v4);
    imageStore(u2DMS, i32v4.xy, i32v4.z, u64v4);

    sparseImageLoadARB(i3D, i32v4.xyz, i64v4);
    sparseImageLoadARB(i2DArray, i32v4.xyz, i64v4);
    sparseImageLoadARB(i2DRect, i32v4.xy, i64v4);
    sparseImageLoadARB(u2D, i32v4.xy, u64v4);
    sparseImageLoadARB(uCube, i32v4.xyz, u64v4);
    sparseImageLoadARB(uCubeArray, i32v4.xyz, u64v4);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.imageLoadStoreLod.frag]=[
#version 450 core

#extension GL_AMD_shader_image_load_store_lod: enable
#extension GL_ARB_gpu_shader_int64: enable
#extension GL_EXT_shader_image_int64: enable

layout(rgba32f,  binding = 0) uniform image1D         i1D;
layout(rgba32f,  binding = 1) uniform image2D         i2D;
layout(rgba32f,  binding = 2) uniform image3D         i3D;
layout(rgba32i,  binding = 3) uniform iimageCube      iiCube;
layout(rgba32i,  binding = 4) uniform iimage1DArray   ii1DArray;
layout(rgba32ui, binding = 5) uniform uimage2DArray   ui2DArray;
layout(rgba32ui, binding = 6) uniform uimageCubeArray uiCubeArray;

layout(location = 0) out vec4 fragColor;

layout(r64i,  binding = 7)  uniform i64image1D        i64i1D;
layout(r64i,  binding = 8)  uniform i64image2D        i64i2D;
layout(r64i,  binding = 9)  uniform i64image3D        i64i3D;
layout(r64ui, binding = 10) uniform u64imageCube      u64iCube;
layout(r64ui, binding = 11) uniform u64image1DArray   u64i1DArray;
layout(r64ui, binding = 12) uniform u64image2DArray   u64i2DArray;
layout(r64ui, binding = 13) uniform u64imageCubeArray u64iCubeArray;

layout(binding = 14) buffer Buf
{
    i64vec4 i64v4;
    u64vec4 u64v4;
};

void main()
{
    const int c1 = 1;
    const ivec2 c2 = ivec2(2, 3);
    const ivec3 c3 = ivec3(4, 5, 6);

    const int lod = 3;

    vec4 f4 = vec4(0.0);
    f4 += imageLoadLodAMD(i1D, c1, lod);
    f4 += imageLoadLodAMD(i2D, c2, lod);
    f4 += imageLoadLodAMD(i3D, c3, lod);

    imageStoreLodAMD(iiCube, c3, lod, ivec4(f4));
    imageStoreLodAMD(ii1DArray, c2, lod, ivec4(f4));

    uvec4 u4;
    sparseImageLoadLodAMD(ui2DArray, c3, lod, u4);
    sparseImageLoadLodAMD(uiCubeArray, c3, lod, u4);

    fragColor = f4 + vec4(u4);

    i64v4 += imageLoadLodAMD(i64i1D, c1, lod);
    i64v4 += imageLoadLodAMD(i64i2D, c2, lod);
    i64v4 += imageLoadLodAMD(i64i3D, c3, lod);

    imageStoreLodAMD(u64iCube, c3, lod, u64v4);
    imageStoreLodAMD(u64i1DArray, c2, lod, u64v4);

    sparseImageLoadLodAMD(u64i2DArray, c3, lod, u64v4);
    sparseImageLoadLodAMD(u64iCubeArray, c3, lod, u64v4);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.int16.amd.frag]=[
#version 450 core

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_AMD_gpu_shader_int16: enable

layout(binding = 0) uniform Uniforms
{
    uint i;
};

// int16/uint16 in block
layout(std140, binding = 1) uniform Block
{
    i16vec3  i16v;
    uint16_t u16;
} block;

// int16/uint16 for input
layout(location = 0) in flat u16vec3 iu16v;
layout(location = 1) in flat int16_t ii16;

void literal()
{
    const int16_t i16c[3] =
    {
        0x111S,         // Hex
        -2s,            // Dec
        0400s,          // Oct
    };

    const uint16_t u16c[] =
    {
        0xFFFFus,       // Hex
        65535US,        // Dec
        0177777us,      // Oct
    };

    uint16_t u16 = i16c[i] + u16c[i];
}

void operators()
{
    u16vec3  u16v;
    int16_t  i16;
    uint16_t u16;
    int      i;
    uint     u;
    bool     b;

    // Unary
    u16v++;
    i16--;
    ++i16;
    --u16v;

    u16v = ~u16v;

    i16 = +i16;
    u16v = -u16v;

    // Arithmetic
    u16  += i16;
    u16v -= u16v;
    i16  *= i16;
    u16v /= u16v;
    u16v %= i16;

    u16v = u16v + u16v;
    u16  = i16 - u16;
    u16v = u16v * i16;
    i16  = i16 * i16;
    i16  = i16 % i16;

    // Shift
    u16v <<= i16;
    i16  >>= u16v.y;

    i16  = i16 << u16v.z;
    u16v = u16v << i16;

    // Relational
    b = (u16v.x != i16);
    b = (i16 == u16v.x);
    b = (u16v.x > u16v.y);
    b = (i16 < u);
    b = (u16v.y >= u16v.x);
    b = (i16 <= i);

    // Bitwise
    u16v |= i16;
    u16  = i16 | u16;
    i16  &= i16;
    u16v = u16v & u16v;
    u16v ^= i16;
    u16v = u16v ^ i16;
}

void typeCast()
{
    bvec2 bv;
    ivec2 iv;
    uvec2 uv;
    vec2  fv;
    dvec2 dv;

    f16vec2 f16v;
    i64vec2 i64v;
    u64vec2 u64v;
    i16vec2 i16v;
    u16vec2 u16v;

    i16v = i16vec2(bv);   // bool -> int16
    u16v = u16vec2(bv);   // bool -> uint16
    bv   = bvec2(i16v);   // int16  -> bool
    bv   = bvec2(u16v);   // uint16 -> bool

    i16v = i16vec2(iv);   // int -> int16
    u16v = u16vec2(iv);   // int -> uint16
    iv   = i16v;          // int16  -> int
    iv   = ivec2(u16v);   // uint16 -> int

    i16v = i16vec2(uv);   // uint -> int16
    u16v = u16vec2(uv);   // uint -> uint16
    uv   = i16v;          // int16  -> uint
    uv   = u16v;          // uint16 -> uint

    i16v = i16vec2(fv);   // float -> int16
    u16v = u16vec2(fv);   // float -> uint16
    fv   = i16v;          // int16  -> float
    fv   = u16v;          // uint16 -> float

    i16v = i16vec2(dv);   // double -> int16
    u16v = u16vec2(dv);   // double -> uint16
    dv   = i16v;          // int16  -> double
    dv   = u16v;          // uint16 -> double

    i16v = i16vec2(f16v); // float16 -> int16
    u16v = u16vec2(f16v); // float16 -> uint16
    f16v = i16v;          // int16  -> float16
    f16v = u16v;          // uint16 -> float16

    i16v = i16vec2(i64v); // int64 -> int16
    u16v = u16vec2(i64v); // int64 -> uint16
    i64v = i16v;          // int16  -> int64
    i64v = i64vec2(u16v); // uint16 -> int64

    i16v = i16vec2(u64v); // uint64 -> int16
    u16v = u16vec2(u64v); // uint64 -> uint16
    u64v = i16v;          // int16  -> uint64
    u64v = u16v;          // uint16 -> uint64

    i16v = i16vec2(u16v); // uint16 -> int16
    u16v = i16v;          // int16 -> uint16
}

void builtinFuncs()
{
    i16vec2  i16v;
    u16vec3  u16v;
    f16vec3  f16v;
    bvec3    bv;

    int16_t  i16;
    uint16_t u16;

    // abs()
    i16v = abs(i16v);

    // sign()
    i16v  = sign(i16v);

    // min()
    i16v = min(i16v, i16);
    i16v = min(i16v, i16vec2(-1s));
    u16v = min(u16v, u16);
    u16v = min(u16v, u16vec3(0us));

    // max()
    i16v = max(i16v, i16);
    i16v = max(i16v, i16vec2(-1s));
    u16v = max(u16v, u16);
    u16v = max(u16v, u16vec3(0us));

    // clamp()
    i16v = clamp(i16v, -i16, i16);
    i16v = clamp(i16v, -i16v, i16v);
    u16v = clamp(u16v, -u16, u16);
    u16v = clamp(u16v, -u16v, u16v);

    // mix()
    i16  = mix(i16v.x, i16v.y, true);
    i16v = mix(i16vec2(i16), i16vec2(-i16), bvec2(false));
    u16  = mix(u16v.x, u16v.y, true);
    u16v = mix(u16vec3(u16), u16vec3(-u16), bvec3(false));

    // frexp()
    i16vec3 exp;
    f16v = frexp(f16v, exp);

    // ldexp()
    f16v = ldexp(f16v, exp);

    // float16BitsToInt16()
    i16v = float16BitsToInt16(f16v.xy);

    // float16BitsToUint16()
    u16v.x = float16BitsToUint16(f16v.z);

    // int16BitsToFloat16()
    f16v.xy = int16BitsToFloat16(i16v);

    // uint16BitsToFloat16()
    f16v = uint16BitsToFloat16(u16v);

    // packInt2x16()
    int packi = packInt2x16(i16v);

    // unpackInt2x16()
    i16v = unpackInt2x16(packi);

    // packUint2x16()
    uint packu = packUint2x16(u16v.xy);

    // unpackUint2x16()
    u16v.xy = unpackUint2x16(packu);

    // packInt4x16()
    int64_t packi64 = packInt4x16(i16vec4(i16));

    // unpackInt4x16()
    i16v = unpackInt4x16(packi64).xy;

    // packUint4x16()
    uint64_t packu64 = packUint4x16(u16vec4(u16));

    // unpackUint4x16()
    u16v = unpackUint4x16(packu64).xyz;

    // lessThan()
    bv    = lessThan(u16v, u16vec3(u16));
    bv.xy = lessThan(i16v, i16vec2(i16));

    // lessThanEqual()
    bv    = lessThanEqual(u16v, u16vec3(u16));
    bv.xy = lessThanEqual(i16v, i16vec2(i16));

    // greaterThan()
    bv    = greaterThan(u16v, u16vec3(u16));
    bv.xy = greaterThan(i16v, i16vec2(i16));

    // greaterThanEqual()
    bv    = greaterThanEqual(u16v, u16vec3(u16));
    bv.xy = greaterThanEqual(i16v, i16vec2(i16));

    // equal()
    bv    = equal(u16v, u16vec3(u16));
    bv.xy = equal(i16v, i16vec2(i16));

    // notEqual()
    bv    = notEqual(u16v, u16vec3(u16));
    bv.xy = notEqual(i16v, i16vec2(i16));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int64_t  si64 = -10L;
layout(constant_id = 101) const uint64_t su64 = 20UL;
layout(constant_id = 102) const int  si = -5;
layout(constant_id = 103) const uint su = 4;
layout(constant_id = 104) const bool sb = true;
layout(constant_id = 105) const int16_t si16 = -5S;
layout(constant_id = 106) const uint16_t su16 = 4US;

// bool <-> int16/uint16
const bool i16_to_b = bool(si16);
const bool u16_to_b = bool(su16);
const int16_t  b_to_i16 = int16_t(sb);
const uint16_t b_to_u16 = uint16_t(sb);

// int <-> int16/uint16
const int i16_to_i = int(si16);
const int u16_to_i = int(su16);
const int16_t  i_to_i16 = int16_t(si);
const uint16_t i_to_u16 = uint16_t(si);

// uint <-> int16/uint16
const uint i16_to_u = uint(si16);
const uint u16_to_u = uint(su16);
const int16_t  u_to_i16 = int16_t(su);
const uint16_t u_to_u16 = uint16_t(su);

// int64 <-> int16/uint16
const int64_t i16_to_i64 = int64_t(si16);
const int64_t u16_to_i64 = int64_t(su16);
const int16_t  i64_to_i16 = int16_t(si64);
const uint16_t i64_to_u16 = uint16_t(si64);

// uint64 <-> int16/uint16
const uint64_t i16_to_u64 = uint64_t(si16);
const uint64_t u16_to_u64 = uint64_t(su16);
const int16_t  u64_to_i16 = int16_t(su64);
const uint16_t u64_to_u16 = uint16_t(su64);

// int16 <-> uint16
const uint16_t i16_to_u16 = uint16_t(si16);
const int16_t  u16_to_i16 = int16_t(su16);

void main()
{
    literal();
    operators();
    typeCast();
    builtinFuncs();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.int16.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    int16_t   i16;
    i16vec2   i16v2;
    i16vec3   i16v3;
    i16vec4   i16v4;
    uint16_t  u16;
    u16vec2   u16v2;
    u16vec3   u16v3;
    u16vec4   u16v4;
} block;

void main()
{
}

void literal()
{
    const int16_t i16Const[3] =
    {
        int16_t(-0x1111),           // Hex
        int16_t(-1),                // Dec
        int16_t(040000),            // Oct
    };

    int16_t i16 = i16Const[index];

    const uint16_t u16Const[] =
    {
        uint16_t(0xFFFF),             // Hex
        uint16_t(65535),              // Dec
        uint16_t(077777),             // Oct
    };

    uint16_t u16 = u16Const[index];
}

void typeCast16()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    i32v = i16v;     // int16_t  ->   int32_t
    i32v = u16v;     // uint16_t ->   int32_t
    u16v = i16v;     // int16_t  ->  uint16_t
    u32v = i16v;     // int16_t  ->  uint32_t
    i64v = i16v;     // int16_t  ->   int64_t
    u64v = i16v;     // int16_t  ->  uint64_t
    u32v = u16v;     // uint16_t ->  uint32_t
    i64v = u16v;     // uint16_t ->   int64_t
    u64v = u16v;     // uint16_t ->  uint64_t
    f16v = i16v;     // int16_t  ->  float16_t
    f32v = i16v;     // int16_t  ->  float32_t
    f64v = i16v;     // int16_t  ->  float64_t
    f16v = u16v;     // uint16_t ->  float16_t
    f32v = u16v;     // uint16_t ->  float32_t
    f64v = u16v;     // uint16_t ->  float64_t

    i32v = i32vec2(i16v);     // int16_t  ->   int32_t
    i32v = i32vec2(u16v);     // uint16_t ->   int32_t
    u16v = u16vec2(i16v);     // int16_t  ->  uint16_t
    u32v = u32vec2(i16v);     // int16_t  ->  uint32_t
    i64v = i64vec2(i16v);     // int16_t  ->   int64_t
    u64v = i64vec2(i16v);     // int16_t  ->  uint64_t
    u32v = u32vec2(u16v);     // uint16_t ->  uint32_t
    i64v = i64vec2(u16v);     // uint16_t ->   int64_t
    u64v = i64vec2(u16v);     // uint16_t ->  uint64_t
    f16v = f16vec2(i16v);     // int16_t  ->  float16_t
    f32v = f32vec2(i16v);     // int16_t  ->  float32_t
    f64v = f64vec2(i16v);     // int16_t  ->  float64_t
    f16v = f16vec2(u16v);     // uint16_t ->  float16_t
    f32v = f32vec2(u16v);     // uint16_t ->  float32_t
    f64v = f64vec2(u16v);     // uint16_t ->  float64_t

    i8v  = i8vec2(i16v);      // int16_t  ->   int8_t
    i8v  = i8vec2(u16v);      // uint16_t ->   int8_t
    u8v  = u8vec2(i16v);      // int16_t  ->  uint8_t
    u8v  = u8vec2(u16v);      // uint16_t ->  uint8_t
    i16v = u8vec2(u16v);      // uint16_t ->   int16_t
    i16v = i16vec2(bv);       // bool     ->   int16
    u16v = u16vec2(bv);       // bool     ->   uint16
    bv   = bvec2(i16v);       // int16    ->   bool
    bv   = bvec2(u16v);       // uint16   ->   bool
}
void operators()
{
    u16vec3 u16v;
    int16_t i16;
    uvec3   uv;
    int32_t i;
    int64_t i64;
    bool    b;
    float   f;
    float   arr[4] = {1.0, 2.0, 3.0, 4.0};

    // Unary
    u16v++;
    i16--;
    ++i16;
    --u16v;

    u16v = ~u16v;

    i16 = +i16;
    u16v = -u16v;

    // Arithmetic
    i16  += i16;
    u16v -= u16v;
    i  *= i16;
    uv /= u16v;
    uv %= i16;

    uv = u16v + uv;
    i64  = i16 - i64;
    uv = u16v * uv;
    i64  = i16 * i64;
    i  = i16 % i;

    // Shift
    u16v <<= i16;
    i16  >>= u16v.y;

    i16  = i16 << u16v.z;
    uv = u16v << i;

    // Relational
    b = (u16v.x != i16);
    b = (i16 == u16v.x);
    b = (u16v.x > uv.y);
    b = (i16 < i);
    b = (u16v.y >= uv.x);
    b = (i16 <= i);

    // Bitwise
    uv |= i16;
    i  = i16 | i;
    i64  &= i16;
    uv = u16v & uv;
    uv ^= i16;
    u16v = u16v ^ i16;

    // Index
    f = arr[i16];
}

void builtinFuncs()
{
    i16vec2  i16v;
    i16vec4  i16v4;
    u16vec3  u16v;
    u16vec2  u16v2;
    u16vec4  u16v4;
    bvec3   bv;
    int16_t i16;
    uint16_t u16;
    int32_t i32;
    uint32_t u32;
    int64_t i64;
    uint64_t u64;

    // abs()
    i16v = abs(i16v);

    // sign()
    i16  = sign(i16);

    // min()
    i16v = min(i16v, i16);
    i16v = min(i16v, i16vec2(-1));
    u16v = min(u16v, u16);
    u16v = min(u16v, u16vec3(0));

    // max()
    i16v = max(i16v, i16);
    i16v = max(i16v, i16vec2(-1));
    u16v = max(u16v, u16);
    u16v = max(u16v, u16vec3(0));

    // clamp()
    i16v = clamp(i16v, -i16, i16);
    i16v = clamp(i16v, -i16v, i16v);
    u16v = clamp(u16v, -u16, u16);
    u16v = clamp(u16v, -u16v, u16v);

    // mix()
    i16  = mix(i16v.x, i16v.y, true);
    i16v = mix(i16vec2(i16), i16vec2(-i16), bvec2(false));
    u16  = mix(u16v.x, u16v.y, true);
    u16v = mix(u16vec3(u16), u16vec3(-u16), bvec3(false));

    //pack
    i32 = pack32(i16v);
    i64 = pack64(i16v4);
    u32 = pack32(u16v2);
    u64 = pack64(u16v4);

    i16v  = unpack16(i32);
    i16v4 = unpack16(i64);
    u16v2 = unpack16(u32);
    u16v4 = unpack16(u64);

    // lessThan()
    bv    = lessThan(u16v, u16vec3(u16));
    bv.xy = lessThan(i16v, i16vec2(i16));

    // lessThanEqual()
    bv    = lessThanEqual(u16v, u16vec3(u16));
    bv.xy = lessThanEqual(i16v, i16vec2(i16));

    // greaterThan()
    bv    = greaterThan(u16v, u16vec3(u16));
    bv.xy = greaterThan(i16v, i16vec2(i16));

    // greaterThanEqual()
    bv    = greaterThanEqual(u16v, u16vec3(u16));
    bv.xy = greaterThanEqual(i16v, i16vec2(i16));

    // equal()
    bv    = equal(u16v, u16vec3(u16));
    bv.xy = equal(i16v, i16vec2(i16));

    // notEqual()
    bv    = notEqual(u16v, u16vec3(u16));
    bv.xy = notEqual(i16v, i16vec2(i16));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int16_t  si16 = int16_t(-10);
layout(constant_id = 101) const uint16_t su16 = uint16_t(20);

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.int32.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    int32_t   i32;
    i32vec2   i32v2;
    i32vec3   i32v3;
    i32vec4   i32v4;
    uint32_t  u32;
    u32vec2   u32v2;
    u32vec3   u32v3;
    u32vec4   u32v4;
} block;

void main()
{
}

void literal()
{

    const int32_t i32Const[3] =
    {
        -0x11111111,           // Hex
        -1,                    // Dec
        04000000000,           // Oct
    };

    int32_t i32 = i32Const[index];

    const uint32_t u32Const[] =
    {
        0xFFFFFFFF,             // Hex
        4294967295,             // Dec
        017777777777,           // Oct
    };

    uint32_t u32 = u32Const[index];
}

void typeCast32()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    u32v = i32v;     // int32_t  ->  uint32_t
    i64v = i32v;     // int32_t  ->   int64_t
    u64v = i32v;     // int32_t  ->  uint64_t
    i64v = u32v;     // uint32_t ->   int64_t
    u64v = u32v;     // uint32_t ->  uint64_t
    f32v = i32v;     // int32_t  ->  float32_t
    f64v = i32v;     // int32_t  ->  float64_t
    f32v = u32v;     // uint32_t ->  float32_t
    f64v = u32v;     // uint32_t ->  float64_t

    i8v =  i8vec2(i32v);       // int32_t   ->   int8_t
    i8v =  i8vec2(u32v);       // uint32_t  ->   int8_t
    i16v = i16vec2(i32v);      // int32_t   ->   int16_t
    i16v = i16vec2(u32v);      // uint32_t  ->   int16_t
    i32v = i32vec2(i32v);      // int32_t   ->   int32_t
    i32v = i32vec2(u32v);      // uint32_t  ->   int32_t
    i64v = i64vec2(i32v);      // int32_t   ->   int64_t
	i64v = i64vec2(u32v);      // uint32_t  ->   int64_t
	u8v =  u8vec2(i32v);       // int32_t   ->   uint8_t
    u8v =  u8vec2(u32v);       // uint32_t  ->   uint8_t
    u16v = u16vec2(i32v);      // int32_t   ->   uint16_t
    u16v = u16vec2(u32v);      // uint32_t  ->   uint16_t
    u32v = u32vec2(i32v);      // int32_t   ->   uint32_t
    u32v = u32vec2(u32v);      // uint32_t  ->   uint32_t
    u64v = u64vec2(i32v);      // int32_t   ->   uint64_t
    u64v = u64vec2(u32v);      // uint32_t  ->   uint64_t

    f16v = f16vec2(i32v);      // int32_t   ->  float16_t
    f32v = f32vec2(i32v);      // int32_t   ->  float32_t
    f64v = f64vec2(i32v);      // int32_t   ->  float64_t
    f16v = f16vec2(u32v);      // uint32_t  ->  float16_t
    f32v = f32vec2(u32v);      // uint32_t  ->  float32_t
    f64v = f64vec2(u32v);      // uint32_t  ->  float64_t

    i32v = i32vec2(bv);       // bool     ->   int32
    u32v = u32vec2(bv);       // bool     ->   uint32
    bv   = bvec2(i32v);       // int32    ->   bool
    bv   = bvec2(u32v);       // uint32   ->   bool
}

void operators()
{
    u32vec3 u32v;
    int32_t i32;
    uvec3   uv;
    int32_t i;
    int64_t i64;
    bool    b;

    // Unary
    u32v++;
    i32--;
    ++i32;
    --u32v;

    u32v = ~u32v;

    i32 = +i32;
    u32v = -u32v;

    // Arithmetic
    i32  += i32;
    u32v -= u32v;
    i  *= i32;
    uv /= u32v;
    uv %= i32;

    uv = u32v + uv;
    i64  = i32 - i64;
    uv = u32v * uv;
    i64  = i32 * i64;
    i  = i32 % i;

    // Shift
    u32v <<= i32;
    i32  >>= u32v.y;

    i64  = i64 << u32v.z;
    uv = u32v << i;

    // Relational
    b = (u32v.x != i32);
    b = (i32 == u32v.x);
    b = (u32v.x > uv.y);
    b = (i32 < i);
    b = (u32v.y >= uv.x);
    b = (i32 <= i);

    // Bitwise
    uv |= i32;
    i  = i32 | i;
    i64  &= i32;
    uv = u32v & uv;
    uv ^= i32;
    u32v = u32v ^ i32;
}

void builtinFuncs()
{
    i32vec2  i32v;
    i32vec4  i32v4;
    u32vec3  u32v;
    u32vec2  u32v2;
    u32vec4  u32v4;
    bvec3   bv;
    int32_t i32;
    uint32_t u32;
    int64_t i64;
    uint64_t u64;
    i8vec4  i8v4;
    u8vec4  u8v4;
    i16vec2  i16v2;
    u16vec2  u16v2;

    // abs()
    i32v = abs(i32v);

    // sign()
    i32  = sign(i32);

    // min()
    i32v = min(i32v, i32);
    i32v = min(i32v, i32vec2(-1));
    u32v = min(u32v, u32);
    u32v = min(u32v, u32vec3(0));

    // max()
    i32v = max(i32v, i32);
    i32v = max(i32v, i32vec2(-1));
    u32v = max(u32v, u32);
    u32v = max(u32v, u32vec3(0));

    // clamp()
    i32v = clamp(i32v, -i32, i32);
    i32v = clamp(i32v, -i32v, i32v);
    u32v = clamp(u32v, -u32, u32);
    u32v = clamp(u32v, -u32v, u32v);

    // mix()
    i32  = mix(i32v.x, i32v.y, true);
    i32v = mix(i32vec2(i32), i32vec2(-i32), bvec2(false));
    u32  = mix(u32v.x, u32v.y, true);
    u32v = mix(u32vec3(u32), u32vec3(-u32), bvec3(false));

    //pack
    i32 = pack32(i8v4);
    i32 = pack32(i16v2);
    u32 = pack32(u8v4);
    u32 = pack32(u16v2);

    i32v  = unpack32(i64);
    u32v2  = unpack32(u64);

    // lessThan()
    bv    = lessThan(u32v, u32vec3(u32));
    bv.xy = lessThan(i32v, i32vec2(i32));

    // lessThanEqual()
    bv    = lessThanEqual(u32v, u32vec3(u32));
    bv.xy = lessThanEqual(i32v, i32vec2(i32));

    // greaterThan()
    bv    = greaterThan(u32v, u32vec3(u32));
    bv.xy = greaterThan(i32v, i32vec2(i32));

    // greaterThanEqual()
    bv    = greaterThanEqual(u32v, u32vec3(u32));
    bv.xy = greaterThanEqual(i32v, i32vec2(i32));

    // equal()
    bv    = equal(u32v, u32vec3(u32));
    bv.xy = equal(i32v, i32vec2(i32));

    // notEqual()
    bv    = notEqual(u32v, u32vec3(u32));
    bv.xy = notEqual(i32v, i32vec2(i32));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int32_t  si32 = -10;
layout(constant_id = 101) const uint32_t su32 = 20U;
layout(constant_id = 102) const int  si = -5;
layout(constant_id = 103) const uint su = 4;
layout(constant_id = 104) const bool sb = true;

#define UINT32_MAX  4294967295u
uint32_t u32Max = UINT32_MAX;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.int64.frag]=[
#version 450

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    i64vec3  i64v;
    uint64_t u64;
} block;

void main()
{
}

void literal()
{
    const int64_t i64Const[3] =
    {
        -0x1111111111111111l,   // Hex
        -1l,                    // Dec
        040000000000l,          // Oct
    };

    int64_t i64 = i64Const[index];

    const uint64_t u64Const[] =
    {
        0xFFFFFFFFFFFFFFFFul,   // Hex
        4294967296UL,           // Dec
        077777777777ul,         // Oct
    };

    uint64_t u64 = u64Const[index];
}

void typeCast()
{
    bvec2 bv;
    ivec2 iv;
    uvec2 uv;
    vec2  fv;
    dvec2 dv;

    i64vec2 i64v;
    u64vec2 u64v;

    i64v = i64vec2(bv);   // bool -> int64
    u64v = u64vec2(bv);   // bool -> uint64

    i64v = iv;            // int   -> int64
    iv = ivec2(i64v);     // int64 -> int

    u64v = uv;            // uint   -> uint64
    uv = uvec2(u64v);     // uint64 -> uint

    fv = vec2(i64v);      // int64 -> float
    dv = i64v;            // int64 -> double

    fv = vec2(u64v);      // uint64 -> float
    dv = u64v;            // uint64 -> double

    i64v = i64vec2(fv);   // float  -> int64
    i64v = i64vec2(dv);   // double -> int64

    u64v = u64vec2(fv);   // float  -> uint64
    u64v = u64vec2(dv);   // double -> uint64

    bv = bvec2(i64v);     // int64  -> bool
    bv = bvec2(u64v);     // uint64 -> bool

    u64v = i64v;          // int64  -> uint64
    i64v = i64vec2(u64v); // uint64 -> int64

    uv = uvec2(i64v);     // int64 -> uint
    i64v = i64vec2(uv);   // uint -> int64
    iv = ivec2(u64v);     // uint64 -> int
    u64v = iv;            // int -> uint64
}

void operators()
{
    u64vec3 u64v;
    int64_t i64;
    uvec3   uv;
    int     i;
    bool    b;

    // Unary
    u64v++;
    i64--;
    ++i64;
    --u64v;

    u64v = ~u64v;

    i64 = +i64;
    u64v = -u64v;

    // Arithmetic
    i64  += i64;
    u64v -= u64v;
    i64  *= i;
    u64v /= uv;
    u64v %= i;

    u64v = u64v + uv;
    i64  = i64 - i;
    u64v = u64v * uv;
    i64  = i64 * i;
    i64  = i64 % i;

    // Shift
    u64v = u64v << i;
    i64 = i64 >> uv.y;
    u64v <<= i;
    i64  >>= uv.y;

    i64  = i64 << u64v.z;
    u64v = u64v << i64;

    // Relational
    b = (u64v.x != i64);
    b = (i64 == u64v.x);
    b = (u64v.x > uv.y);
    b = (i64 < i);
    b = (u64v.y >= uv.x);
    b = (i64 <= i);

    // Bitwise
    u64v |= i;
    i64  = i64 | i;
    i64  &= i;
    u64v = u64v & uv;
    u64v ^= i64;
    u64v = u64v ^ i64;
}

void builtinFuncs()
{
    i64vec2  i64v;
    u64vec3  u64v;
    dvec3    dv;
    bvec3    bv;

    int64_t  i64;
    uint64_t u64;

    // abs()
    i64v = abs(i64v);

    // sign()
    i64  = sign(i64);

    // min()
    i64v = min(i64v, i64);
    i64v = min(i64v, i64vec2(-1));
    u64v = min(u64v, u64);
    u64v = min(u64v, u64vec3(0));

    // max()
    i64v = max(i64v, i64);
    i64v = max(i64v, i64vec2(-1));
    u64v = max(u64v, u64);
    u64v = max(u64v, u64vec3(0));

    // clamp()
    i64v = clamp(i64v, -i64, i64);
    i64v = clamp(i64v, -i64v, i64v);
    u64v = clamp(u64v, -u64, u64);
    u64v = clamp(u64v, -u64v, u64v);

    // mix()
    i64  = mix(i64v.x, i64v.y, true);
    i64v = mix(i64vec2(i64), i64vec2(-i64), bvec2(false));
    u64  = mix(u64v.x, u64v.y, true);
    u64v = mix(u64vec3(u64), u64vec3(-u64), bvec3(false));

    // doubleBitsToInt64()
    i64v = doubleBitsToInt64(dv.xy);

    // doubleBitsToUint64()
    u64v.x = doubleBitsToUint64(dv.z);

    // int64BitsToDouble()
    dv.xy = int64BitsToDouble(i64v);

    // uint64BitsToDouble()
    dv = uint64BitsToDouble(u64v);

    // packInt2x32()
    i64 = packInt2x32(ivec2(1, 2));

    // unpackInt2x32()
    ivec2 iv = unpackInt2x32(i64);

    // packUint2x32()
    u64 = packUint2x32(uvec2(2, 3));

    // unpackUint2x32()
    uvec2 uv = unpackUint2x32(u64);

    // lessThan()
    bv    = lessThan(u64v, u64vec3(u64));
    bv.xy = lessThan(i64v, i64vec2(i64));

    // lessThanEqual()
    bv    = lessThanEqual(u64v, u64vec3(u64));
    bv.xy = lessThanEqual(i64v, i64vec2(i64));

    // greaterThan()
    bv    = greaterThan(u64v, u64vec3(u64));
    bv.xy = greaterThan(i64v, i64vec2(i64));

    // greaterThanEqual()
    bv    = greaterThanEqual(u64v, u64vec3(u64));
    bv.xy = greaterThanEqual(i64v, i64vec2(i64));

    // equal()
    bv    = equal(u64v, u64vec3(u64));
    bv.xy = equal(i64v, i64vec2(i64));

    // notEqual()
    bv    = notEqual(u64v, u64vec3(u64));
    bv.xy = notEqual(i64v, i64vec2(i64));

    // findLSB()
    i64   = findLSB(u64);
    i64v  = findLSB(u64vec2(u64));

    // bitCount()
    i64   = bitCount(u64);
    i64v  = bitCount(u64vec2(u64));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int64_t  si64 = -10L;
layout(constant_id = 101) const uint64_t su64 = 20UL;
layout(constant_id = 102) const int  si = -5;
layout(constant_id = 103) const uint su = 4;
layout(constant_id = 104) const bool sb = true;
layout(constant_id = 105) const uint64_t su64inc = su64 + 1UL;

// bool <-> int64/uint64
const bool i64_to_b = bool(si64);
const bool u64_to_b = bool(su64);
const int64_t  b_to_i64 = int64_t(sb);
const uint64_t b_to_u64 = uint64_t(sb);

// int <-> int64
const int     i64_to_i = int(si64);
const int64_t i_to_i64 = int64_t(si);

// uint <-> uint64
const uint     u64_to_u = uint(su64);
const uint64_t u_to_u64 = uint64_t(su);

// int64 <-> uint64
const int64_t  u64_to_i64 = int64_t(su64);
const uint64_t i64_to_u64 = uint64_t(si64);

// int <-> uint64
const int      u64_to_i = int(su64);
const uint64_t i_to_u64 = uint64_t(si);

// uint <-> int64
const uint    i64_to_u = uint(si64);
const int64_t u_to_i64 = int64_t(su);

#define UINT64_MAX  18446744073709551615ul
uint64_t u64Max = UINT64_MAX;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.int8.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    int8_t   i8;
    i8vec2   i8v2;
    i8vec3   i8v3;
    i8vec4   i8v4;
    uint8_t  u8;
    u8vec2   u8v2;
    u8vec3   u8v3;
    u8vec4   u8v4;
} block;

void main()
{
}

void literal()
{
    const int8_t i8Const[3] =
    {
        int8_t(-0x11),           // Hex
        int8_t(-1),              // Dec
        int8_t(0400),            // Oct
    };

    int8_t i8 = i8Const[index];

    const uint8_t u8Const[] =
    {
        uint8_t(0xFF),             // Hex
        uint8_t(255),              // Dec
        uint8_t(0177),             // Oct
    };

    uint8_t u8 = u8Const[index];
}

void typeCast8()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    u8v = i8v;      // int8_t  ->  uint8_t
    i16v = i8v;     // int8_t  ->   int16_t
    i16v = u8v;     // uint8_t ->   int16_t
    i32v = i8v;     // int8_t  ->   int32_t
    i32v = u8v;     // uint8_t ->   int32_t
    u32v = i8v;     // int8_t  ->  uint32_t
    i64v = i8v;     // int8_t  ->   int64_t
    u64v = i8v;     // int8_t  ->  uint64_t
    u32v = u8v;     // uint8_t ->  uint32_t
    i64v = u8v;     // uint8_t ->   int64_t
    u64v = u8v;     // uint8_t ->  uint64_t
    f16v = i8v;     // int8_t  ->  float16_t
    f32v = i8v;     // int8_t  ->  float32_t
    f64v = i8v;     // int8_t  ->  float64_t
    f16v = u8v;     // uint8_t ->  float16_t
    f32v = u8v;     // uint8_t ->  float32_t
    f64v = u8v;     // uint8_t ->  float64_t

    i8v =  i8vec2(u8v);       // uint8_t  ->   int8_t
    i16v = i16vec2(i8v);      // int8_t   ->   int16_t
    i16v = i16vec2(u8v);      // uint8_t  ->   int16_t
    i32v = i32vec2(i8v);      // int8_t   ->   int32_t
    i32v = i32vec2(u8v);      // uint8_t  ->   int32_t
    i64v = i64vec2(i8v);      // int8_t   ->   int64_t
    u64v = i64vec2(i8v);      // int8_t   ->  uint64_t
    u16v = u16vec2(i8v);      // int8_t   ->  uint16_t
    u16v = u16vec2(u8v);      // uint8_t  ->  uint16_t
    u32v = u32vec2(u8v);      // uint8_t  ->  uint32_t
    i64v = i64vec2(u8v);      // uint8_t  ->   int64_t
    u64v = i64vec2(u8v);      // uint8_t  ->  uint64_t
    f16v = f16vec2(i8v);      // int8_t   ->  float16_t
    f32v = f32vec2(i8v);      // int8_t   ->  float32_t
    f64v = f64vec2(i8v);      // int8_t   ->  float64_t
    f16v = f16vec2(u8v);      // uint8_t  ->  float16_t
    f32v = f32vec2(u8v);      // uint8_t  ->  float32_t
    f64v = f64vec2(u8v);      // uint8_t  ->  float64_t

    i8v = i8vec2(bv);       // bool     ->   int8
    u8v = u8vec2(bv);       // bool     ->   uint8
    bv  = bvec2(i8v);       // int8    ->   bool
    bv  = bvec2(u8v);       // uint8   ->   bool
}

void operators()
{
    u8vec3 u8v;
    int8_t i8;
    uvec3   uv;
    int32_t i;
    int16_t i16;
    bool    b;
    float   arr[4] = {1.0, 2.0, 3.0, 4.0};
    float   f;

    // Unary
    u8v++;
    i8--;
    ++i8;
    --u8v;

    u8v = ~u8v;

    i8 = +i8;
    u8v = -u8v;

    // Arithmetic
    i8  += i8;
    u8v -= u8v;
    i  *= i8;
    uv /= u8v;
    uv %= i8;

    uv = u8v + uv;
    i16  = i8 - i16;
    uv = u8v * uv;
    i16  = i8 * i16;
    i  = i8 % i;

    // Shift
    u8v <<= i8;
    i8  >>= u8v.y;

    i8  = i8 << u8v.z;
    u8v = u8v << i8;

    // Relational
    b = (u8v.x != i8);
    b = (i8 == u8v.x);
    b = (u8v.x > uv.y);
    b = (i8 < i);
    b = (u8v.y >= uv.x);
    b = (i8 <= i);

    // Bitwise
    uv |= i8;
    i  = i8 | i;
    i16  &= i8;
    uv = u8v & uv;
    uv ^= i8;
    u8v = u8v ^ i8;

    // Index
    f = arr[i8];
}

void builtinFuncs()
{
    i8vec2  i8v;
    i8vec4  i8v4;
    u8vec3  u8v;
    u8vec2  u8v2;
    u8vec4  u8v4;
    bvec3   bv;
    int16_t i16;
    int32_t i32;
    uint16_t u16;
    uint32_t u32;

    int8_t  i8;
    uint8_t u8;

    // abs()
    i8v = abs(i8v);

    // sign()
    i8  = sign(i8);

    // min()
    i8v = min(i8v, i8);
    i8v = min(i8v, i8vec2(-1));
    u8v = min(u8v, u8);
    u8v = min(u8v, u8vec3(0));

    // max()
    i8v = max(i8v, i8);
    i8v = max(i8v, i8vec2(-1));
    u8v = max(u8v, u8);
    u8v = max(u8v, u8vec3(0));

    // clamp()
    i8v = clamp(i8v, -i8, i8);
    i8v = clamp(i8v, -i8v, i8v);
    u8v = clamp(u8v, -u8, u8);
    u8v = clamp(u8v, -u8v, u8v);

    // mix()
    i8  = mix(i8v.x, i8v.y, true);
    i8v = mix(i8vec2(i8), i8vec2(-i8), bvec2(false));
    u8  = mix(u8v.x, u8v.y, true);
    u8v = mix(u8vec3(u8), u8vec3(-u8), bvec3(false));

    //pack
    i16 = pack16(i8v);
    i32 = pack32(i8v4);
    u16 = pack16(u8v2);
    u32 = pack32(u8v4);

    i8v  = unpack8(i16);
    i8v4 = unpack8(i32);
    u8v2 = unpack8(u16);
    u8v4 = unpack8(u32);

    // lessThan()
    bv    = lessThan(u8v, u8vec3(u8));
    bv.xy = lessThan(i8v, i8vec2(i8));

    // lessThanEqual()
    bv    = lessThanEqual(u8v, u8vec3(u8));
    bv.xy = lessThanEqual(i8v, i8vec2(i8));

    // greaterThan()
    bv    = greaterThan(u8v, u8vec3(u8));
    bv.xy = greaterThan(i8v, i8vec2(i8));

    // greaterThanEqual()
    bv    = greaterThanEqual(u8v, u8vec3(u8));
    bv.xy = greaterThanEqual(i8v, i8vec2(i8));

    // equal()
    bv    = equal(u8v, u8vec3(u8));
    bv.xy = equal(i8v, i8vec2(i8));

    // notEqual()
    bv    = notEqual(u8v, u8vec3(u8));
    bv.xy = notEqual(i8v, i8vec2(i8));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int8_t  si8 = int8_t(-10);
layout(constant_id = 101) const uint8_t su8 = uint8_t(20);

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.intOps.vert]=[
#version 310 es

in uint u1;
in uvec2 u2;
in uvec3 u3;
in uvec4 u4;

in float v1;
in vec2 v2;
in vec3 v3;
in vec4 v4;

in int i1;
in ivec2 i2;
in ivec3 i3;
in ivec4 i4;

out uvec4 uout;
out ivec4 iout;
out vec4 fout;

void main()
{
    iout = ivec4(0);
    uout = uvec4(0);
    fout = vec4(0.0);

    uvec2 u2out;
    uout.xy += uaddCarry(u2, u2, u2out);
    uout.xy += u2out;

    uint u1out;
    uout.x += usubBorrow(u1, u1, u1out);
    uout.x += u1out;

    uvec4 u4outHi, u4outLow;
    umulExtended(u4, u4, u4outHi, u4outLow);
    uout += u4outHi + u4outLow;

    ivec4 i4outHi, i4outLow;
    imulExtended(i4, i4, i4outHi, i4outLow);
    iout += i4outLow + i4outHi;

    ivec3 i3out;
    fout.xyz += frexp(v3, i3out);
    iout.xyz += i3out;
    int i1out;
    fout.x += frexp(v1, i1out);
    iout.x += i1out;

    fout.xy += ldexp(v2, i2);
    fout.x += ldexp(v1, i1);

    iout.x += bitfieldExtract(i1, 4, 5);
    uout.xyz += bitfieldExtract(u3, 4, 5);
    iout.xyz += bitfieldInsert(i3, i3, 4, 5);
    uout.x += bitfieldInsert(u1, u1, 4, 5);
    iout.xy += bitfieldReverse(i2);
    uout += bitfieldReverse(u4);
    iout.x += bitCount(i1);
    iout.xyz += bitCount(u3);

    iout.xy += findLSB(i2);
    iout += findLSB(u4);
    iout.x += findMSB(i1);
    iout.xy += findMSB(u2);

    uout.x += packUnorm4x8(v4);
    uout.x += packSnorm4x8(v4);
    fout += unpackUnorm4x8(u1);
    fout += unpackSnorm4x8(u1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.intcoopmat.comp]=[
#version 450 core
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_NV_cooperative_matrix : enable
#extension GL_NV_integer_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

const int X = 8;
layout(constant_id = 0) const int Y = 2;
const int Z = X*Y;

icoopmatNV<8, gl_ScopeSubgroup, Z, 8> miC;
icoopmatNV<8, gl_ScopeSubgroup, Z, 8> miC2[3];
ucoopmatNV<8, gl_ScopeSubgroup, Z, 8> muC;
ucoopmatNV<8, gl_ScopeSubgroup, Z, 8> muC2[3];

int iarr[miC.length()];
int iarr2[miC2[1].length()];
int uarr[muC.length()];
int uarr2[muC2[1].length()];

const icoopmatNV<32, gl_ScopeSubgroup, Z, 8> mD = icoopmatNV<32, gl_ScopeSubgroup, Z, 8>(1);
const ucoopmatNV<8, gl_ScopeSubgroup, 8, 8> mD2 = ucoopmatNV<8, gl_ScopeSubgroup, 8, 8>(1);

struct S { int a; int b; int c; };

const S s = S(12, 23, 34);

layout(set = 0, binding = 0, buffer_reference) coherent buffer Block {
    uint y[1024*1024];
    uint x[];
} block;

layout(set = 0, binding = 0) coherent buffer Block16 {
    int8_t y[1024*1024];
    int8_t x[];

    Block b;
} block8;

icoopmatNV<8, gl_ScopeSubgroup, 8, 8> ineg(icoopmatNV<8, gl_ScopeSubgroup, 8, 8> m) { return -m; }
ucoopmatNV<8, gl_ScopeSubgroup, 8, 8> umul(ucoopmatNV<8, gl_ScopeSubgroup, 8, 8> m) { return m * uint8_t(2); }

layout(constant_id = 2) const int SC = 1;
ucoopmatNV<32, gl_ScopeSubgroup, SC, SC> scm[SC][SC];

// sized for icoopmatNV<8, gl_ScopeSubgroup, 16, 16>
shared uvec4 shmatrix[16*16*2/16];

void main()
{
    ucoopmatNV<8, gl_ScopeSubgroup, 16, (2>1?8:4)> mu = ucoopmatNV<8, gl_ScopeSubgroup, 16, (2>1?8:4)>(2);
    icoopmatNV<8, gl_ScopeSubgroup, 16, (2>1?8:4)> mi = icoopmatNV<8, gl_ScopeSubgroup, 16, (2>1?8:4)>(2);

    mu = mu + mu;
    mu = mu - mu;
    mi = -mi;
    mi = mi * int8_t(2);

    fcoopmatNV<16, gl_ScopeSubgroup, 16, 8> mf16_0 = fcoopmatNV<16, gl_ScopeSubgroup, 16, 8>(mu);
    fcoopmatNV<32, gl_ScopeSubgroup, 16, 8> mf32_0 = fcoopmatNV<32, gl_ScopeSubgroup, 16, 8>(mu);
    fcoopmatNV<16, gl_ScopeSubgroup, 16, 8> mf16_1 = fcoopmatNV<16, gl_ScopeSubgroup, 16, 8>(mi);
    fcoopmatNV<32, gl_ScopeSubgroup, 16, 8> mf32_1 = fcoopmatNV<32, gl_ScopeSubgroup, 16, 8>(mi);

    uint8_t x = mu[1];
    mi[0] = int8_t(x);

    coopMatLoadNV(mi, block.x, 16, 128, false);
    coopMatStoreNV(mi, block.x, 16, 128, false);
    coopMatLoadNV(mu, block8.x, 16, 128, false);
    coopMatStoreNV(mu, block8.x, 16, 128, false);
    coopMatLoadNV(mi, block8.b.x, 16, 128, false);
    coopMatStoreNV(mi, block8.b.x, 16, 128, false);

    ucoopmatNV<8, gl_ScopeSubgroup, 16, 8> A;
    ucoopmatNV<8, gl_ScopeSubgroup, 8, 8> B;
    ucoopmatNV<8, gl_ScopeSubgroup, 16, 8> C;
    ucoopmatNV<8, gl_ScopeSubgroup, 16, 8> D;
    D = coopMatMulAddNV(A, B, C);

    int l = D.length();
.
.
    icoopmatNV<8, gl_ScopeSubgroup, 16, (2>1?8:4)> a[5];
    a[3][0] = int8_t(1);

    int md1 = mD[1];

    md1 += (mi += mi)[1234];

    muC2[0] = muC2[1];
    muC2[1][0] = (miC2[2][0]);

    coopMatLoadNV(mi, block.y, 16, 128, false);
    coopMatStoreNV(mi, block.y, 16, 128, false);
    coopMatLoadNV(mu, block8.y, 16, 128, false);
    coopMatStoreNV(mu, block8.y, 16, 128, false);

    icoopmatNV<8, gl_ScopeSubgroup, 8, 8> p1;
    ucoopmatNV<8, gl_ScopeSubgroup, 8, 8> p2;

    p1 = ineg(p1);
    p2 = umul(p2);

    p1 /= p1;
    p2 /= p2;

    p1 *= int8_t(2);
    p2 *= uint8_t(4);

    icoopmatNV<8, gl_ScopeSubgroup, 16, 8> ms;
    coopMatLoadNV(ms, shmatrix, 1, 2, false);
    coopMatStoreNV(ms, shmatrix, 1, 2, false);

}

<><><><><><><><><><><><><><><><><><><><><><><><><>
14:10; [@127,438:438='<',<'<'>,14:10]; no viable alternative at input 'icoopmatNV<'; NoViableAltException:null
14:35; [@137,463:463='8',<INT32CONSTANT>,14:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
15:10; [@144,482:482='<',<'<'>,15:10]; no viable alternative at input 'icoopmatNV<'; NoViableAltException:null
15:35; [@154,507:507='8',<INT32CONSTANT>,15:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
16:10; [@164,530:530='<',<'<'>,16:10]; no viable alternative at input 'ucoopmatNV<'; NoViableAltException:null
16:35; [@174,555:555='8',<INT32CONSTANT>,16:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
17:10; [@181,574:574='<',<'<'>,17:10]; no viable alternative at input 'ucoopmatNV<'; NoViableAltException:null
17:35; [@191,599:599='8',<INT32CONSTANT>,17:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
24:16; [@259,742:742='<',<'<'>,24:16]; no viable alternative at input 'const icoopmatNV<'; NoViableAltException:null
24:42; [@269,768:768='8',<INT32CONSTANT>,24:42]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
24:86; [@287,812:812='8',<INT32CONSTANT>,24:86]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
25:16; [@297,836:836='<',<'<'>,25:16]; no viable alternative at input 'const ucoopmatNV<'; NoViableAltException:null
25:38; [@304,858:858='8',<INT32CONSTANT>,25:38]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
25:41; [@307,861:861='8',<INT32CONSTANT>,25:41]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
25:82; [@322,902:902='8',<INT32CONSTANT>,25:82]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
25:85; [@325,905:905='8',<INT32CONSTANT>,25:85]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
43:10; [@488,1244:1244='<',<'<'>,43:10]; no viable alternative at input 'icoopmatNV<'; NoViableAltException:null
43:32; [@495,1266:1266='8',<INT32CONSTANT>,43:32]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
43:35; [@498,1269:1269='8',<INT32CONSTANT>,43:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
43:75; [@511,1309:1309='8',<INT32CONSTANT>,43:75]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
43:78; [@514,1312:1312='8',<INT32CONSTANT>,43:78]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
43:97; [@528,1331:1331='}',<'}'>,43:97]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
44:32; [@538,1366:1366='8',<INT32CONSTANT>,44:32]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
44:35; [@541,1369:1369='8',<INT32CONSTANT>,44:35]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
44:75; [@554,1409:1409='8',<INT32CONSTANT>,44:75]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
44:78; [@557,1412:1412='8',<INT32CONSTANT>,44:78]; mismatched input '8' expecting IDENTIFIER; InputMismatchException:null
44:109; [@577,1443:1443='}',<'}'>,44:109]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
47:10; [@601,1501:1501='<',<'<'>,47:10]; no viable alternative at input 'ucoopmatNV<'; NoViableAltException:null
47:39; [@612,1530:1530='>',<'>'>,47:39]; mismatched input '>' expecting {';', '[', ',', '='}; InputMismatchException:null
54:54; [@675,1708:1708='=',<'='>,54:54]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
55:54; [@728,1816:1816='=',<'='>,55:54]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
62:51; [@823,2004:2004='=',<'='>,62:51]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
63:51; [@860,2103:2103='=',<'='>,63:51]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
64:51; [@897,2202:2202='=',<'='>,64:51]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
65:51; [@934,2301:2301='=',<'='>,65:51]; mismatched input '=' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', ';', '[', ',', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
]


testGlslangErrors[spv.interpOps.frag]=[
#version 450

in float if1;
in vec2  if2;
in vec3  if3;
in vec4  if4;

flat in int samp;
flat in vec2 offset;

out vec4 fragColor;

void main()
{
    vec4 f4 = vec4(0.0);
    f4.x    += interpolateAtCentroid(if1);
    f4.xy   += interpolateAtCentroid(if2);
    f4.xyz  += interpolateAtCentroid(if3);
    f4      += interpolateAtCentroid(if4);

    f4.x    += interpolateAtSample(if1, samp);
    f4.xy   += interpolateAtSample(if2, samp);
    f4.xyz  += interpolateAtSample(if3, samp);
    f4      += interpolateAtSample(if4, samp);

    f4.x    += interpolateAtOffset(if1, offset);
    f4.xy   += interpolateAtOffset(if2, offset);
    f4.xyz  += interpolateAtOffset(if3, offset);
    f4      += interpolateAtOffset(if4, offset);

    fragColor = f4;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.invariantAll.vert]=[
#version 450 core
#pragma STDGL invariant(all)

layout(location=0) out highp float v;

void main()
{
    gl_Position = vec4(v, v, 0, 1);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.layer.tese]=[
#version 450

#extension GL_ARB_shader_viewport_layer_array : require

layout(triangles) in;
void main() {
  gl_Layer = 1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.layoutNested.vert]=[
#version 450

// should get 3 SPV types for S: no layout, 140, and 430, plus extras for interpolation or invariant differences
struct S
{
	highp uvec3 a;
	mediump mat2 b[4];
	lowp uint c;
};

layout(set = 0, binding = 0, std140) uniform Block140
{
	mediump int u;
	S s[2][3];
	mediump vec2 v;
} inst140;

layout(set = 0, binding = 1, std430) buffer Block430
{
	mediump int u;
	S s[2][3];
	mediump vec2 v;
} inst430;

S s;

// should get 5 SPV types for T: no layout, 140/row, 140/col, 430/row, and 430/col
struct T {
    mat2 m;
    int a;
};

T t;

struct Nestor {
    T nestorT;
};

layout(set = 1, binding = 0, std140) uniform Bt1
{
    layout(row_major) Nestor nt;
} Btn1;

layout(set = 1, binding = 0, std140) uniform Bt2
{
    layout(column_major) Nestor nt;
} Btn2;

layout(row_major, set = 1, binding = 0, std140) uniform Bt3
{
    layout(column_major) Nestor ntcol;
    Nestor ntrow;                         // should be row major decoration version of Nestor
} Btn3;

layout(set = 1, binding = 0, std430) buffer bBt1
{
    layout(row_major) Nestor nt;
} bBtn1;

layout(set = 1, binding = 0, std430) buffer bBt2
{
    layout(column_major) Nestor nt;
} bBtn2;

layout(set = 1, binding = 0, std430) buffer bBt3
{
    layout(row_major) Nestor ntcol;
    Nestor ntrow;                         // should be col major decoration version of Nestor
} bBtn3;

void main()
{
}

flat out S sout;
invariant out S soutinv;

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.length.frag]=[
#version 140

vec4 u[3];

in vec2 v[2];

void main()
{
    int a[5];

    vec2 t = v[0] + v[1];

    gl_FragColor = vec4(u.length() * v.length() * a.length());
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.localAggregates.frag]=[
#version 400

uniform sampler2D samp2D;
in vec2 coord;
in vec4 color;

struct s1 {
    int i;
    float f;
};

struct s2 {
    int i;
    float f;
	s1 s1_1;
	vec4 bleh;
};

struct s3 {
	s2 s2_1;
    int i;
    float f;
	s1 s1_1;
};
.
.
flat in s1 foo;
flat in s2 foo2;
flat in s3 foo3;
.
.
flat in int condition;

void main()
{
	s2 locals2;
	s3 locals3;
	float localFArray[16];
	int localIArray[8];

	locals2 = foo3.s2_1;

	if (foo3.s2_1.i > 0) {
		locals2.s1_1.f = 1.0;
		localFArray[4] = coord.x;
		localIArray[2] = foo3.s2_1.i;
	} else {
		locals2.s1_1.f = coord.x;
		localFArray[4] = 1.0;
		localIArray[2] = 0;
	}

	if (localIArray[2] == 0)
		++localFArray[4];

 	float localArray[16];
	int x = 5;
	localArray[x] = coord.x;

	float[16] a;

	for (int i = 0; i < 16; i++)
		a[i] = 0.0;
	
	if (condition == 1)
		a = localArray;
	
	locals2.bleh = color;
	locals2.bleh.z = coord.y;

	gl_FragColor = locals2.bleh * (localFArray[4] + locals2.s1_1.f + localArray[x] + a[x]) * texture(samp2D, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.loops.frag]=[
#version 140
in vec4 bigColor;
in vec4 bigColor1_1;
in vec4 bigColor1_2;
in vec4 bigColor1_3;
in vec4 bigColor2;
in vec4 bigColor3;
in vec4 bigColor4;
in vec4 bigColor5;
in vec4 bigColor6;
in vec4 bigColor7;
in vec4 bigColor8;

in vec4 BaseColor;

in float d;
in float d2;
in float d3;
in float d4;
in float d5;
in float d6;
in float d7;
in float d8;
in float d9;
in float d10;
in float d11;
in float d12;
in float d14;
in float d15;
in float d16;
in float d17;
in float d18;
flat in int Count;

void main()
{
    vec4 color = BaseColor;

    // Not a real loop
    while (true) {
        if (color.x < 0.33) {
            color += vec4(0.33);
            break;
        }
        if (color.x < 0.66) {
            color += vec4(0.66);
            break;
        }

        color += vec4(0.33);
        break;
    }

    // While
    while (color.x < d) {
        color += bigColor;
    }

    // While (latchy)
    while (color.z < d) {
        color += bigColor1_1;
        if (color.w < d)
            continue;

        color += bigColor1_1;
    }

    // While (constant)
    while (color.x < 42.0) {
        ++color;
    }

    // While (complicated-conditional)
    while (color.w < d2 && color.y < d3) {
        color += bigColor1_2;
    }

    // While (multi-exit)
    while (color.z < d3) {
        color += bigColor1_3;
        if (color.y < d4)
            break;
        color += bigColor1_3;
    }

    // For (dynamic)
    for (int i = 0; i < Count; ++i) {
        color += bigColor2;
    }

    // Do while
    do {
        color += bigColor3;
    } while (color.x < d2);

    // For (static)
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
    }

    // For (static) flow-control
    for (int i = 0; i < 100; ++i) {
        if (color.z < 20.0)
            color.x++;
        else
            color.y++;
        if (color.w < 20.0)
            if (color.z > color.y)
                0;              // do nothing
    }

    // For (static) flow-control with latch merge
    for (int i = 0; i < 120; ++i) {
        if (color.z < 20.0)
            color.x++;
        else
            color.y++;
    }

    // For (static) latchy
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
        if (color.x < d4)
            continue;
        ++color.w;
    }

    // For (static) multi-exit
    for (int i = 0; i < 42; ++i) {
        color.z += d3;
        if (color.x < d4)
            break;
        ++color.w;
    }

    // Latchy
    do {
        color += bigColor4;
        if (color.x < d4)
            continue;
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    } while (color.z < d4);

    // Do while flow control
    do {
        color += bigColor5;
        if (color.y < d5)
            color.y += d5;
    } while (color.x < d5);

    // If then loop
    if (color.x < d6) {
        while (color.y < d6)
            color += bigColor6;
    } else {
        while (color.z < d6)
            color.z += bigColor6.z;
    }

    // If then multi-exit
    if (color.x < d6) {
        while (color.y < d6) {
            color += bigColor6;
            if (d7 < 1.0)
                break;
        }

    } else {
        while (color.z < d6)
            color.z += bigColor6.z;
    }
.
.
    // Multi-exit
    do {
       if (d7 < 0.0)
           break;

       color += bigColor7;

       if (d7 < 1.0) {
           color.z++;
           break;
       }

       color += BaseColor;

    } while (true);
.
.
    // Multi-exit2
    do {
        // invariant conditional break at the top of the loop. This could be a
        // situation where unswitching the loop has no real increases in code
        // size.
       if (d8 < 0.0)
           break;

       color += bigColor7;

       if (d8 < 1.0) {
           color.z++;
           if (d8 < 2.0) {
               color.y++;
           } else {
               color.x++;
           }
           break;
       }

       color += BaseColor;

    } while (color.z < d8);

    // Deep exit
    while (color.w < d9) {
        if (d9 > d8) {
            if (color.x <= d7) {
                if (color.z == 5.0)
                    color.w++;
                else
                    break;
            }
        }

    }

    // No end loop-back.
    while (color.z < d10) {
        color.y++;
        if (color.y < d11) {
            color.z++;
            if (color.w < d12)
                color.w++;
            else
                color.x++;
            continue;
        }

        color++;
        break;
    }

    // Multi-continue
    while (color.x < 10.0) {
        color += bigColor8;

        if (color.z < d8)
            if (color.w < d6)
                continue;

        color.y += bigColor8.x;
    }

    color++;
    gl_FragColor = color;

    // Early Return
    while (color.x < d14) {
        if (color.y < d15) {
            return;
        }
        else
            color++;
    }

    color++;

    while (color.w < d16) {
        color.w++;
    }
.
.
    // While (complicated-conditional)
    while (color.w < d2 && color.y < d3) {
        color += bigColor1_2;
        if (color.z < d3)
            return;
    }
.
.
    do {
        if (color.y < d18)
            return;
        color++;
    } while (color.x < d17);

    // Early Discard
    while (color.y < d16) {
        if (color.w < d16) {
            discard;
        } else
            color++;
    }

    color++;

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.loopsArtificial.frag]=[
#version 140
in vec4 bigColor;
in vec4 bigColor1_1;
in vec4 bigColor1_2;
in vec4 bigColor1_3;
in vec4 bigColor2;
in vec4 bigColor3;
in vec4 bigColor4;
in vec4 bigColor5;
in vec4 bigColor6;
in vec4 bigColor7;
in vec4 bigColor8;

in vec4 BaseColor;

in float d;
in float d2;
in float d3;
in float d4;
in float d13;

flat in int Count;

void main()
{
    vec4 color = BaseColor;

    // Latchy2
    do {
        color += bigColor4;
        if (color.x < d4) {
            color.z += 2.0;
            if (color.z < d4) {
                color.x++;
                continue;
            }
        }
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    } while (color.z < d4);

    // Immediate dominator
    while (color.w < d13) {
        if (color.z < d13)
            color++;
        else
            color--;
        // code from Latchy 2
        color += bigColor4;
        if (color.x < d4) {
            color.z += 2.0;
            if (color.z < d4) {
                color.x++;
                continue;
            }
        }
        if (color.y < d4)
            color.y += d4;
        else
            color.x += d4;
    }

    color++;
    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.looseUniformNoLoc.vert]=[
#version 450 core

layout(location = 0)
in  vec4 foo;

layout(location = 0)
out vec4 bar;

uniform vec4 uv;

void main()
{
    bar = foo;
    gl_Position = foo;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.matFun.vert]=[
#version 400

uniform bl {
    uniform mat4 m4;
    uniform mat3 m3;
} bName;

in vec3 v3;

vec3 xf(mat3 m, vec3 v)
{
    return v * m;
}

mat3 Mat3(mat4 m)
{
	return mat3(m[0].xyz, m[1].xyz, m[2].xyz);
}

vec3 mxv(mat4 m4, vec3 v)
{
	return v * Mat3(m4);
}

void main()
{
    gl_Position = vec4(mxv(bName.m4, v3) + xf(bName.m3, v3), 1.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.matrix.frag]=[
#version 420

in mat3x4 m1;
in mat3x4 m2;
in float f;
in vec3 v3;
in vec4 v4;

out vec4 color;

void main()
{
    mat3x4 sum34;
    dmat3x4 dm;
    vec3 sum3;
    vec4 sum4;

    sum34 = m1 - m2;
    sum34 += m1 * f;
    sum34 += f * m1;
    sum34 /= matrixCompMult(m1, m2);
    sum34 += m1 / f;
    sum34 += f / m1;
    sum34 += f;
    sum34 -= f;
    dm = dmat3x4(sum34);
    sum34 = mat3x4(dm);

    sum3 = v4 * m2;
    sum4 = m2 * v3;

    mat4x3 m43 = transpose(sum34);
    mat4 m4 = m1 * m43;

    sum4 = v4 * m4;

    color = sum4;

    ++sum34;
    --sum34;

    sum34 += mat3x4(f);
    sum34 += mat3x4(v3, f, v3, f, v3, f);

    color += sum3 * m43 + sum4;

    color += vec4(m43);
    color += vec4(vec3(mat2(f)), 7.2);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.matrix2.frag]=[
#version 150

in mat3 colorTransform;
in vec3 Color;
in mat4 m, n;

in mat4x3 um43;
in mat3x4 un34;
in mat2 um2;
in mat3 um3;
in mat4 um4;

in vec4 v;

in vec3 u;

out vec4 FragColor;

void main()
{
    mat3x4 m34 = outerProduct(v, u);

    m34 += mat3x4(4.3);

    FragColor = vec4(Color, 1.0);
    FragColor *= vec4(FragColor * m34, 1.0);

    m34 *= v.x;

    mat4 m44 = mat4(un34);

    m44 += m34 * um43;

    FragColor += (-m44) * v;

    FragColor *= matrixCompMult(m44, m44);

    m34 = transpose(um43);
    FragColor *= vec4(FragColor * m34, 1.0);
    FragColor *= vec4(determinant(um4));
    mat2 inv = inverse(um2);
    FragColor *= vec4(inv[0][0], inv[1][0], inv[0][1], inv[1][1]);
    mat3 inv3 = inverse(um3);
    FragColor *= vec4(inv3[2][1]);

    mat4 inv4 = inverse(um4);
    FragColor *= inv4;

    FragColor = vec4(FragColor * matrixCompMult(un34, un34), FragColor.w);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.memoryQualifier.frag]=[
#version 450

layout(binding = 0, r32f) uniform coherent image1D      i1D;
layout(binding = 1, r32f) uniform volatile image2D      i2D;
layout(binding = 2, r32f) uniform restrict image2DRect  i2DRect;
layout(binding = 3, r32f) uniform readonly image3D      i3D;
layout(binding = 3, r32f) uniform writeonly imageCube   iCube;

struct Data
{
    float f1;
    vec2  f2;
};

coherent buffer Buffer
{
    volatile float f1;
    restrict vec2  f2;
    readonly vec3  f3;
    writeonly vec4 f4;
    int i1;
    Data data;
};

void main()
{
    vec4 texel = imageLoad(i1D, 1);
    texel += imageLoad(i2D, ivec2(1));
    texel += imageLoad(i2DRect, ivec2(1));
    texel += imageLoad(i3D, ivec3(1));
    imageStore(iCube, ivec3(1), texel);

    texel[i1] = f1;
    texel.xy += f2;
    texel.xyz -= f3;
    texel.w += data.f1 + data.f2[1];
    f4 = texel;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.memoryScopeSemantics.comp]=[
#version 450
#extension GL_KHR_memory_scope_semantics : require
#extension GL_ARB_gpu_shader_int64 : require

#pragma use_vulkan_memory_model

shared uint value;
shared int atomi;
shared uint atomu;
layout(binding = 0, r32ui) workgroupcoherent uniform uimage2D imageu;
layout(binding = 1, r32i) volatile coherent uniform iimage2D imagei;
layout(binding = 5, r32i) nonprivate uniform iimage2D imagej[2];
layout (binding = 2) buffer BufferU { workgroupcoherent uint x; } bufferu;
layout (binding = 3) coherent buffer BufferI { uint x; } bufferi;
struct A { uint x[2]; };
layout (binding = 4) volatile buffer BufferJ { subgroupcoherent A a; } bufferj[2];
layout (binding = 6) nonprivate uniform sampler2D samp[2];
layout (binding = 7) nonprivate uniform BufferK { uint x; } bufferk;
shared uint64_t atomu64;
shared int64_t atomi64;
layout (binding = 8) volatile buffer BufferL { uint x; } bufferl;
layout (binding = 9) buffer BufferM { volatile uint x; } bufferm;
layout(binding = 10, r32i) volatile coherent uniform iimage2DMS imageMS;
.
.
void main()
{
    int origi = atomicAdd(atomi, 3, gl_ScopeDevice, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsRelease);
    uint origu = atomicAnd(atomu, value);
    origi = atomicLoad(atomi, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
    atomicStore(atomu, value, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease);
    origi = imageAtomicLoad(imagei, ivec2(0,0), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
    origu = imageAtomicAdd(imageu, ivec2(0,0), 3u, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
    imageAtomicStore(imageu, ivec2(0,0), 4u, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease);
    origu = atomicOr(atomu, 7u, gl_ScopeDevice, 0, 0);
    origu = atomicXor(atomu, 7u, gl_ScopeDevice, 0, 0);
    origu = atomicMin(atomu, value, gl_ScopeDevice, 0, 0);
    origi = atomicMax(atomi, 7, gl_ScopeDevice, 0, 0);
    origi = atomicExchange(atomi, origi, gl_ScopeDevice, 0, 0);
    origu = atomicCompSwap(atomu, 10u, value, gl_ScopeDevice, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire);
    atomicAdd(bufferu.x, 1, gl_ScopeDevice, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsRelease);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsRelease);
    controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire);
    controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup, 0, 0);

    uint y;
    y = bufferu.x;
    bufferu.x = y;
    y = bufferi.x;
    y = bufferj[0].a.x[1];
    bufferi.x = y;
    bufferj[0].a.x[1] = y;
    bufferj[0].a = bufferj[1].a;
    bufferi.x = bufferk.x;

    imageLoad(imagei, ivec2(0,0));
    imageLoad(imagej[0], ivec2(0,0));
    imageStore(imagej[1], ivec2(0,0), ivec4(0,0,0,0));
    texture(samp[0], vec2(0,0));

    atomu64 = atomicMax(atomu64, uint64_t(7), gl_ScopeDevice, 0, 0);
    atomicCompSwap(atomi64, int64_t(10), int64_t(atomu64), gl_ScopeDevice, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire);

    y = bufferl.x;
    atomicAdd(bufferl.x, 1);
    atomicOr(bufferm.x, 2);
    imageAtomicAdd(imagei, ivec2(0,0), 3);
    atomicAdd(bufferu.x, 4u, gl_ScopeDevice, 0, 0);
    atomicAdd(bufferu.x, 5u, gl_ScopeDevice, 0, gl_SemanticsVolatile);

    imageAtomicStore(imageMS, ivec2(0,0), 1, 4, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease);
    imageAtomicStore(imagei, ivec2(0,0), -7, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.memoryScopeSemantics_Error.comp]=[
#version 450
#extension GL_KHR_memory_scope_semantics : require
.
.
shared uint value;
shared int atomi;
shared uint atomu;
layout(binding = 0, r32ui) workgroupcoherent uniform uimage2D imageu;
layout(binding = 1, r32i) coherent uniform iimage2D imagei;
layout (binding = 2) buffer BufferU { workgroupcoherent uint x; } bufferu;
layout (binding = 3) subgroupcoherent buffer BufferI { uint x; } bufferi;

void main()
{
    atomicStore(atomu, value, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
    int origi = imageAtomicLoad(imagei, ivec2(0,0), gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease);
    atomicStore(atomu, value, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquireRelease);
    atomicStore(atomu, value, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_StorageSemanticsBuffer);
    origi = imageAtomicLoad(imagei, ivec2(0,0), gl_ScopeDevice, gl_SemanticsAcquire, gl_SemanticsAcquire);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, 0);
    memoryBarrier(gl_ScopeWorkgroup, 0, gl_SemanticsRelease);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsRelease | gl_SemanticsAcquire);
    atomicAdd(atomu, value, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelease | gl_SemanticsAcquire);
    uint origu = atomicCompSwap(atomu, 10u, value, gl_ScopeDevice, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquire, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared, gl_SemanticsAcquireRelease);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer, gl_SemanticsRelease | gl_SemanticsMakeVisible);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer, gl_SemanticsAcquire | gl_SemanticsMakeAvailable);
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsBuffer, gl_SemanticsRelease | gl_SemanticsVolatile);
    atomicCompSwap(bufferi.x, 10u, 10u, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsAcquire | gl_SemanticsVolatile, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.merge-unreachable.frag]=[
#version 450
precision mediump int; precision highp float;
layout(location=1) in highp vec4 v;
void main (void)
{
  if (v == vec4(0.1,0.2,0.3,0.4)) discard;
  else return;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.meshShaderBuiltins.mesh]=[
#version 460

#define MAX_VER  81
#define MAX_PRIM 32

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test use of builtins in mesh shaders:

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;

    gl_MeshVerticesNV[iid].gl_Position = vec4(1.0);
    gl_MeshVerticesNV[iid].gl_PointSize = 2.0;
    gl_MeshVerticesNV[iid].gl_ClipDistance[3] = 3.0;
    gl_MeshVerticesNV[iid].gl_CullDistance[2] = 4.0;

    BARRIER();

    gl_MeshVerticesNV[iid+1].gl_Position = gl_MeshVerticesNV[iid].gl_Position;
    gl_MeshVerticesNV[iid+1].gl_PointSize = gl_MeshVerticesNV[iid].gl_PointSize;
    gl_MeshVerticesNV[iid+1].gl_ClipDistance[3] = gl_MeshVerticesNV[iid].gl_ClipDistance[3];
    gl_MeshVerticesNV[iid+1].gl_CullDistance[2] = gl_MeshVerticesNV[iid].gl_CullDistance[2];

    BARRIER();

    gl_MeshPrimitivesNV[iid].gl_PrimitiveID = 6;
    gl_MeshPrimitivesNV[iid].gl_Layer = 7;
    gl_MeshPrimitivesNV[iid].gl_ViewportIndex = 8;
    gl_MeshPrimitivesNV[iid].gl_ViewportMask[0] = 9;

    BARRIER();

    gl_MeshPrimitivesNV[iid+1].gl_PrimitiveID = gl_MeshPrimitivesNV[iid].gl_PrimitiveID;
    gl_MeshPrimitivesNV[iid+1].gl_Layer = gl_MeshPrimitivesNV[iid].gl_Layer;
    gl_MeshPrimitivesNV[iid+1].gl_ViewportIndex = gl_MeshPrimitivesNV[iid].gl_ViewportIndex;
    gl_MeshPrimitivesNV[iid+1].gl_ViewportMask[0] = gl_MeshPrimitivesNV[iid].gl_ViewportMask[0];

    BARRIER();

    // check bound limits
    gl_PrimitiveIndicesNV[0] = 257; // should truncate 257 -> 1
    gl_PrimitiveIndicesNV[(MAX_PRIM * 3) - 1] = 2;
    gl_PrimitiveIndicesNV[gid] = gl_PrimitiveIndicesNV[gid-1];

    // writes 4 indices at offset gl_DrawID
    writePackedPrimitiveIndices4x8NV(gl_DrawID, 0x01020304);

    gl_PrimitiveCountNV = MAX_PRIM * 3;

    BARRIER();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.meshShaderPerViewBuiltins.mesh]=[
#version 450

#define MAX_VER  81
#define MAX_PRIM 32
#define MAX_VIEWS gl_MaxMeshViewCountNV

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test use of per-view builtin attributes

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint viewID = gl_MeshViewIndicesNV[gl_MeshViewCountNV%MAX_VIEWS];

    gl_MeshVerticesNV[iid].gl_PositionPerViewNV[viewID]          = vec4(1.0, 2.0, 3.0, 4.0);
    gl_MeshVerticesNV[iid].gl_ClipDistancePerViewNV[viewID][2]   = 5.0;
    gl_MeshVerticesNV[iid].gl_CullDistancePerViewNV[viewID][3]   = 6.0;
    gl_MeshPrimitivesNV[iid].gl_LayerPerViewNV[viewID]           = 7;
    gl_MeshPrimitivesNV[iid].gl_ViewportMaskPerViewNV[viewID][0] = 8;

    BARRIER();

    gl_MeshVerticesNV[iid+1].gl_PositionPerViewNV[viewID]          = gl_MeshVerticesNV[iid].gl_PositionPerViewNV[viewID];
    gl_MeshVerticesNV[iid+1].gl_ClipDistancePerViewNV[viewID][2]   = gl_MeshVerticesNV[iid].gl_ClipDistancePerViewNV[viewID][2];
    gl_MeshVerticesNV[iid+1].gl_CullDistancePerViewNV[viewID][3]   = gl_MeshVerticesNV[iid].gl_CullDistancePerViewNV[viewID][3];
    gl_MeshPrimitivesNV[iid+1].gl_LayerPerViewNV[viewID]           = gl_MeshPrimitivesNV[iid].gl_LayerPerViewNV[viewID];
    gl_MeshPrimitivesNV[iid+1].gl_ViewportMaskPerViewNV[viewID][0] = gl_MeshPrimitivesNV[iid].gl_ViewportMaskPerViewNV[viewID][0];

    BARRIER();
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.meshShaderPerView_Errors.mesh]=[
#version 450

#define MAX_VER  81
#define MAX_PRIM 32
#define MAX_VIEWS gl_MaxMeshViewCountNV

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test error checks for use of incorrect per-view attributes

// per-view block attributes
perviewNV layout(location=0) out perviewBlock {
    vec4 missingInnermostDimSize1[][];
    vec4 incorrectViewDimSize1[MAX_VIEWS+1];
    vec4 missingViewDim1;
} b2[];

// per-view non-block attributes
perviewNV layout(location=10) out vec4 missingInnermostDimSize2[][][];
perviewNV layout(location=11) out vec4 incorrectViewDimSize2[][MAX_VIEWS-1];
perviewNV layout(location=12) out vec4 missingViewDim2[];

void main()
{
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>
18:10; [@73,379:384='layout',<'layout'>,18:10]; no viable alternative at input 'perviewNV layout'; NoViableAltException:null
25:10; [@124,586:591='layout',<'layout'>,25:10]; no viable alternative at input 'perviewNV layout'; NoViableAltException:null
26:10; [@146,658:663='layout',<'layout'>,26:10]; no viable alternative at input 'perviewNV layout'; NoViableAltException:null
27:10; [@169,736:741='layout',<'layout'>,27:10]; no viable alternative at input 'perviewNV layout'; NoViableAltException:null
]


testGlslangErrors[spv.meshShaderSharedMem.mesh]=[
#version 450

#define MAX_VER  81
#define MAX_PRIM 32

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test use of shared memory in mesh shaders:

writeonly uniform image2D uni_image;
uniform block0 {
    uint    uni_value;
};

shared vec4 mem[10];

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;

    for (uint i = 0; i < 10; ++i) {
        mem[i] = vec4(i+uni_value);
    }
    imageStore(uni_image, ivec2(iid), mem[gid]);
    imageStore(uni_image, ivec2(iid), mem[gid+1]);

    BARRIER();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.meshShaderTaskMem.mesh]=[
#version 450

#define MAX_VER  81
#define MAX_PRIM 32

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

layout(max_vertices=MAX_VER) out;
layout(max_primitives=MAX_PRIM) out;
layout(triangles) out;

// test use of task memory in mesh shaders:

taskNV in taskBlock {
    float gid1[2];
    vec4 gid2;
} mytask;

buffer bufferBlock {
    float gid3[2];
    vec4 gid4;
} mybuf;

layout(location=0) out outBlock {
    float gid5;
    vec4 gid6;
} myblk[];

void main()
{
    uint iid = gl_LocalInvocationID.x;

    myblk[iid].gid5 = mytask.gid1[1] + mybuf.gid3[1];
    myblk[iid].gid6 = mytask.gid2    + mybuf.gid4;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
20:7; [@77,337:338='in',<'in'>,20:7]; no viable alternative at input 'taskNV in'; NoViableAltException:null
]


testGlslangErrors[spv.meshTaskShader.task]=[
#version 450

#define MAX_VIEWS gl_MaxMeshViewCountNV

#define BARRIER() \
    memoryBarrierShared(); \
    barrier();

#extension GL_NV_mesh_shader : enable

layout(local_size_x = 32) in;

// test use of shared memory in task shaders:
layout(binding=0) writeonly uniform image2D uni_image;
uniform block0 {
    uint uni_value;
};
shared vec4 mem[10];

// test use of task memory in task shaders:
taskNV out Task {
    vec2 dummy;
    vec2 submesh[3];
    uint viewID;
} mytask;

void main()
{
    uint iid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;
    uint viewID = gl_MeshViewIndicesNV[gl_MeshViewCountNV%MAX_VIEWS];

    // 1. shared memory load and stores
    for (uint i = 0; i < 10; ++i) {
        mem[i] = vec4(i + uni_value);
    }
    imageStore(uni_image, ivec2(iid), mem[gid]);
    imageStore(uni_image, ivec2(iid), mem[gid+1]);

    BARRIER();

    // 2. task memory stores

    mytask.dummy      = vec2(30.0, 31.0);
    mytask.submesh[0] = vec2(32.0, 33.0);
    mytask.submesh[1] = vec2(34.0, 35.0);
    mytask.submesh[2] = mytask.submesh[gid%2];
    mytask.viewID     = viewID;

    BARRIER();

    // 3. set task count
    gl_TaskCountNV = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
21:7; [@87,404:406='out',<'out'>,21:7]; no viable alternative at input 'taskNV out'; NoViableAltException:null
]


testGlslangErrors[spv.multiStruct.comp]=[
#version 450 core

struct MyStruct
{
    vec2 foo[2];
    bool sb;
};

layout(binding = 0, std430) buffer SSBO0
{
    MyStruct a;
} inBuf;

layout(binding = 1, std430) buffer SSBO1
{
    MyStruct b;
} outBuf;

layout(binding = 2, std140) uniform UBO
{
    MyStruct c;
} uBuf;

struct Nested {
    float f;
    MyStruct S[2];
};

layout(binding = 2, std140) uniform UBON
{
    Nested N1;
} uBufN;

layout(binding = 1, std430) buffer SSBO1N
{
    Nested N2;
} outBufN;

void main()
{
    MyStruct t = inBuf.a;
    outBuf.b = t;
    t = uBuf.c;
    outBuf.b = t;

    Nested n = uBufN.N1;
    outBufN.N2 = n;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.multiStructFuncall.frag]=[
#version 450

struct S { mat4 m; };
buffer blockName { S s1; };  // need an S with decoration
S s2;                        // no decorations on S

void fooConst(const in S s) { }
void foo(in S s) { }
void fooOut(inout S s) { }

void main()
{
  fooConst(s1);
  fooConst(s2);

  foo(s1);
  foo(s2);

  fooOut(s1);
  fooOut(s2);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.multiView.frag]=[
#version 450

#extension GL_EXT_multiview : enable

out vec4 color;

void main() {
    color = vec4(gl_ViewIndex, 0, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.multiviewPerViewAttributes.tesc]=[
#version 450

#extension GL_NVX_multiview_per_view_attributes :require

layout(vertices = 4) out;
out gl_PerVertex {
    int gl_ViewportMaskPerViewNV[];
    vec4 gl_PositionPerViewNV[];
 } gl_out[];
void main()
{
    gl_out[gl_InvocationID].gl_ViewportMaskPerViewNV[0]    = 1;
    gl_out[gl_InvocationID].gl_PositionPerViewNV[0] = gl_in[1].gl_Position + gl_in[1].gl_PositionPerViewNV[0];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.multiviewPerViewAttributes.vert]=[
#version 450

#extension GL_NVX_multiview_per_view_attributes :require

void main()
{
    gl_ViewportMaskPerViewNV[0]    = 1;
    gl_PositionPerViewNV[0]        = gl_Position;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.newTexture.frag]=[
#version 430

uniform sampler2D s2D;
uniform sampler2DRect sr;
uniform sampler3D s3D;
uniform samplerCube sCube;
uniform samplerCubeShadow sCubeShadow;
uniform samplerCubeArrayShadow sCubeArrayShadow;
uniform sampler2DShadow s2DShadow;
uniform sampler2DArray s2DArray;
uniform sampler2DArrayShadow s2DArrayShadow;

uniform isampler2D is2D;
uniform isampler3D is3D;
uniform isamplerCube isCube;
uniform isampler2DArray is2DArray;
uniform isampler2DMS is2Dms;

uniform usampler2D us2D;
uniform usampler3D us3D;
uniform usamplerCube usCube;
uniform usampler2DArray us2DArray;

in float c1D;
in vec2  c2D;
in vec3  c3D;
in vec4  c4D;

flat in int   ic1D;
flat in ivec2 ic2D;
flat in ivec3 ic3D;
flat in ivec4 ic4D;

out vec4 FragData;

void main()
{
    vec4 v = texture(s2D, c2D);
    v.y += texture(sCubeArrayShadow, c4D, c1D);
    v += textureProj(s3D, c4D);
    v += textureLod(s2DArray, c3D, 1.2);
    v.y += textureOffset(s2DShadow, c3D, ivec2(3), c1D);
    v += texelFetch(s3D, ic3D, ic1D);
    v += texelFetchOffset(s2D, ic2D, 4, ivec2(3));
    v += texelFetchOffset(sr, ic2D, ivec2(4));
    v.y += textureLodOffset(s2DShadow, c3D, c1D, ivec2(3));
    v += textureProjLodOffset(s2D, c3D, c1D, ivec2(3));
    v += textureGrad(sCube, c3D, c3D, c3D);
    v.x += textureGradOffset(s2DArrayShadow, c4D, c2D, c2D, ivec2(3));
    v += textureProjGrad(s3D, c4D, c3D, c3D);
    v += textureProjGradOffset(s2D, c3D, c2D, c2D, ivec2(3));

    ivec4 iv = texture(is2D, c2D);
    v += vec4(iv);
    iv = textureProjOffset(is2D, c4D, ivec2(3));
    v += vec4(iv);
    iv = textureProjLod(is2D, c3D, c1D);
    v += vec4(iv);
    iv = textureProjGrad(is2D, c3D, c2D, c2D);
    v += vec4(iv);
    iv = texture(is3D, c3D, 4.2);
    v += vec4(iv);
    iv = textureLod(isCube, c3D, c1D);
    v += vec4(iv);
    iv = texelFetch(is2DArray, ic3D, ic1D);
    v += vec4(iv);

    ivec2 iv2 = textureSize(sCubeShadow, 2);
    // iv2 += textureSize(is2Dms);

    FragData = v + vec4(iv2, 0.0, 0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.noBuiltInLoc.vert]=[
#version 450 core

layout(location = 0)
in  vec4 foo;

layout(location = 0)
out vec4 bar;

uniform vec4 uv1;
uniform float uv2;
uniform vec3 uv3;

layout(binding = 0) uniform atomic_uint a_uint;

void main()
{
    bar = foo;
    gl_Position = foo;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.noDeadDecorations.vert]=[
#version 310 es
precision mediump float;

float func(float a)
{
    return -a;
    a = a * -1.0;
}

void main()
{
    gl_Position.x = func(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.noLocation.vert]=[
#version 450

layout(location = 1) in vec4 in1;
in vec4 in2;                        // ERROR
layout(location = 3) in vec4 in3;

layout(location = 1) out vec4 out1;
out vec4 out2;                      // ERROR
layout(location = 3) out vec4 out3;

layout(location = 10) out inb1 { 
    vec4 a;
    vec4 b;
} inbi1;
out inb2 { 
    layout(location = 12) vec4 a;
    layout(location = 13) vec4 b;
} inbi2;
out inb3 {                          // ERROR
    vec4 a;
    vec4 b;
} inbi3;

layout(location = 14) out struct S1 { vec4 a; } s1;
out struct S2 { vec4 a; } s2;       // ERROR

struct SS { int a; };
out layout(location = 15) SS ss1;
out SS ss2;                         // ERROR

out gl_PerVertex {
    vec4 gl_Position;
    float gl_ClipDistance[2];
};

void main()
{
    gl_ClipDistance[0] = 1.0;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.noWorkgroup.comp]=[
#version 450

layout(local_size_x_id = 18, local_size_y_id=10,local_size_z_id = 19) in;

shared uint keys[gl_WorkGroupSize.z][gl_WorkGroupSize.x * gl_WorkGroupSize.y];

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nonSquare.vert]=[
#version 140

in vec3 v3;
in vec4 v4;

out mat3x2 m32;

const vec2 cv2 = vec2(10.0, 20.0);
const mat2x4 m24 = mat2x4(3.0);
const mat4x2 m42 = mat4x2(1.0, 2.0, 
                          3.0, 4.0,
                          5.0, 6.0, 
                          7.0, 8.0);

void main()
{
    mat2x3 m23;
    vec2 a, b;

    a = v3 * m23;
    b = m32 * v3;

    gl_Position = vec4(m23 * m32 * v3, m24[1][3]) + 
                  (m24 * m42) * v4 + cv2 * m42 + m24 * cv2 + vec4(cv2[1], cv2.x, m42[2][1], m42[2][0]);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nonuniform.frag]=[
#version 450

#extension GL_EXT_nonuniform_qualifier : enable

layout(location=0) nonuniformEXT in vec4 nu_inv4;
nonuniformEXT float nu_gf;
layout(location=1) in nonuniformEXT flat int nu_ii;
layout(location = 2) in vec2 inTexcoord;

layout(binding=0, input_attachment_index = 0) uniform subpassInput        inputAttachmentDyn[];
layout(binding=1)                             uniform samplerBuffer       uniformTexelBufferDyn[];
layout(binding=2, r32f)                       uniform imageBuffer         storageTexelBufferDyn[];
layout(binding=3)                             uniform uname { float a; }  uniformBuffer[];
layout(binding=4)                             buffer  bname { float b; }  storageBuffer[];
layout(binding=5)                             uniform sampler2D           sampledImage[];
layout(binding=6, r32f)                       uniform image2D             storageImage[];
layout(binding=7, input_attachment_index = 1) uniform subpassInput        inputAttachment[];
layout(binding=8)                             uniform samplerBuffer       uniformTexelBuffer[];
layout(binding=9, r32f)                       uniform imageBuffer         storageTexelBuffer[];
layout(binding = 10)                          uniform texture2D           uniformTexArr[8];
layout(binding = 11)                          uniform sampler             uniformSampler;

nonuniformEXT int foo(nonuniformEXT int nupi, nonuniformEXT out int f)
{
    return nupi;
}

void main()
{
    nonuniformEXT int nu_li;
    nonuniformEXT int nu_li2;
    int dyn_i;

    int a = foo(nu_li, nu_li);
    nu_li = nonuniformEXT(a) + nonuniformEXT(a * 2);
    nu_li2 = a + nonuniformEXT(a * 2);

    float b;
    b = nu_inv4.x * nu_gf;
    b += subpassLoad(inputAttachmentDyn[dyn_i]).x;
    b += texelFetch(uniformTexelBufferDyn[dyn_i], 1).x;
    b += imageLoad(storageTexelBufferDyn[dyn_i], 1).x;
    b += uniformBuffer[nu_ii].a;
    b += storageBuffer[nu_ii].b;
    b += texture(sampledImage[nu_ii], vec2(0.5)).x;
    b += imageLoad(storageImage[nu_ii], ivec2(1)).x;
    b += subpassLoad(inputAttachment[nu_ii]).x;
    b += texelFetch(uniformTexelBuffer[nu_ii], 1).x;
    b += imageLoad(storageTexelBuffer[nu_ii], 1).x;
    b += texture(sampler2D(uniformTexArr[nu_ii], uniformSampler), inTexcoord.xy).x;
    b += texture(nonuniformEXT(sampler2D(uniformTexArr[nu_ii], uniformSampler)), inTexcoord.xy).x;

    nonuniformEXT ivec4 v;
    nonuniformEXT mat4 m;
    nonuniformEXT struct S { int a; } s;
    nonuniformEXT int arr[10];
    ivec4 uv;
    mat4 um;
    struct US { int a[10]; } us;
    int uarr[10];
    b += uniformBuffer[v.y].a;
    b += uniformBuffer[v[2]].a;
    b += uniformBuffer[uv[nu_ii]].a;
    b += uniformBuffer[int(m[2].z)].a;
    b += uniformBuffer[s.a].a;
    b += uniformBuffer[arr[2]].a;
    b += uniformBuffer[int(um[nu_ii].z)].a;
    b += uniformBuffer[us.a[nu_ii]].a;
    b += uniformBuffer[uarr[nu_ii]].a;

    storageBuffer[nu_ii].b = b;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
5:33; [@25,100:101='in',<'in'>,5:33]; no viable alternative at input 'layout(location=0) nonuniformEXT in'; NoViableAltException:null
6:14; [@34,132:136='float',<FLOAT32>,6:14]; no viable alternative at input 'nonuniformEXT float'; NoViableAltException:null
7:36; [@50,182:185='flat',<'flat'>,7:36]; no viable alternative at input 'layout(location=1) in nonuniformEXT flat'; NoViableAltException:null
23:14; [@313,1394:1396='int',<INT32>,23:14]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
23:60; [@326,1440:1442='out',<'out'>,23:60]; missing ';' at 'out'; <no exception>
26:0; [@341,1473:1473='}',<'}'>,26:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
30:18; [@355,1512:1514='int',<INT32>,30:18]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
31:18; [@363,1542:1544='int',<INT32>,31:18]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
53:18; [@692,2444:2448='ivec4',<I32VEC4>,53:18]; no viable alternative at input 'nonuniformEXT ivec4'; NoViableAltException:null
54:18; [@700,2472:2475='mat4',<F32MAT4X4>,54:18]; no viable alternative at input 'nonuniformEXT mat4'; NoViableAltException:null
55:18; [@708,2499:2504='struct',<'struct'>,55:18]; no viable alternative at input 'nonuniformEXT struct'; NoViableAltException:null
56:18; [@727,2541:2543='int',<INT32>,56:18]; no viable alternative at input 'nonuniformEXT int'; NoViableAltException:null
]


testGlslangErrors[spv.nonuniform2.frag]=[
#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(set=0,binding=4,rgba32f) uniform imageBuffer data[];
layout(location = 0) out vec4     FragColor;
layout(location = 3) in flat int  rIndex;
void main()
{
  FragColor = imageLoad(data[nonuniformEXT(rIndex)], 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nonuniform3.frag]=[
#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(set = 0, binding = 0) uniform texture2D uTex[];
layout(set = 1, binding = 0) uniform sampler uSamp;
layout(location = 0) flat in int Index;
layout(location = 0) out vec4 FragColor;
void main()
{
    FragColor = texture(nonuniformEXT(sampler2D(uTex[Index], uSamp)), vec2(0.5));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nonuniform4.frag]=[
#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(set=0,binding=4,r32ui) uniform uimageBuffer data[];
layout(location = 3) in flat int  rIndex;
void main()
{
  imageAtomicAdd(data[nonuniformEXT(rIndex)], 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nonuniform5.frag]=[
#version 450
#extension GL_EXT_nonuniform_qualifier : require

layout(location = 0) flat in int Index;
layout(location = 0) out vec4 FragColor;

layout(set = 0, binding = 0) uniform UBO
{
	vec4 v;
} ubos[];

void main()
{
	FragColor = ubos[nonuniformEXT(Index)].v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.nullInit.comp]=[
#version 460

#extension GL_EXT_null_initializer : enable

#ifdef GL_EXT_null_initializer

struct S {
    vec3[4] v;
    int a;
};

struct T {
    int b;
    S s;
};

shared float f = { };
shared T t1 = { };
shared T t2 = { };
shared S s = { };
shared float g = { };
shared int i = { };

void main()
{
    S local = { };
    ++local.a;
}

S global = { };

#endif

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.offsets.frag]=[
#version 450

layout(set = 0, binding = 0, std140) uniform n1 {
    layout(offset = 8)  int a;
    layout(offset = 4)  int b;
    layout(offset = 0)  int c;
    layout(offset = 12) int d;
} i1;

layout(set = 0, binding = 1, std430) buffer n2 {
    layout(offset = 32) vec3 e;
                        vec3 f;
    layout(offset = 16) vec3 g;
    layout(offset = 0)  vec3 h;
} i2;

void main() {}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.paramMemory.420.frag]=[
#version 420

// Need this extension to permit passing a formatless readonly image to a helper function.
#extension GL_EXT_shader_image_load_formatted : require

readonly coherent uniform layout(set = 0, binding = 0) image2D image1;
readonly uniform layout(set = 0, binding = 2) image2D image2;
writeonly coherent uniform layout(set = 0, binding = 1, rgba32f) image2D image3;
writeonly uniform layout(set = 0, binding = 3, rgba16f) image2D image4;

flat in layout(location = 0) ivec2 in_coords;
out layout(location = 0) vec4 out_color;

vec4 image_load(readonly coherent image2D image, ivec2 coords)
{
	return imageLoad(image, in_coords);
}

void image_store(writeonly coherent image2D image, ivec2 coords, vec4 data)
{
	imageStore(image, in_coords, data);
}

void main()
{
	vec4 read1 = image_load(image1, in_coords);
	vec4 read2 = image_load(image2, in_coords);

	image_store(image3, in_coords, read1*0.5);
	image_store(image4, in_coords, read2*2.0);

	out_color = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.paramMemory.frag]=[
#version 310 es

// readonly coherent uniform layout(set = 0, binding = 0) highp image2D image1;
// readonly uniform layout(set = 0, binding = 2) highp image2D image2;
writeonly coherent uniform layout(set = 0, binding = 1, rgba32f) highp image2D image3;
writeonly uniform layout(set = 0, binding = 3, rgba16f) highp image2D image4;

flat in layout(location = 0) highp ivec2 in_coords;
out layout(location = 0) highp vec4 out_color;

highp vec4 image_load(readonly coherent highp image2D image, highp ivec2 coords)
{
	return imageLoad(image, in_coords);
}

void image_store(writeonly coherent highp image2D image, highp ivec2 coords, highp vec4 data)
{
	imageStore(image, in_coords, data);
}

void main()
{
	highp vec4 read1 = vec4(0.4); // = image_load(image1, in_coords);
	highp vec4 read2 = vec4(0.5); // = image_load(image2, in_coords);
	
	image_store(image3, in_coords, read1*0.5);
	image_store(image4, in_coords, read2*2.0);

	out_color = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.pp.line.frag]=[
#version 140

uniform sampler1D       texSampler1D;
uniform sampler2D       texSampler2D;

varying float blend;
varying vec4 u;

in  vec2 coords2D;

void main()
{
    float blendscale = 1.789;
    float bias       = 2.0;
    float coords1D   = 1.789;
    vec4  color      = vec4(0.0, 0.0, 0.0, 0.0);
#line 53
    color += texture    (texSampler1D, coords1D);
    color += texture    (texSampler1D, coords1D, bias);
#line 102
    color += texture        (texSampler2D, coords2D);
    color += texture        (texSampler2D, coords2D, bias);

    gl_FragColor = mix(color, u, blend * blendscale);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precise.tesc]=[
#version 310 es
#extension GL_EXT_tessellation_shader : require
#extension GL_EXT_gpu_shader5 : require

layout(vertices = 3) out;

layout(location = 0) in highp vec2  in_tc_position[];
layout(location = 1) in highp float in_tc_tessParam[];

layout(location = 0) out highp vec2 in_te_position[];

precise gl_TessLevelOuter;

void main (void)
{
    in_te_position[gl_InvocationID] = in_tc_position[gl_InvocationID];

    gl_TessLevelInner[0] = 5.0;
    gl_TessLevelInner[1] = 5.0;

    gl_TessLevelOuter[0] = 1.0 + 59.0 * 0.5 * (in_tc_tessParam[1] + in_tc_tessParam[2]);
    gl_TessLevelOuter[1] = 1.0 + 59.0 * 0.5 * (in_tc_tessParam[2] + in_tc_tessParam[0]);
    gl_TessLevelOuter[2] = 1.0 + 59.0 * 0.5 * (in_tc_tessParam[0] + in_tc_tessParam[1]);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precise.tese]=[
#version 310 es
#extension GL_EXT_tessellation_shader : require
#extension GL_EXT_gpu_shader5 : require

layout(triangles, equal_spacing) in;

layout(location = 0) in highp vec2 in_te_position[];

layout(location = 0) out mediump vec4 in_f_color;

precise gl_Position;

void main(void) {
  highp vec2 pos = gl_TessCoord.x * in_te_position[0] +
                   gl_TessCoord.y * in_te_position[1] +
                   gl_TessCoord.z * in_te_position[2];

  highp float f =
      sqrt(3.0 * min(gl_TessCoord.x, min(gl_TessCoord.y, gl_TessCoord.z))) *
          0.5 +
      0.5;
  in_f_color = vec4(gl_TessCoord * f, 1.0);

  // Offset the position slightly, based on the parity of the bits in the float
  // representation.
  // This is done to detect possible small differences in edge vertex positions
  // between patches.
  uvec2 bits = floatBitsToUint(pos);
  uint numBits = 0u;
  for (uint i = 0u; i < 32u; i++)
    numBits +=
        ((bits[0] << i) & 1u) + ((bits[1] << i) & 1u);
  pos += float(numBits & 1u) * 0.04;

  gl_Position = vec4(pos, 0.0, 1.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precision.frag]=[
#version 310 es
#extension GL_OES_sample_variables : enable
precision mediump float;
in lowp float lowfin;
in mediump float mediumfin;
in highp vec4 highfin;

highp int uniform_high;
mediump int uniform_medium;
lowp int uniform_low;
bvec2 ub2;

out mediump vec4 mediumfout;

highp float global_highp;

lowp vec2 foo(mediump vec3 mv3)
{
    return highfin.xy;
}

bool boolfun(bvec2 bv2)
{
    return bv2 == bvec2(false, true);
}

struct S {
    highp float a;
    lowp float b;
};

in S s;

void main()
{
    lowp int sum = uniform_medium + uniform_high;

    sum += uniform_high;
    sum += uniform_low;
    
    // test maxing precisions of args to get precision of builtin
    lowp float arg1 = 3.2;
    mediump float arg2 = 1023908.2;
    lowp float d = distance(lowfin, mediumfin);

    global_highp = length(highfin);

    highp vec4 local_highp = vec4(global_highp);

    mediumfout = vec4(sin(d)) + arg2 + local_highp;

    sum += 4 + ((ivec2(uniform_low) * ivec2(uniform_high) + ivec2((/* comma operator */uniform_low, uniform_high)))).x;

    mediumfout += vec4(sum);

    if (boolfun(ub2))
        ++mediumfout;
    
    mediumfout *= s.a;
    mediumfout *= s.b;

    mediumfout = ((mediumfin * mediumfin > 4.2) ? 2.0 * mediumfout : 3.0 * mediumfout);
    mediumfout = ((gl_SampleMaskIn[0] >> uniform_medium > 0) ? 2.0 * mediumfout : 3.0 * mediumfout);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precisionArgs.frag]=[
#version 310 es

precision mediump float;

void fooConst(const in float f, const in highp float g) { }

void foo(in float f, in highp float g) { }

      float retM (      float x) { return x; }
highp float retH (highp float x) { return x; }
      float retHM(highp float x) { return x; }
highp float retMH(      float x) { return x; }

void main()
{
    float aM, bM;
    highp float aH, bH;
    fooConst(aM, bM);   // must copy bM
    fooConst(aH, bH);   // must copy aH
    foo(aM, bM);
    foo(aH, bH);

    retM(aM);
    retH(aH);
    retHM(aH);
    retMH(aM);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precisionNonESSamp.frag]=[
#version 450

precision lowp sampler2D;
precision lowp int;
precision lowp float;

uniform lowp sampler2D s;
uniform highp sampler3D t;
layout(rgba32f) uniform lowp image2D i1;
layout(rgba32f) uniform highp image2D i2;

layout(location = 0) in lowp vec2 v2;
layout(location = 1) in lowp vec3 v3;
layout(location = 3) flat in lowp ivec2 iv2;

layout(location = 0) out lowp vec4 color;

void main()
{
    color = texture(s, v2);
    color = texture(t, v3);
    lowp vec4 vi1 = imageLoad(i1, iv2);
    lowp vec4 vi2 = imageLoad(i2, iv2);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.precisionTexture.frag]=[
#version 310 es
precision mediump float;
precision mediump int;
layout(binding = 0) uniform mediump sampler2D texM;
layout(binding = 1) uniform highp sampler2D texH;
layout(binding = 0, rgba32f) uniform readonly mediump image2D imageM;
layout(binding = 1, rgba32f) uniform readonly highp image2D imageH;

layout(location = 0) in highp vec4 vertex;
layout(location = 1) flat in highp ivec2 coord;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 v;
    v = texture(texM, vertex.xy);
    v = texture(texH, vertex.xy);
    v = textureLod(texM, vertex.xy, vertex.z);
    v = textureLod(texH, vertex.xy, vertex.z);
    v = textureProj(texM, vertex.xyz);
    v = textureProj(texH, vertex.xyz);
    v = imageLoad(imageM, coord);
    v = imageLoad(imageH, coord);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.prepost.frag]=[
#version 140

void main()
{
    struct s {
        float y[5];
    } str;

    float t;
    int index = 5;  // all indexing is 4

    str.y[4] = 2.0;             // 2.0
    t = ++str.y[--index];       // 3.0
    str.y[4] += t;              // 6.0
    t = str.y[4]--;             // 5.0 (t = 6.0)
    str.y[index++] += t;        // 11.0
    --str.y[--index];           // 10.0

    float x = str.y[4];
	++x;
	--x;
	x++;
	x--;

	// x is 10.0

	float y = x * ++x;  // 10 * 11
	float z = y * x--;  // 110 * 11

    // x is 10.0
    // z is 1210.0

    vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
    v.y = v.z--;  // (1,3,2,4)
    v.x = --v.w;  // (3,3,2,3)

    gl_FragColor = z * v;// (3630.0, 3630.0, 2420.0, 3630.0)
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.privateVariableTypes.frag]=[
#version 460 core
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable

int8_t i8;
uint8_t u8;
int16_t i16;
uint16_t u16;
int64_t i64;
uint64_t u64;
float16_t f16;

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.pushConstant.vert]=[
#version 400

layout(push_constant) uniform Material {
    int kind;
    float fa[3];
} matInst;

out vec4 color;

void main()
{
    switch (matInst.kind) {
    case 1:  color = vec4(0.2); break;
    case 2:  color = vec4(0.5); break;
    default: color = vec4(0.0); break;
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.pushConstantAnon.vert]=[
#version 400

layout(push_constant) uniform Material {
    int kind;
    float fa[3];
};

out vec4 color;

void main()
{
    switch (kind) {
    case 1:  color = vec4(0.2); break;
    case 2:  color = vec4(0.5); break;
    default: color = vec4(fa[1]); break;
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.qualifiers.vert]=[
#version 430 core

in vec4 inV;

centroid out vec4 outVc;
smooth out vec4 outVs;
flat out vec4 outVf;
noperspective out vec4 outVn;

centroid noperspective out vec4 outVcn;

void main()
{
    outVc = inV;
    outVs = inV;
    outVf = inV;
    outVn = inV;
    outVcn = inV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.queryL.frag]=[
#version 430 core

uniform sampler1D samp1D;
uniform isampler2D isamp2D;
uniform usampler2D usamp2D;
uniform isampler3D isamp3D;
uniform usampler3D usamp3D;
uniform samplerCube sampCube; 
uniform isamplerCube isampCube; 
uniform isampler1DArray isamp1DA;
uniform sampler2DArray samp2DA;
uniform usampler2DArray usamp2DA;
uniform isamplerCubeArray isampCubeA;
uniform usamplerCubeArray usampCubeA;

uniform sampler1DShadow samp1Ds;
uniform sampler2DShadow samp2Ds;
uniform samplerCubeShadow sampCubes;
uniform sampler1DArrayShadow samp1DAs;
uniform sampler2DArrayShadow samp2DAs;
uniform samplerCubeArrayShadow sampCubeAs;

uniform samplerBuffer sampBuf;
uniform sampler2DRect sampRect;

void main()
{
    vec2 lod;
    float pf;
    vec2 pf2;
    vec3 pf3;

    lod = textureQueryLod(samp1D, pf);
    lod += textureQueryLod(isamp2D, pf2);
    lod += textureQueryLod(usamp3D, pf3);
    lod += textureQueryLod(sampCube, pf3);
    lod += textureQueryLod(isamp1DA, pf);
    lod += textureQueryLod(usamp2DA, pf2);
    lod += textureQueryLod(isampCubeA, pf3);

    lod += textureQueryLod(samp1Ds, pf);
    lod += textureQueryLod(samp2Ds, pf2);
    lod += textureQueryLod(sampCubes, pf3);
    lod += textureQueryLod(samp1DAs, pf);
    lod += textureQueryLod(samp2DAs, pf2);
    lod += textureQueryLod(sampCubeAs, pf3);

    int levels;

    levels = textureQueryLevels(samp1D);
    levels += textureQueryLevels(usamp2D);
    levels += textureQueryLevels(isamp3D);
    levels += textureQueryLevels(isampCube);
    levels += textureQueryLevels(isamp1DA);
    levels += textureQueryLevels(samp2DA);
    levels += textureQueryLevels(usampCubeA);

    levels = textureQueryLevels(samp1Ds);
    levels += textureQueryLevels(samp2Ds);
    levels += textureQueryLevels(sampCubes);
    levels += textureQueryLevels(samp1DAs);
    levels += textureQueryLevels(samp2DAs);
    levels += textureQueryLevels(sampCubeAs);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.queueFamilyScope.comp]=[
#version 450
#extension GL_KHR_memory_scope_semantics : require

layout (binding = 0) buffer Buffer { uint a; } A;

void main()
{
    atomicLoad(A.a, gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsAcquire);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.rankShift.comp]=[
#version 450
#extension GL_ARB_gpu_shader_int64 : require

layout(local_size_x = 54) in;

layout(location=4) uniform int64_t arg0;
layout(location=5) uniform uint arg1;

void main()
{
    uint64_t result = arg0 << arg1;
    result = arg0 >> arg1;
    result <<= arg1;
    result >>= arg1;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.register.autoassign-2.frag]=[

SamplerState g_tSamp : register(s0);

Texture2D g_tScene[2] : register(t0);

struct PS_OUTPUT
{
    float4 Color : SV_Target0;
};

void main(out PS_OUTPUT psout)
{
    psout.Color = g_tScene[0].Sample(g_tSamp, float2(0.3,0.4)) +
                  g_tScene[1].Sample(g_tSamp, float2(0.3,0.4));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
2:21; [@5,22:22=':',<COLON>,2:21]; no viable alternative at input 'SamplerState g_tSamp :'; NoViableAltException:null
4:22; [@21,61:61=':',<COLON>,4:22]; mismatched input ':' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', '[', ']', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
8:17; [@41,114:114=':',<COLON>,8:17]; no viable alternative at input 'struct PS_OUTPUT\n{\n    float4 Color :'; NoViableAltException:null
9:0; [@46,128:128='}',<'}'>,9:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[spv.register.autoassign.frag]=[

SamplerState       g_sSamp1 : register(s0);
SamplerState       g_sSamp2;
SamplerState       g_sSamp3[2] : register(s2);
SamplerState       g_sSamp4[3];
SamplerState       g_sSamp5;

SamplerState       g_sSamp_unused1;
SamplerState       g_sSamp_unused2;

Texture1D          g_tTex1 : register(t1);
const uniform Texture1D g_tTex2;
Texture1D          g_tTex3[2] : register(t3);
Texture1D          g_tTex4[3];
Texture1D          g_tTex5;

Texture1D          g_tTex_unused1 : register(t0);
Texture1D          g_tTex_unused2 : register(t2);
Texture1D          g_tTex_unused3;

struct MyStruct_t {
    int a;
    float b;
    float3 c;
};

uniform MyStruct_t mystruct : register(b4);

struct PS_OUTPUT
{
    float4 Color : SV_Target0;
};

uniform float4 myfloat4_a;
uniform float4 myfloat4_b;
uniform int4 myint4_a;

float4 Func1()
{
    return
        g_tTex1    . Sample(g_sSamp1,    0.1) +
        g_tTex2    . Sample(g_sSamp2,    0.2) +
        g_tTex3[0] . Sample(g_sSamp3[0], 0.3) +
        g_tTex3[1] . Sample(g_sSamp3[1], 0.3) +
        g_tTex4[1] . Sample(g_sSamp4[1], 0.4) +
        g_tTex4[2] . Sample(g_sSamp4[2], 0.4) +
        g_tTex5    . Sample(g_sSamp5,    0.5) +
        mystruct.c[1];
}

float4 Func2()
{
    return
        g_tTex1    . Sample(g_sSamp1,    0.1) +
        g_tTex3[1] . Sample(g_sSamp3[1], 0.3);
}

// Not called from entry point:
float4 Func2_unused()
{
    return
        g_tTex_unused1 . Sample(g_sSamp_unused1, 1.1) +
        g_tTex_unused2 . Sample(g_sSamp_unused2, 1.2);
}

PS_OUTPUT main_ep()
{
    PS_OUTPUT psout;
    psout.Color = Func1() + Func2();
    return psout;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
2:28; [@5,29:29=':',<COLON>,2:28]; no viable alternative at input 'SamplerState       g_sSamp1 :'; NoViableAltException:null
4:31; [@25,105:105=':',<COLON>,4:31]; mismatched input ':' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', '[', ']', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
11:27; [@62,283:283=':',<COLON>,11:27]; no viable alternative at input 'Texture1D          g_tTex1 :'; NoViableAltException:null
13:30; [@86,362:362=':',<COLON>,13:30]; mismatched input ':' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', '[', ']', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
17:34; [@112,472:472=':',<COLON>,17:34]; no viable alternative at input 'Texture1D          g_tTex_unused1 :'; NoViableAltException:null
18:34; [@124,522:522=':',<COLON>,18:34]; no viable alternative at input 'Texture1D          g_tTex_unused2 :'; NoViableAltException:null
27:28; [@172,664:664=':',<COLON>,27:28]; no viable alternative at input 'uniform MyStruct_t mystruct :'; NoViableAltException:null
31:17; [@192,717:717=':',<COLON>,31:17]; no viable alternative at input 'struct PS_OUTPUT\n{\n    float4 Color :'; NoViableAltException:null
32:0; [@197,731:731='}',<'}'>,32:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[spv.register.autoassign.rangetest.frag]=[

SamplerState g_tSamp : register(s5);

Texture2D g_tScene[2] : register(t5);

struct PS_OUTPUT
{
    float4 Color : SV_Target0;
};

void main(out PS_OUTPUT psout)
{
    psout.Color = g_tScene[0].Sample(g_tSamp, float2(0.3, 0.3)) +
                  g_tScene[1].Sample(g_tSamp, float2(0.3, 0.3));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
2:21; [@5,22:22=':',<COLON>,2:21]; no viable alternative at input 'SamplerState g_tSamp :'; NoViableAltException:null
4:22; [@21,61:61=':',<COLON>,4:22]; mismatched input ':' expecting {'++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '^^', '||', '[', ']', '.', '+', '-', '*', '/', '%', '<', '>', '&', '|', '^', '?'}; InputMismatchException:null
8:17; [@41,114:114=':',<COLON>,8:17]; no viable alternative at input 'struct PS_OUTPUT\n{\n    float4 Color :'; NoViableAltException:null
9:0; [@46,128:128='}',<'}'>,9:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[spv.register.subpass.frag]=[

// Test binding autoassignment and offset for SubpassInput objects

layout(input_attachment_index = 1) SubpassInput<float4> subpass_f4 : register(t1);
layout(input_attachment_index = 4) SubpassInputMS<float4> subpass_ms_f4;
[[vk::input_attachment_index(7)]] SubpassInput subpass_2;

float4 main() : SV_Target0
{
    float4 result00 = subpass_f4.SubpassLoad();
    float4 result10 = subpass_ms_f4.SubpassLoad(3);
    float4 result73 = subpass_2.SubpassLoad();

    return 0;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
4:47; [@13,116:116='<',<'<'>,4:47]; no viable alternative at input 'layout(input_attachment_index = 1) SubpassInput<'; NoViableAltException:null
5:49; [@37,201:201='<',<'<'>,5:49]; no viable alternative at input 'layout(input_attachment_index = 4) SubpassInputMS<'; NoViableAltException:null
6:56; [@59,281:281=';',<';'>,6:56]; no viable alternative at input '[[vk::input_attachment_index(7)]] SubpassInput subpass_2;'; NoViableAltException:null
8:14; [@68,298:298=':',<COLON>,8:14]; no viable alternative at input 'float4 main() :'; NoViableAltException:null
14:4; [@119,465:470='return',<'return'>,14:4]; extraneous input 'return' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
15:0; [@124,475:475='}',<'}'>,15:0]; extraneous input '}' expecting {<EOF>, 'uniform', 'buffer', 'in', 'out', 'inout', 'highp', 'mediump', 'lowp', 'precision', 'const', 'precise', INVARIANT, 'smooth', 'flat', 'noperspective', 'centroid', 'sample', 'patch', 'attribute', 'coherent', 'volatile', 'restrict', 'varying', 'readonly', 'writeonly', 'shared', 'subroutine', 'devicecoherent', 'queuefamilycoherent', 'workgroupcoherent', 'subgroupcoherent', 'nonprivate', 'layout', 'atomic_uint', 'struct', 'bool', 'bvec2', 'bvec3', 'bvec4', 'int8_t', 'i8vec2', 'i8vec3', 'i8vec4', 'uint8_t', 'ui8vec2', 'ui8vec3', 'ui8vec4', 'int16_t', 'i16vec2', 'i16vec3', 'i16vec4', 'uint16_t', 'ui16vec2', 'ui16vec3', 'ui16vec4', INT32, I32VEC2, I32VEC3, I32VEC4, UINT32, UI32VEC2, UI32VEC3, UI32VEC4, 'int64_t', 'i64vec2', 'i64vec3', 'i64vec4', 'uint64_t', 'ui64vec2', 'ui64vec3', 'ui64vec4', 'float16_t', 'f16vec2', 'f16vec3', 'f16vec4', F16MAT2X2, 'f16mat2x3', 'f16mat2x4', 'f16mat3x2', F16MAT3X3, 'f16mat3x4', 'f16mat4x2', 'f16mat4x3', F16MAT4X4, FLOAT32, F32VEC2, F32VEC3, F32VEC4, F32MAT2X2, F32MAT2X3, F32MAT2X4, F32MAT3X2, F32MAT3X3, F32MAT3X4, F32MAT4X2, F32MAT4X3, F32MAT4X4, FLOAT64, F64VEC2, F64VEC3, F64VEC4, F64MAT2X2, F64MAT2X3, F64MAT2X4, F64MAT3X2, F64MAT3X3, F64MAT3X4, F64MAT4X2, F64MAT4X3, F64MAT4X4, 'image1D', 'image2D', 'image3D', 'uimage1D', 'uimage2D', 'uimage3D', 'iimage1D', 'iimage2D', 'iimage3D', 'sampler1D', 'sampler2D', 'sampler3D', 'sampler2DRect', 'sampler1DShadow', 'sampler2DShadow', 'sampler2DRectShadow', 'sampler1DArray', 'sampler2DArray', 'sampler1DArrayShadow', 'sampler2DArrayShadow', 'isampler1D', 'isampler2D', 'isampler2DRect', 'isampler3D', 'isampler1DArray', 'isampler2DArray', 'usampler1D', 'usampler2D', 'usampler2DRect', 'usampler3D', 'usampler1DArray', 'usampler2DArray', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray', 'image2DRect', 'image1DArray', 'image2DArray', 'image2DMS', 'image2DMSArray', 'iimage2DRect', 'iimage1DArray', 'iimage2DArray', 'iimage2DMS', 'iimage2DMSArray', 'uimage2DRect', 'uimage1DArray', 'uimage2DArray', 'uimage2DMS', 'uimage2DMSArray', 'samplerCube', 'samplerCubeShadow', 'samplerBuffer', 'samplerCubeArray', 'samplerCubeArrayShadow', 'isamplerCube', 'isamplerBuffer', 'isamplerCubeArray', 'usamplerCube', 'usamplerBuffer', 'usamplerCubeArray', 'imageCube', 'imageBuffer', 'imageCubeArray', 'iimageCube', 'iimageBuffer', 'iimageCubeArray', 'uimageCube', 'uimageBuffer', 'uimageCubeArray', 'void', ';', '[', '#', IDENTIFIER}; <no exception>
]


testGlslangErrors[spv.sample.frag]=[
#version 450

layout(location = 0) in sample vec4 samp;
layout(location = 0) out vec4 color;

void main()
{
    color = samp;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.sampleId.frag]=[
#version 450

layout(location = 0) in vec4 samp;
layout(location = 0) out vec4 color;

void main()
{
    if (gl_SampleID < 3)
        color = samp;
    else
        color = 2 * samp;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.sampleMaskOverrideCoverage.frag]=[
#version 450
#extension GL_NV_sample_mask_override_coverage : enable
in vec4 color;
layout(override_coverage) out int gl_SampleMask[];
void main() {
    gl_SampleMask[0] = int(0xFFFFFFFF);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.samplePosition.frag]=[
#version 450

layout(location = 0) in vec4 samp;
layout(location = 0) out vec4 color;

void main()
{
    if (gl_SamplePosition.y < 0.5)
        color = samp;
    else
        color = 2 * samp;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.samplerlessTextureFunctions.frag]=[
#version 450 core
#extension GL_EXT_samplerless_texture_functions : enable

layout(binding = 1) uniform texture2D tex2D;
layout(binding = 1) uniform texture2DMS texMS;
layout(binding = 0) uniform textureBuffer buf;

void main()
{
    vec4 tex2DFetch = texelFetch(tex2D, ivec2(0, 0), 0);
    vec4 texMSFetch = texelFetch(texMS, ivec2(0, 0), 0);
    vec4 bufFetch = texelFetch(buf, 0);

    vec4 tex2DFetchOffset = texelFetchOffset(tex2D, ivec2(0, 0), 0, ivec2(0, 0));

    ivec2 tex2DSize = textureSize(tex2D, 0);
    ivec2 texMSSize = textureSize(texMS);
    int bufSize = textureSize(buf);

    int tex2DLevels = textureQueryLevels(tex2D);

    int texMSSamples = textureSamples(texMS);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.scalarlayout.frag]=[
#version 450 core

#extension GL_EXT_scalar_block_layout : enable

// Block memory layout
struct S
{
    float      a;   // offset 0
    vec2       b;   // offset 4
    double     c;   // offset 16
    float      d;   // offset 24
    vec3       e;   // offset 28
    float      f;   // offset 40
    // size = 44, align = 8
};

layout(column_major, scalar) uniform B1
{
    float      a;     // offset = 0
    vec2       b;     // offset = 4
    vec3       c;     // offset = 12
    float      d[2];  // offset = 24
    mat2x3     e;     // offset = 32, takes 24 bytes, matrixstride = 12
    mat2x3     f[2];  // offset = 56, takes 48 bytes, matrixstride = 12, arraystride = 24
    float      g;     // offset = 104
    S          h;     // offset = 112 (aligned to multiple of 8)
    S          i[2];  // offset = 160 (aligned to multiple of 8) stride = 48
};

layout (std430) uniform;

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.scalarlayoutfloat16.frag]=[
#version 450 core

#extension GL_EXT_shader_16bit_storage: enable
#extension GL_EXT_scalar_block_layout : enable

// Block memory layout
struct S
{
    float16_t      a;   // offset 0
    f16vec2        b;   // offset 2
    double         c;   // offset 8
    float16_t      d;   // offset 16
    f16vec3        e;   // offset 18
    float16_t      f;   // offset 24
    // size = 26, align = 8
};

layout(column_major, scalar) uniform B1
{
    float16_t      a;     // offset = 0
    f16vec2        b;     // offset = 2
    f16vec3        c;     // offset = 6
    float16_t      d[2];  // offset = 12 stride = 2
    float16_t      g;     // offset = 16
    S              h;     // offset = 24 (aligned to multiple of 8)
    S              i[2];  // offset = 56 (aligned to multiple of 8) stride = 32
};

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.separate.frag]=[
#version 400

uniform sampler s;
uniform samplerShadow sShadow;
uniform sampler sA[4];
uniform texture2D t2d;
uniform texture3D t3d[4];
flat in int i;

out vec4 color;

void main()
{
    color = texture(sampler2D(t2d, s), vec2(0.5));
    color += texture(sampler3D(t3d[i], sA[2]), vec3(0.5));
    color += texture(sampler2D(t2d, s), vec2(0.5));
}

uniform texture2D                 tex2D;
uniform textureCube               texCube;
uniform textureCubeArray          texCubeArray;
uniform itextureCubeArray         itexCubeArray;
uniform utextureCubeArray         utexCubeArray;
uniform itexture1DArray           itex1DArray;
uniform utexture1D                utex1D;
uniform itexture1D                itex1D;
uniform utexture1DArray           utex1DArray;
uniform textureBuffer             texBuffer;
uniform texture2DArray            tex2DArray;
uniform itexture2D                itex2D;
uniform itexture3D                itex3D;
uniform itextureCube              itexCube;
uniform itexture2DArray           itex2DArray;
uniform utexture2D                utex2D;
uniform utexture3D                utex3D;
uniform utextureCube              utexCube;
uniform utexture2DArray           utex2DArray;
uniform itexture2DRect            itex2DRect;
uniform utexture2DRect            utex2DRect;
uniform itextureBuffer            itexBuffer;
uniform utextureBuffer            utexBuffer;
uniform texture2DMS               tex2DMS;
uniform itexture2DMS              itex2DMS;
uniform utexture2DMS              utex2DMS;
uniform texture2DMSArray          tex2DMSArray;
uniform itexture2DMSArray         itex2DMSArray;
uniform utexture2DMSArray         utex2DMSArray;
uniform texture1D                 tex1D;
uniform texture3D                 tex3D;
uniform texture2DRect             tex2DRect;
uniform texture1DArray            tex1DArray;

void foo()
{
    sampler2D              (tex2D, s);
    samplerCube            (texCube, s);
    samplerCubeArray       (texCubeArray, s);
    samplerCubeArrayShadow (texCubeArray, sShadow);
    isamplerCubeArray      (itexCubeArray, s);
    usamplerCubeArray      (utexCubeArray, s);
    sampler1DArrayShadow   (tex1DArray, sShadow);
    isampler1DArray        (itex1DArray, s);
    usampler1D             (utex1D, s);
    isampler1D             (itex1D, s);
    usampler1DArray        (utex1DArray, s);
    samplerBuffer          (texBuffer, s);
    samplerCubeShadow      (texCube, sShadow);
    sampler2DArray         (tex2DArray, s);
    sampler2DArrayShadow   (tex2DArray, sShadow);
    isampler2D             (itex2D, s);
    isampler3D             (itex3D, s);
    isamplerCube           (itexCube, s);
    isampler2DArray        (itex2DArray, s);
    usampler2D             (utex2D, s);
    usampler3D             (utex3D, s);
    usamplerCube           (utexCube, s);
    usampler2DArray        (utex2DArray, s);
    isampler2DRect         (itex2DRect, s);
    usampler2DRect         (utex2DRect, s);
    isamplerBuffer         (itexBuffer, s);
    usamplerBuffer         (utexBuffer, s);
    sampler2DMS            (tex2DMS, s);
    isampler2DMS           (itex2DMS, s);
    usampler2DMS           (utex2DMS, s);
    sampler2DMSArray       (tex2DMSArray, s);
    isampler2DMSArray      (itex2DMSArray, s);
    usampler2DMSArray      (utex2DMSArray, s);
    sampler1D              (tex1D, s);
    sampler1DShadow        (tex1D, sShadow);
    sampler3D              (tex3D, s);
    sampler2DShadow        (tex2D, sShadow);
    sampler2DRect          (tex2DRect, s);
    sampler2DRectShadow    (tex2DRect, sShadow);
    sampler1DArray         (tex1DArray, s);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.set.vert]=[
#version 450

layout(set = 4, binding = 7) uniform sampler2D samp2D;

layout(set = 0, binding = 8) buffer setBuf {
    vec4 color;
} setBufInst;

out vec4 color;

void main()
{
    color = setBufInst.color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderBallot.comp]=[
#version 450

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_ARB_shader_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4; 
} data[4];

void main()
{
    uint invocation = (gl_SubGroupInvocationARB + gl_SubGroupSizeARB) % 4;

    uint64_t relMask = gl_SubGroupEqMaskARB +
                       gl_SubGroupGeMaskARB +
                       gl_SubGroupGtMaskARB +
                       gl_SubGroupLeMaskARB +
                       gl_SubGroupLtMaskARB;

    if (relMask == ballotARB(true))
    {
        data[invocation].f4.x   = readInvocationARB(data[0].f4.x,    invocation);
        data[invocation].f4.xy  = readInvocationARB(data[1].f4.xy,   invocation);
        data[invocation].f4.xyz = readInvocationARB(data[2].f4.xyz,  invocation);
        data[invocation].f4     = readInvocationARB(data[3].f4,      invocation);

        data[invocation].i4.x   = readInvocationARB(data[0].i4.x,    invocation);
        data[invocation].i4.xy  = readInvocationARB(data[1].i4.xy,   invocation);
        data[invocation].i4.xyz = readInvocationARB(data[2].i4.xyz,  invocation);
        data[invocation].i4     = readInvocationARB(data[3].i4,      invocation);

        data[invocation].u4.x   = readInvocationARB(data[0].u4.x,    invocation);
        data[invocation].u4.xy  = readInvocationARB(data[1].u4.xy,   invocation);
        data[invocation].u4.xyz = readInvocationARB(data[2].u4.xyz,  invocation);
        data[invocation].u4     = readInvocationARB(data[3].u4,      invocation);
    }
    else
    {
        data[invocation].f4.x   = readFirstInvocationARB(data[0].f4.x);
        data[invocation].f4.xy  = readFirstInvocationARB(data[1].f4.xy);
        data[invocation].f4.xyz = readFirstInvocationARB(data[2].f4.xyz);
        data[invocation].f4     = readFirstInvocationARB(data[3].f4);

        data[invocation].i4.x   = readFirstInvocationARB(data[0].i4.x);
        data[invocation].i4.xy  = readFirstInvocationARB(data[1].i4.xy);
        data[invocation].i4.xyz = readFirstInvocationARB(data[2].i4.xyz);
        data[invocation].i4     = readFirstInvocationARB(data[3].i4);

        data[invocation].u4.x   = readFirstInvocationARB(data[0].u4.x);
        data[invocation].u4.xy  = readFirstInvocationARB(data[1].u4.xy);
        data[invocation].u4.xyz = readFirstInvocationARB(data[2].u4.xyz);
        data[invocation].u4     = readFirstInvocationARB(data[3].u4);
    }
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderBallotAMD.comp]=[
#version 450

#extension GL_ARB_gpu_shader_int64: enable
#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_AMD_gpu_shader_int16: enable
#extension GL_AMD_shader_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    int     i;
    uvec2   uv;
    vec3    fv;
    dvec4   dv;
    int64_t i64;
    u64vec2 u64v;
    f16vec3 f16v;
    i16vec4 i16v;
    uint16_t u16;
};

void main()
{
    i    = minInvocationsAMD(i);
    uv   = minInvocationsAMD(uv);
    fv   = minInvocationsAMD(fv);
    dv   = minInvocationsAMD(dv);
    i64  = minInvocationsAMD(i64);
    u64v = minInvocationsAMD(u64v);
    f16v = minInvocationsAMD(f16v);
    i16v = minInvocationsAMD(i16v);
    u16  = minInvocationsAMD(u16);

    i    = maxInvocationsAMD(i);
    uv   = maxInvocationsAMD(uv);
    fv   = maxInvocationsAMD(fv);
    dv   = maxInvocationsAMD(dv);
    i64  = maxInvocationsAMD(i64);
    u64v = maxInvocationsAMD(u64v);
    f16v = maxInvocationsAMD(f16v);
    i16v = maxInvocationsAMD(i16v);
    u16  = maxInvocationsAMD(u16);

    i    = addInvocationsAMD(i);
    uv   = addInvocationsAMD(uv);
    fv   = addInvocationsAMD(fv);
    dv   = addInvocationsAMD(dv);
    i64  = addInvocationsAMD(i64);
    u64v = addInvocationsAMD(u64v);
    f16v = addInvocationsAMD(f16v);
    i16v = addInvocationsAMD(i16v);
    u16  = addInvocationsAMD(u16);

	i    = minInvocationsNonUniformAMD(i);
    uv   = minInvocationsNonUniformAMD(uv);
    fv   = minInvocationsNonUniformAMD(fv);
    dv   = minInvocationsNonUniformAMD(dv);
    i64  = minInvocationsNonUniformAMD(i64);
    u64v = minInvocationsNonUniformAMD(u64v);
    f16v = minInvocationsNonUniformAMD(f16v);
    i16v = minInvocationsNonUniformAMD(i16v);
    u16  = minInvocationsNonUniformAMD(u16);

    i    = maxInvocationsNonUniformAMD(i);
    uv   = maxInvocationsNonUniformAMD(uv);
    fv   = maxInvocationsNonUniformAMD(fv);
    dv   = maxInvocationsNonUniformAMD(dv);
    i64  = maxInvocationsNonUniformAMD(i64);
    u64v = maxInvocationsNonUniformAMD(u64v);
    f16v = maxInvocationsNonUniformAMD(f16v);
    i16v = maxInvocationsNonUniformAMD(i16v);
    u16  = maxInvocationsNonUniformAMD(u16);

    i    = addInvocationsNonUniformAMD(i);
    uv   = addInvocationsNonUniformAMD(uv);
    fv   = addInvocationsNonUniformAMD(fv);
    dv   = addInvocationsNonUniformAMD(dv);
    i64  = addInvocationsNonUniformAMD(i64);
    u64v = addInvocationsNonUniformAMD(u64v);
    f16v = addInvocationsNonUniformAMD(f16v);
    i16v = addInvocationsNonUniformAMD(i16v);
    u16  = addInvocationsNonUniformAMD(u16);

    i    = minInvocationsInclusiveScanAMD(i);
    uv   = minInvocationsInclusiveScanAMD(uv);
    fv   = minInvocationsInclusiveScanAMD(fv);
    dv   = minInvocationsInclusiveScanAMD(dv);
    i64  = minInvocationsInclusiveScanAMD(i64);
    u64v = minInvocationsInclusiveScanAMD(u64v);
    f16v = minInvocationsInclusiveScanAMD(f16v);
    i16v = minInvocationsInclusiveScanAMD(i16v);
    u16  = minInvocationsInclusiveScanAMD(u16);

    i    = maxInvocationsInclusiveScanAMD(i);
    uv   = maxInvocationsInclusiveScanAMD(uv);
    fv   = maxInvocationsInclusiveScanAMD(fv);
    dv   = maxInvocationsInclusiveScanAMD(dv);
    i64  = maxInvocationsInclusiveScanAMD(i64);
    u64v = maxInvocationsInclusiveScanAMD(u64v);
    f16v = maxInvocationsInclusiveScanAMD(f16v);
    i16v = maxInvocationsInclusiveScanAMD(i16v);
    u16  = maxInvocationsInclusiveScanAMD(u16);

    i    = addInvocationsInclusiveScanAMD(i);
    uv   = addInvocationsInclusiveScanAMD(uv);
    fv   = addInvocationsInclusiveScanAMD(fv);
    dv   = addInvocationsInclusiveScanAMD(dv);
    i64  = addInvocationsInclusiveScanAMD(i64);
    u64v = addInvocationsInclusiveScanAMD(u64v);
    f16v = addInvocationsInclusiveScanAMD(f16v);
    i16v = addInvocationsInclusiveScanAMD(i16v);
    u16  = addInvocationsInclusiveScanAMD(u16);

    i    = minInvocationsExclusiveScanAMD(i);
    uv   = minInvocationsExclusiveScanAMD(uv);
    fv   = minInvocationsExclusiveScanAMD(fv);
    dv   = minInvocationsExclusiveScanAMD(dv);
    i64  = minInvocationsExclusiveScanAMD(i64);
    u64v = minInvocationsExclusiveScanAMD(u64v);
    f16v = minInvocationsExclusiveScanAMD(f16v);
    i16v = minInvocationsExclusiveScanAMD(i16v);
    u16  = minInvocationsExclusiveScanAMD(u16);

    i    = maxInvocationsExclusiveScanAMD(i);
    uv   = maxInvocationsExclusiveScanAMD(uv);
    fv   = maxInvocationsExclusiveScanAMD(fv);
    dv   = maxInvocationsExclusiveScanAMD(dv);
    i64  = maxInvocationsExclusiveScanAMD(i64);
    u64v = maxInvocationsExclusiveScanAMD(u64v);
    f16v = maxInvocationsExclusiveScanAMD(f16v);
    i16v = maxInvocationsExclusiveScanAMD(i16v);
    u16  = maxInvocationsExclusiveScanAMD(u16);

    i    = addInvocationsExclusiveScanAMD(i);
    uv   = addInvocationsExclusiveScanAMD(uv);
    fv   = addInvocationsExclusiveScanAMD(fv);
    dv   = addInvocationsExclusiveScanAMD(dv);
    i64  = addInvocationsExclusiveScanAMD(i64);
    u64v = addInvocationsExclusiveScanAMD(u64v);
    f16v = addInvocationsExclusiveScanAMD(f16v);
    i16v = addInvocationsExclusiveScanAMD(i16v);
    u16  = addInvocationsExclusiveScanAMD(u16);

    i    = minInvocationsInclusiveScanNonUniformAMD(i);
    uv   = minInvocationsInclusiveScanNonUniformAMD(uv);
    fv   = minInvocationsInclusiveScanNonUniformAMD(fv);
    dv   = minInvocationsInclusiveScanNonUniformAMD(dv);
    i64  = minInvocationsInclusiveScanNonUniformAMD(i64);
    u64v = minInvocationsInclusiveScanNonUniformAMD(u64v);
    f16v = minInvocationsInclusiveScanNonUniformAMD(f16v);
    i16v = minInvocationsInclusiveScanNonUniformAMD(i16v);
    u16  = minInvocationsInclusiveScanNonUniformAMD(u16);

    i    = maxInvocationsInclusiveScanNonUniformAMD(i);
    uv   = maxInvocationsInclusiveScanNonUniformAMD(uv);
    fv   = maxInvocationsInclusiveScanNonUniformAMD(fv);
    dv   = maxInvocationsInclusiveScanNonUniformAMD(dv);
    i64  = maxInvocationsInclusiveScanNonUniformAMD(i64);
    u64v = maxInvocationsInclusiveScanNonUniformAMD(u64v);
    f16v = maxInvocationsInclusiveScanNonUniformAMD(f16v);
    i16v = maxInvocationsInclusiveScanNonUniformAMD(i16v);
    u16  = maxInvocationsInclusiveScanNonUniformAMD(u16);

    i    = addInvocationsInclusiveScanNonUniformAMD(i);
    uv   = addInvocationsInclusiveScanNonUniformAMD(uv);
    fv   = addInvocationsInclusiveScanNonUniformAMD(fv);
    dv   = addInvocationsInclusiveScanNonUniformAMD(dv);
    i64  = addInvocationsInclusiveScanNonUniformAMD(i64);
    u64v = addInvocationsInclusiveScanNonUniformAMD(u64v);
    f16v = addInvocationsInclusiveScanNonUniformAMD(f16v);
    i16v = addInvocationsInclusiveScanNonUniformAMD(i16v);
    u16  = addInvocationsInclusiveScanNonUniformAMD(u16);

    i    = minInvocationsExclusiveScanNonUniformAMD(i);
    uv   = minInvocationsExclusiveScanNonUniformAMD(uv);
    fv   = minInvocationsExclusiveScanNonUniformAMD(fv);
    dv   = minInvocationsExclusiveScanNonUniformAMD(dv);
    i64  = minInvocationsExclusiveScanNonUniformAMD(i64);
    u64v = minInvocationsExclusiveScanNonUniformAMD(u64v);
    f16v = minInvocationsExclusiveScanNonUniformAMD(f16v);
    i16v = minInvocationsExclusiveScanNonUniformAMD(i16v);
    u16  = minInvocationsExclusiveScanNonUniformAMD(u16);

    i    = maxInvocationsExclusiveScanNonUniformAMD(i);
    uv   = maxInvocationsExclusiveScanNonUniformAMD(uv);
    fv   = maxInvocationsExclusiveScanNonUniformAMD(fv);
    dv   = maxInvocationsExclusiveScanNonUniformAMD(dv);
    i64  = maxInvocationsExclusiveScanNonUniformAMD(i64);
    u64v = maxInvocationsExclusiveScanNonUniformAMD(u64v);
    f16v = maxInvocationsExclusiveScanNonUniformAMD(f16v);
    i16v = maxInvocationsExclusiveScanNonUniformAMD(i16v);
    u16  = maxInvocationsExclusiveScanNonUniformAMD(u16);

    i    = addInvocationsExclusiveScanNonUniformAMD(i);
    uv   = addInvocationsExclusiveScanNonUniformAMD(uv);
    fv   = addInvocationsExclusiveScanNonUniformAMD(fv);
    dv   = addInvocationsExclusiveScanNonUniformAMD(dv);
    i64  = addInvocationsExclusiveScanNonUniformAMD(i64);
    u64v = addInvocationsExclusiveScanNonUniformAMD(u64v);
    f16v = addInvocationsExclusiveScanNonUniformAMD(f16v);
    i16v = addInvocationsExclusiveScanNonUniformAMD(i16v);
    u16  = addInvocationsExclusiveScanNonUniformAMD(u16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderDrawParams.vert]=[
#version 450 core

#extension GL_ARB_shader_draw_parameters: enable

layout(binding = 0) uniform Block
{
    vec4 pos[2][4];
} block;

void main()
{
    if ((gl_BaseVertexARB > 0) || (gl_BaseInstanceARB > 0))
        gl_Position = block.pos[0][gl_DrawIDARB % 4];
    else
        gl_Position = block.pos[1][gl_DrawIDARB % 4];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderFragMaskAMD.frag]=[
#version 450 core

#extension GL_AMD_shader_fragment_mask: enable

layout(binding = 0) uniform sampler2DMS       s2DMS;
layout(binding = 1) uniform isampler2DMSArray is2DMSArray;

layout(binding = 2, input_attachment_index = 0) uniform usubpassInputMS usubpassMS;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 f4 = vec4(0.0);

    uint fragMask = fragmentMaskFetchAMD(s2DMS, ivec2(2, 3));
    uint fragIndex = (fragMask & 0xF0) >> 4;
    f4 += fragmentFetchAMD(s2DMS, ivec2(2, 3), 1);

    fragMask = fragmentMaskFetchAMD(is2DMSArray, ivec3(2, 3, 1));
    fragIndex = (fragMask & 0xF0) >> 4;
    f4 += fragmentFetchAMD(is2DMSArray, ivec3(2, 3, 1), fragIndex);

    fragMask = fragmentMaskFetchAMD(usubpassMS);
    fragIndex = (fragMask & 0xF0) >> 4;
    f4 += fragmentFetchAMD(usubpassMS, fragIndex);

    fragColor = f4;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderGroupVote.comp]=[
#version 450

#extension GL_ARB_shader_group_vote : enable

layout(local_size_x = 4, local_size_y = 4) in;

layout(std430, binding = 0) buffer Buffers
{
    bool b;
};

void main()
{
    bool b1 = b;

    b1 = anyInvocationARB(b1);
    b1 = allInvocationsARB(b1);
    b1 = allInvocationsEqualARB(b1);

    b = b1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderImageFootprint.frag]=[
#version 450

#extension GL_NV_shader_texture_footprint : require
.
.
layout (location = 0) in vec2 P2;
layout (location = 2) in vec3 P3;
layout (location = 3) in flat int granularity;
layout (location = 4) in float lodClamp;
layout (location = 5) in float lod;
layout (location = 6) in vec2 dx;
layout (location = 8) in vec2 dy;
layout (location = 9) in float bias;

uniform sampler2D sample2D;
uniform sampler3D sample3D;

buffer result2D {
    bool ret2D;
    uvec2 anchor2D;
    uvec2 offset2D;
    uvec2 mask2D;
    uint lod2D;
    uint granularity2D;
};

buffer result3D {
    bool ret3D;
    uvec3 anchor3D;
    uvec3 offset3D;
    uvec2 mask3D;
    uint lod3D;
    uint granularity3D;
};

void main() {
 gl_TextureFootprint2DNV fp2D;
 gl_TextureFootprint3DNV fp3D;
 
 ret2D = textureFootprintNV(sample2D, P2, granularity, true, fp2D);
 anchor2D = fp2D.anchor;
 offset2D = fp2D.offset;
 mask2D = fp2D.mask;
 lod2D = fp2D.lod;
 granularity2D = fp2D.granularity;
 
 ret2D = textureFootprintNV(sample2D, P2, granularity, true, fp2D, bias);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret2D = textureFootprintClampNV(sample2D, P2, lodClamp, granularity, true, fp2D);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret2D = textureFootprintClampNV(sample2D, P2, lodClamp, granularity, true, fp2D, bias);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret2D = textureFootprintLodNV(sample2D, P2, lod, granularity, true, fp2D);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret2D = textureFootprintGradNV(sample2D, P2, dx, dy, granularity, true, fp2D);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret2D = textureFootprintGradClampNV(sample2D, P2, dx, dy, lodClamp, granularity, true, fp2D);
 anchor2D += fp2D.anchor;
 offset2D += fp2D.offset;
 mask2D += fp2D.mask;
 lod2D += fp2D.lod;
 granularity2D += fp2D.granularity;
 
 ret3D = textureFootprintNV(sample3D, P3, granularity, true, fp3D);
 anchor3D = fp3D.anchor;
 offset3D = fp3D.offset;
 mask3D = fp3D.mask;
 lod3D = fp3D.lod;
 granularity3D = fp3D.granularity;
 
 ret3D = textureFootprintNV(sample3D, P3, granularity, true, fp3D, bias);
 anchor3D += fp3D.anchor;
 offset3D += fp3D.offset;
 mask3D += fp3D.mask;
 lod3D += fp3D.lod;
 granularity3D += fp3D.granularity;
 
 ret3D = textureFootprintClampNV(sample3D, P3, lodClamp, granularity, true, fp3D);
 anchor3D += fp3D.anchor;
 offset3D += fp3D.offset;
 mask3D += fp3D.mask;
 lod3D += fp3D.lod;
 granularity3D += fp3D.granularity;
 
 ret3D = textureFootprintClampNV(sample3D, P3, lodClamp, granularity, true, fp3D, bias);
 anchor3D += fp3D.anchor;
 offset3D += fp3D.offset;
 mask3D += fp3D.mask;
 lod3D += fp3D.lod;
 granularity3D += fp3D.granularity;
 
 ret3D = textureFootprintLodNV(sample3D, P3, lod, granularity, true, fp3D);
 anchor3D += fp3D.anchor;
 offset3D += fp3D.offset;
 mask3D += fp3D.mask;
 lod3D += fp3D.lod;
 granularity3D += fp3D.granularity;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shaderStencilExport.frag]=[
#version 450 core

#extension GL_ARB_shader_stencil_export: enable

out int gl_FragStencilRefARB;

void main()
{
    gl_FragStencilRefARB = 100;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shadingRate.frag]=[
#version 450

#extension GL_NV_shading_rate_image : require

layout (location = 0) out vec2 FragmentSize;
layout (location = 2) out int InvocationsPerPixel;

void main () {
    FragmentSize = gl_FragmentSizeNV;
    InvocationsPerPixel = gl_InvocationsPerPixelNV;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shiftOps.frag]=[
#version 450

flat in int   i1;
flat in uint  u1;
flat in ivec3 i3;
flat in uvec3 u3;

out ivec3 icolor;
out uvec3 ucolor;

void main()
{
    icolor = i3 << u1;
    icolor <<= 4u;

    ucolor = u3 >> i1;
    ucolor >>= 5;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.shortCircuit.frag]=[
#version 400

flat in ivec4 uiv4;
in vec4 uv4;
bool ub;
bool uba;
bvec4 ub41, ub42;
in float uf;
flat in int ui;

out float of1;
out vec4  of4;

bool foo() { ++of1; return of1 > 10.0; }

void main()
{
    of1 = 0.0;
    of4 = vec4(0.0);

    if (ub || ui > 2)  // not worth short circuiting
        ++of1;

    if (ub && !uba)  // not worth short circuiting
        ++of1;

    if (ub || foo())   // must short circuit
        ++of1;

    if (ub && foo())   // must short circuit
        ++of1;

    if (foo() || ub)   // not worth short circuiting
        ++of1;

    if (foo() && ub)   // not worth short circuiting
        ++of1;

    if (ub || ++of1 > 1.0)   // must short circuit
        ++of4;

    if (++of1 > 1.0 || ub)   // not worth short circuiting
        ++of4;

    if (ub || sin(uf) * 4.0 > of1)  // worth short circuiting
        ++of1;

    if (ub && sin(uf) * 4.0 > of1)  // worth short circuiting
        ++of1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.simpleFunctionCall.frag]=[
#version 150

in vec4 BaseColor;

vec4 foo()
{
    return BaseColor;
}

void main()
{
    gl_FragColor = foo();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.simpleMat.vert]=[
#version 330

varying mat4 mvp;

in vec4 v;
in mat3 am3;
in mat4 arraym[3];

out float f;
out vec4 glPos;
//out mat4 mout[2];

void main()
{
	//needs complex output blocks to work: gl_Position = mvp * v;
    glPos = mvp * v;
	f = am3[2][1] + arraym[1][2][3];
    //mout[1] = arraym[2];
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.smBuiltins.frag]=[
#version 450
#extension GL_NV_shader_sm_builtins: enable
layout(location = 0) out uvec4 data;
void main (void)
{
  data = uvec4(gl_WarpsPerSMNV, gl_SMCountNV, gl_WarpIDNV, gl_SMIDNV);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.smBuiltins.vert]=[
#version 450
#extension GL_NV_shader_sm_builtins: enable
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_VertexIndex] = uvec4(gl_WarpsPerSMNV, gl_SMCountNV, gl_WarpIDNV, gl_SMIDNV);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.sparseTexture.frag]=[
#version 450
#extension GL_ARB_sparse_texture2: enable

uniform sampler2D               s2D;
uniform sampler3D               s3D;
uniform sampler2DShadow         s2DShadow;
uniform samplerCubeShadow       sCubeShadow;
uniform sampler2DArrayShadow    s2DArrayShadow;
uniform sampler2DRectShadow     s2DRectShadow;
uniform samplerCubeArrayShadow  sCubeArrayShadow;
uniform sampler2DMS             s2DMS;

uniform isamplerCube            isCube;
uniform isampler2DArray         is2DArray;

uniform usamplerCubeArray       usCubeArray;
uniform usampler2DRect          us2DRect;

layout(rgba32f) uniform image2D i2D;
layout(rgba32i) uniform iimage3D ii3D;
layout(rgba32f) uniform image2DMS i2DMS;

in vec2 c2;
in vec3 c3;
in vec4 c4;

in flat ivec2 ic2;
in flat ivec3 ic3;

out vec4 outColor;

void main()
{
    int   resident = 0;
    vec4  texel  = vec4(0.0);
    ivec4 itexel = ivec4(0);
    uvec4 utexel = uvec4(0);

    resident |= sparseTextureARB(s2D, c2, texel);
    resident |= sparseTextureARB(s3D, c3, texel, 2.0);
    resident |= sparseTextureARB(isCube, c3, itexel);
    resident |= sparseTextureARB(s2DShadow, c3, texel.x);
    resident |= sparseTextureARB(sCubeArrayShadow, c4, 1.0, texel.x);

    resident |= sparseTextureLodARB(s2D, c2, 2.0, texel);
    resident |= sparseTextureLodARB(usCubeArray, c4, 1.0, utexel);
    resident |= sparseTextureLodARB(s2DShadow, c3, 2.0, texel.y);

    resident |= sparseTextureOffsetARB(s3D, c3, ivec3(2), texel, 2.0);
    resident |= sparseTextureOffsetARB(us2DRect, c2, ivec2(3), utexel);
    resident |= sparseTextureOffsetARB(s2DArrayShadow, c4, ivec2(5), texel.z);

    resident |= sparseTexelFetchARB(s2D, ivec2(c2), 2, texel);
    resident |= sparseTexelFetchARB(us2DRect, ivec2(c2), utexel);
    resident |= sparseTexelFetchARB(s2DMS, ivec2(c2), 4, texel);

    resident |= sparseTexelFetchOffsetARB(s3D, ivec3(c3), 2, ivec3(4), texel);
    resident |= sparseTexelFetchOffsetARB(us2DRect, ivec2(c2), ivec2(3), utexel);

    resident |= sparseTextureLodOffsetARB(s2D, c2, 2.0, ivec2(5), texel);
    resident |= sparseTextureLodOffsetARB(is2DArray, c3, 2.0, ivec2(6), itexel);
    resident |= sparseTextureLodOffsetARB(s2DShadow, c3, 2.0, ivec2(7), texel.z);

    resident |= sparseTextureGradARB(s3D, c3, c3, c3, texel);
    resident |= sparseTextureGradARB(sCubeShadow, c4, c3, c3, texel.y);
    resident |= sparseTextureGradARB(usCubeArray, c4, c3, c3, utexel);

    resident |= sparseTextureGradOffsetARB(s2D, c2, c2, c2, ivec2(5), texel);
    resident |= sparseTextureGradOffsetARB(s2DRectShadow, c3, c2, c2, ivec2(6), texel.w);
    resident |= sparseTextureGradOffsetARB(is2DArray, c3, c2, c2, ivec2(2), itexel);

    resident |= sparseTextureGatherARB(s2D, c2, texel);
    resident |= sparseTextureGatherARB(is2DArray, c3, itexel, 2);
    resident |= sparseTextureGatherARB(s2DArrayShadow, c3, 2.0, texel);

    resident |= sparseTextureGatherOffsetARB(s2D, c2, ivec2(4), texel);
    resident |= sparseTextureGatherOffsetARB(is2DArray, c3, ivec2(5), itexel, 2);
    resident |= sparseTextureGatherOffsetARB(s2DRectShadow, c2, 2.0, ivec2(7), texel);

    const ivec2 constOffsets[4] = ivec2[4](ivec2(1,2), ivec2(3,4), ivec2(15,16), ivec2(-2,0));
    resident |= sparseTextureGatherOffsetsARB(s2D, c2, constOffsets, texel);
    resident |= sparseTextureGatherOffsetsARB(is2DArray, c3, constOffsets, itexel, 2);
    resident |= sparseTextureGatherOffsetsARB(s2DRectShadow, c2, 2.0, constOffsets, texel);

    resident |= sparseImageLoadARB(i2D, ic2, texel);
    resident |= sparseImageLoadARB(ii3D, ic3, itexel);
    resident |= sparseImageLoadARB(i2DMS, ic2, 3, texel);

    outColor = sparseTexelsResidentARB(resident) ? texel : vec4(itexel) + vec4(utexel);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.sparseTextureClamp.frag]=[
#version 450
#extension GL_ARB_sparse_texture_clamp: enable

uniform sampler2D               s2D;
uniform sampler3D               s3D;
uniform sampler2DShadow         s2DShadow;
uniform samplerCubeShadow       sCubeShadow;
uniform sampler2DArrayShadow    s2DArrayShadow;
uniform sampler2DRectShadow     s2DRectShadow;
uniform samplerCubeArrayShadow  sCubeArrayShadow;

uniform isamplerCube            isCube;
uniform isampler2DArray         is2DArray;

uniform usamplerCubeArray       usCubeArray;
uniform usampler2DRect          us2DRect;

in vec2 c2;
in vec3 c3;
in vec4 c4;

in float lodClamp;

out vec4 outColor;

void main()
{
    int   resident = 0;
    vec4  texel  = vec4(0.0);
    ivec4 itexel = ivec4(0);
    uvec4 utexel = uvec4(0);

    resident |= sparseTextureClampARB(s2D, c2, lodClamp, texel);
    resident |= sparseTextureClampARB(s3D, c3, lodClamp, texel, 2.0);
    resident |= sparseTextureClampARB(isCube, c3, lodClamp, itexel);
    resident |= sparseTextureClampARB(s2DShadow, c3, lodClamp, texel.x);
    resident |= sparseTextureClampARB(sCubeArrayShadow, c4, 1.0, lodClamp, texel.x);

    texel   += textureClampARB(s2D, c2, lodClamp);
    texel   += textureClampARB(s3D, c3, lodClamp, 2.0);
    itexel  += textureClampARB(isCube, c3, lodClamp);
    texel.x += textureClampARB(s2DShadow, c3, lodClamp);
    texel.x += textureClampARB(sCubeArrayShadow, c4, 1.0, lodClamp);

    resident |= sparseTextureOffsetClampARB(s3D, c3, ivec3(2), lodClamp, texel, 2.0);
    resident |= sparseTextureOffsetClampARB(us2DRect, c2, ivec2(3), lodClamp, utexel);
    resident |= sparseTextureOffsetClampARB(s2DArrayShadow, c4, ivec2(5), lodClamp, texel.z);

    texel   += textureOffsetClampARB(s3D, c3, ivec3(2), lodClamp, 2.0);
    utexel  += textureOffsetClampARB(us2DRect, c2, ivec2(3), lodClamp);
    texel.z += textureOffsetClampARB(s2DArrayShadow, c4, ivec2(5), lodClamp);

    resident |= sparseTextureGradClampARB(s3D, c3, c3, c3, lodClamp, texel);
    resident |= sparseTextureGradClampARB(sCubeShadow, c4, c3, c3, lodClamp, texel.y);
    resident |= sparseTextureGradClampARB(usCubeArray, c4, c3, c3, lodClamp, utexel);

    texel   += textureGradClampARB(s3D, c3, c3, c3, lodClamp);
    texel.y += textureGradClampARB(sCubeShadow, c4, c3, c3, lodClamp);
    utexel  += textureGradClampARB(usCubeArray, c4, c3, c3, lodClamp);

    resident |= sparseTextureGradOffsetClampARB(s2D, c2, c2, c2, ivec2(5), lodClamp, texel);
    resident |= sparseTextureGradOffsetClampARB(s2DRectShadow, c3, c2, c2, ivec2(6), lodClamp, texel.w);
    resident |= sparseTextureGradOffsetClampARB(is2DArray, c3, c2, c2, ivec2(2), lodClamp, itexel);

    texel   += textureGradOffsetClampARB(s2D, c2, c2, c2, ivec2(5), lodClamp);
    texel.w += textureGradOffsetClampARB(s2DRectShadow, c3, c2, c2, ivec2(6), lodClamp);
    itexel  += textureGradOffsetClampARB(is2DArray, c3, c2, c2, ivec2(2), lodClamp);

    outColor = sparseTexelsResidentARB(resident) ? texel : vec4(itexel) + vec4(utexel);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConst.vert]=[
#version 450

layout(constant_id = 11) const int a = 8;

void main()
{
    gl_Position = vec4(1.0) / a;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstant.comp]=[
#version 450

layout(local_size_x_id = 18, local_size_z_id = 19) in;
layout(local_size_x = 32, local_size_y = 32) in;

buffer bn {
    uint a;
} bi;

void main()
{
    bi.a = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstant.float16.comp]=[
#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

layout(constant_id = 1) const float16_t sc0 = 9.5hf;
layout(constant_id = 2) const float16_t sc1 = -14.25hf;

layout (set = 0, binding = 0, std430) writeonly buffer Output {
    float16_t r0;
    float16_t r1;
} sb_out;
.
.
void main (void)
{
    sb_out.r0 = sc0;
    sb_out.r1 = sc1;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstant.int16.comp]=[
#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

layout(constant_id = 1) const int16_t sc0 = 20000s;
layout(constant_id = 2) const int16_t sc1 = -20000s;

layout (set = 0, binding = 0, std430) writeonly buffer Output {
    int16_t r0;
    int16_t r1;
} sb_out;
.
.
void main (void)
{
    sb_out.r0 = sc0;
    sb_out.r1 = sc1;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstant.int8.comp]=[
#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(constant_id = 1) const int8_t sc0 = int8_t(127);
layout(constant_id = 2) const int8_t sc1 = int8_t(-127);

layout (set = 0, binding = 0, std430) writeonly buffer Output {
    int8_t r0;
    int8_t r1;
} sb_out;
.
.
void main (void)
{
    sb_out.r0 = sc0;
    sb_out.r1 = sc1;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstant.vert]=[
#version 400

layout(constant_id = 16) const int arraySize = 5;
in vec4 ucol[arraySize];

layout(constant_id = 17) const bool spBool = true;
layout(constant_id = 18) const float spFloat = 3.14;
layout(constant_id = 19) const double spDouble = 3.1415926535897932384626433832795;
layout(constant_id = 22) const uint scale = 2;

layout(constant_id = 24) gl_MaxImageUnits;

out vec4 color;
out int size;

// parameter should be considered same type as ucol
void foo(vec4 p[arraySize]);

void main()
{
    color = ucol[2];
    size = arraySize;
    if (spBool)
        color *= scale;
    color += float(spDouble / spFloat);

    foo(ucol);
}

layout(constant_id = 116) const int dupArraySize = 12;
in vec4 dupUcol[dupArraySize];

layout(constant_id = 117) const bool spDupBool = true;
layout(constant_id = 118) const float spDupFloat = 3.14;
layout(constant_id = 119) const double spDupDouble = 3.1415926535897932384626433832795;
layout(constant_id = 122) const uint dupScale = 2;

void foo(vec4 p[arraySize])
{
    color += dupUcol[2];
    size += dupArraySize;
    if (spDupBool)
        color *= dupScale;
    color += float(spDupDouble / spDupFloat);
}

int builtin_spec_constant()
{
    int result = gl_MaxImageUnits;
    return result;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstantComposite.vert]=[
#version 450

// constant_id specified scalar spec constants
layout(constant_id = 200) const int spec_int = 3;
layout(constant_id = 201) const float spec_float = 3.14;
layout(constant_id = 202) const
    double spec_double = 3.1415926535897932384626433832795;
layout(constant_id = 203) const bool spec_bool = true;

// const float cast_spec_float = float(spec_float);

// Flat struct
struct flat_struct {
    int i;
    float f;
    double d;
    bool b;
};

// Nesting struct
struct nesting_struct {
    flat_struct nested;
    vec4 v;
    int i;
};

// Expect OpSpecConstantComposite
// Flat struct initializer
//const flat_struct spec_flat_struct_all_spec = {spec_int, spec_float,
//                                               spec_double, spec_bool};
//const flat_struct spec_flat_struct_partial_spec = {30, 30.14, spec_double,
//                                                   spec_bool};

// Nesting struct initializer
//const nesting_struct nesting_struct_ctor = {
//    {spec_int, spec_float, spec_double, false},
//    vec4(0.1, 0.1, 0.1, 0.1),
//    spec_int};

// Vector constructor
//const vec4 spec_vec4_all_spec =
//    vec4(spec_float, spec_float, spec_float, spec_float);
//const vec4 spec_vec4_partial_spec =
//    vec4(spec_float, spec_float, 300.14, 300.14);
//const vec4 spec_vec4_from_one_scalar = vec4(spec_float);

// Matrix constructor
//const mat2x3 spec_mat2x3 = mat2x3(spec_float, spec_float, spec_float, 1.1, 2.2, 3.3);
//const mat2x3 spec_mat2x3_from_one_scalar = mat2x3(spec_float);

// Struct nesting constructor
//const nesting_struct spec_nesting_struct_all_spec = {
//    spec_flat_struct_all_spec, spec_vec4_all_spec, spec_int};
//const nesting_struct spec_nesting_struct_partial_spec = {
//    spec_flat_struct_partial_spec, spec_vec4_partial_spec, 3000};

//const float spec_float_array[5] = {spec_float, spec_float, 1.0, 2.0, 3.0};
//const int spec_int_array[5] = {spec_int, spec_int, 1, 2, 30};

// global_vec4_array_with_spec_length is not a spec constant, but its array
// size is. When calling global_vec4_array_with_spec_length.length(), A
// TIntermSymbol Node should be returned, instead of a TIntermConstantUnion
// node which represents a known constant value.
in vec4 global_vec4_array_with_spec_length[spec_int];

out vec4 color;

void refer_primary_spec_const() {
    if (spec_bool) color *= spec_int;
}

void refer_composite_spec_const() {
    //color += spec_vec4_all_spec;
    //color -= spec_vec4_partial_spec;
}

void refer_copmosite_dot_dereference() {
    //color *= spec_nesting_struct_all_spec.i;
    //color += spec_vec4_all_spec.x;
}

void refer_composite_bracket_dereference() {
    //color -= spec_float_array[1];
    //color /= spec_int_array[spec_int_array[spec_int]];
}

int refer_spec_const_array_length() {
    int len = global_vec4_array_with_spec_length.length();
    return len;
}

void declare_spec_const_in_func() {
    //const nesting_struct spec_const_declared_in_func = {
    //    spec_flat_struct_partial_spec, spec_vec4_partial_spec, 10};
    //color /= spec_const_declared_in_func.i;
}

void main() {}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specConstantOperations.vert]=[
#version 450

layout(constant_id = 200) const float sp_float = 3.1415926;
layout(constant_id = 201) const int sp_int = 10;
layout(constant_id = 202) const uint sp_uint = 100;
layout(constant_id = 203) const int sp_sint = -10;
layout(constant_id = 204) const double sp_double = 2.718281828459;

//
// Scalars
//

// float <-> double conversion
const float float_from_double = float(sp_double);
const double double_from_float = double(sp_float);

// uint/int <-> bool conversion
const bool bool_from_int = bool(sp_int);
const bool bool_from_uint = bool(sp_uint);
const int int_from_bool = int(bool_from_int);
const uint uint_from_bool = uint(bool_from_int);

// uint <-> int
const uint sp_uint_from_sint = uint(sp_sint);
const int sp_sint_from_uint = int(sp_uint);

// Negate and Not
const int negate_int = -sp_int;
const int not_int = ~sp_int;

// Add and Subtract
const int sp_int_add_two = sp_int + 2;
const int sp_int_add_two_sub_three = sp_int + 2 - 3;
const int sp_int_add_two_sub_four = sp_int_add_two - 4;

// Mul, Div and Rem
const int sp_sint_mul_two = sp_sint * 2;
const uint sp_uint_mul_two = sp_uint * 2;
const int sp_sint_mul_two_div_five = sp_sint_mul_two / 5;
const uint sp_uint_mul_two_div_five = sp_uint_mul_two / 5;
const int sp_sint_rem_four = sp_sint % 4;
const uint sp_uint_rem_four = sp_uint % 4;
const int sp_sint_mul_three_div_five = sp_sint * 3 / 5;

// Shift
const int sp_sint_shift_right_arithmetic = sp_sint >> 10;
const uint sp_uint_shift_right_arithmetic = sp_uint >> 20;
const int sp_sint_shift_left = sp_sint << 1;
const uint sp_uint_shift_left = sp_uint << 2;

// Bitwise And, Or, Xor
const int sp_sint_or_256 = sp_sint | 0x100;
const uint sp_uint_xor_512 = sp_uint ^ 0x200;

/* // Scalar comparison */
const bool sp_int_lt_sp_sint = sp_int < sp_sint;
const bool sp_uint_equal_sp_uint = sp_uint == sp_uint;
const bool sp_int_gt_sp_sint = sp_int > sp_sint;

//
// Vectors
//
const ivec4 iv = ivec4(20, 30, sp_int, sp_int);
const uvec4 uv = uvec4(sp_uint, sp_uint, -1, -2);
//const vec4 fv = vec4(sp_float, 1.25, sp_float, 1.25);

// uint/int <-> bool conversion
const bvec4 bv_from_iv = bvec4(iv);
const bvec4 bv_from_uv = bvec4(uv);
const ivec4 iv_from_bv = ivec4(bv_from_iv);
const uvec4 uv_from_bv = uvec4(bv_from_iv);

// uint <-> int
const uvec4 uv_from_iv = uvec4(iv);
const ivec4 iv_from_uv = ivec4(uv);

// Negate and Not
const ivec4 not_iv = ~iv;
const ivec4 negate_iv = -iv;

// Add and Subtract
const ivec4 iv_add_two = iv + 2;
const ivec4 iv_add_two_sub_three = iv + 2 - 3;
const ivec4 iv_add_two_sub_four = iv_add_two_sub_three - 4;

// Mul, Div and Rem
const ivec4 iv_mul_two = iv * 2;
const ivec4 iv_mul_two_div_five = iv_mul_two / 5;
const ivec4 iv_rem_four = iv % 4;

// Shift
const ivec4 iv_shift_right_arithmetic = iv >> 10;
const ivec4 iv_shift_left = iv << 2;

// Bitwise And, Or, Xor
const ivec4 iv_or_1024 = iv | 0x400;
const uvec4 uv_xor_2048 = uv ^ 0x800;

// Swizzles
const int iv_x = iv.x;
const ivec2 iv_yx = iv.yx;
const ivec3 iv_zyx = iv.zyx;
const ivec4 iv_yzxw = iv.yzxw;

int non_const_array_size_from_spec_const() {
    int array[sp_int + 2];
    for (int i = 0; i < sp_int + 2; i++) {
        array[i] = 1023;
    }
    return array[sp_int + 1];
}

// ternary
layout(constant_id = 210) const int a = 4;
layout(constant_id = 211) const int b = 6;
layout(constant_id = 212) const bool c = true;
int ternayArray1[a > b ? a : b];
const int t1 = c ? 13 : 17;
const int t2 = c ? a : 17;
const int t3 = true ? a : 17;
const int t4 = a > b ? 13 + a : 17 * b;
const vec2 v2 = !c ? vec2(1.0) : vec2(2.0);

void main() {}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.specTexture.frag]=[
#version 450

layout(constant_id = 1) const int offs = 0;
layout(binding = 0) uniform sampler2D tex;
layout(location = 0) out vec4 color_out;

void main(void)
{
  color_out = textureLodOffset(tex, vec2(0.0, 0.0), 0.0, ivec2(offs, offs));
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.stereoViewRendering.tesc]=[
#version 450

#extension GL_NV_viewport_array2 :require
#extension GL_NV_stereo_view_rendering : require

layout(vertices = 4) out;

out gl_PerVertex {
    int gl_SecondaryViewportMaskNV[2];
    vec4 gl_SecondaryPositionNV;
} gl_out[4];

layout (viewport_relative, secondary_view_offset = 1) out highp int gl_Layer;

void main()
{
    gl_out[gl_InvocationID].gl_SecondaryViewportMaskNV[0]            = 1;
    gl_out[gl_InvocationID].gl_SecondaryPositionNV = gl_in[1].gl_Position + gl_in[1].gl_SecondaryPositionNV;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.stereoViewRendering.vert]=[
#version 450

#extension GL_NV_viewport_array2 :require
#extension GL_NV_stereo_view_rendering : require

layout (viewport_relative, secondary_view_offset = 2) out highp int gl_Layer;
void main()
{
    gl_SecondaryViewportMaskNV[0] = 1;
    gl_SecondaryPositionNV        = gl_Position;
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.storageBuffer.vert]=[
#version 450

#pragma use_storage_buffer

uniform ub {
    vec4 a;
} ubi;

buffer bb {
    vec4 b;
} bbi;

void main()
{
    gl_Position = ubi.a + bbi.b;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.structAssignment.frag]=[
#version 140

precision mediump int;

uniform sampler2D samp2D;
in mediump vec2 coord;

struct lunarStruct1 {
    int i;
    float f;
};

struct lunarStruct2 {
    int i;
    float f;
	lunarStruct1 s1_1;
};

struct lunarStruct3 {
	lunarStruct2 s2_1;
    int i;
    float f;
	lunarStruct1 s1_1;
};
.
.
lunarStruct1 foo;
lunarStruct2 foo2;
lunarStruct3 foo3;

void main()
{
	lunarStruct2 locals2;

	if (foo3.s2_1.i > 0)
		locals2 = foo3.s2_1;
	else
		locals2 = foo2;

	gl_FragColor =  locals2.s1_1.f * texture(samp2D, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.structDeref.frag]=[
#version 140

uniform sampler2D samp2D;
in vec2 coord;

struct s0 {
    int i;
};

struct s00 {
    s0 s0_0;
};

struct s1 {
    int i;
    float f;
    s0 s0_1;
};

struct s2 {
    int i;
    float f;
    s1 s1_1;
};

struct s3 {
    s2[12] s2_1;
    int i;
    float f;
    s1 s1_1;
};
.
.
s0 foo0;
s1 foo1;
s2 foo2;
s3 foo3;

s00 foo00;

void main()
{
    s0 locals0;
    s2 locals2;
    s00 locals00;

    float[6] fArray;

    s1[10] locals1Array;

    if (foo3.s2_1[9].i > 0) {
        locals2.f = 1.0;
        locals2.s1_1 = s1(0, 1.0, s0(0));
        fArray = float[6]( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        locals1Array[6] = foo1;
        locals0 = s0(0);
        locals00 = s00(s0(0));
    } else {
        locals2.f = coord.x;
        locals2.s1_1 = s1(1, coord.y, foo0);
        fArray = float[6]( 0.0, 1.0, 2.0, 3.0, 4.0, 5.0);
        locals1Array[6] = locals2.s1_1;
        locals0 = foo1.s0_1;
        locals00 = foo00;
    }

    if (locals0.i > 5)
        locals0 = locals00.s0_0;

    gl_FragColor = (float(locals0.i) + locals1Array[6].f + fArray[3] + locals2.s1_1.f) * texture(samp2D, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.structure.frag]=[
#version 140
uniform sampler2D samp2D;
in vec2 coord;

struct lunarStruct1 {
    int i;
	float f[4];
	vec4 color[5];
};

struct lunarStruct2 {
    int i[5];
    float f;
	lunarStruct1 s1_1[7];
};

lunarStruct1 foo;
lunarStruct2 foo2[5];

void main()
{
	float scale = 0.0;

	if (foo2[3].i[4] > 0)
		scale = foo2[3].s1_1[2].color[3].x;
	else
		scale = foo2[3].s1_1[2].f[3];

	gl_FragColor =  scale * texture(samp2D, coord);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroup.frag]=[
#version 450
#extension GL_KHR_shader_subgroup_basic: enable
layout(location = 0) out uvec4 data;
void main (void)
{
  data = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroup.geom]=[
#version 450
#extension GL_KHR_shader_subgroup_basic: enable
layout(points) in;
layout(points, max_vertices = 1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveIDIn] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroup.tesc]=[
#version 450
#extension GL_KHR_shader_subgroup_basic: enable
layout(vertices=1) out;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroup.tese]=[
#version 450
#extension GL_KHR_shader_subgroup_basic: enable
layout(isolines) in;
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_PrimitiveID] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroup.vert]=[
#version 450
#extension GL_KHR_shader_subgroup_basic: enable
layout(set = 0, binding = 0, std430) buffer Output
{
  uvec4 result[];
};

void main (void)
{
  result[gl_VertexIndex] = uvec4(gl_SubgroupSize, gl_SubgroupInvocationID, 0, 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupArithmetic.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_arithmetic: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupAdd(data[3].f4);

    data[invocation].i4.x   = subgroupAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAdd(data[3].i4);

    data[invocation].u4.x   = subgroupAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAdd(data[3].u4);

    data[invocation].d4.x   = subgroupAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupAdd(data[3].d4);

    data[invocation].f4.x   = subgroupMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupMul(data[3].f4);

    data[invocation].i4.x   = subgroupMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupMul(data[3].i4);

    data[invocation].u4.x   = subgroupMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupMul(data[3].u4);

    data[invocation].d4.x   = subgroupMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupMul(data[3].d4);

    data[invocation].f4.x   = subgroupMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupMin(data[3].f4);

    data[invocation].i4.x   = subgroupMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupMin(data[3].i4);

    data[invocation].u4.x   = subgroupMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupMin(data[3].u4);

    data[invocation].d4.x   = subgroupMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupMin(data[3].d4);

    data[invocation].f4.x   = subgroupMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupMax(data[3].f4);

    data[invocation].i4.x   = subgroupMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupMax(data[3].i4);

    data[invocation].u4.x   = subgroupMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupMax(data[3].u4);

    data[invocation].d4.x   = subgroupMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupMax(data[3].d4);

    data[invocation].i4.x   = subgroupAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAnd(data[3].i4);

    data[invocation].u4.x   = subgroupAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupOr(data[3].i4);

    data[invocation].u4.x   = subgroupOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupXor(data[3].i4);

    data[invocation].u4.x   = subgroupXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupInclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupInclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupExclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupExclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveXor(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupBallot.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[invocation].u4.x = subgroupBallotBitCount(result);
    data[invocation].u4.y = subgroupBallotBitExtract(result, 0) ? 1 : 0;
    data[invocation].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[invocation].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    if ((relMask == result) && subgroupInverseBallot(data[0].u4))
    {
        data[invocation].f4.x   = subgroupBroadcast(data[0].f4.x,    3);
        data[invocation].f4.xy  = subgroupBroadcast(data[1].f4.xy,   3);
        data[invocation].f4.xyz = subgroupBroadcast(data[2].f4.xyz,  3);
        data[invocation].f4     = subgroupBroadcast(data[3].f4,      3);

        data[invocation].i4.x   = subgroupBroadcast(data[0].i4.x,    2);
        data[invocation].i4.xy  = subgroupBroadcast(data[1].i4.xy,   2);
        data[invocation].i4.xyz = subgroupBroadcast(data[2].i4.xyz,  2);
        data[invocation].i4     = subgroupBroadcast(data[3].i4,      2);

        data[invocation].u4.x   = subgroupBroadcast(data[0].u4.x,    1);
        data[invocation].u4.xy  = subgroupBroadcast(data[1].u4.xy,   1);
        data[invocation].u4.xyz = subgroupBroadcast(data[2].u4.xyz,  1);
        data[invocation].u4     = subgroupBroadcast(data[3].u4,      1);

        data[invocation].d4.x   = subgroupBroadcast(data[0].d4.x,    0);
        data[invocation].d4.xy  = subgroupBroadcast(data[1].d4.xy,   0);
        data[invocation].d4.xyz = subgroupBroadcast(data[2].d4.xyz,  0);
        data[invocation].d4     = subgroupBroadcast(data[3].d4,      0);

        data[invocation].i4.x   = int(subgroupBroadcast(data[0].i4.x < 0,            1));
        data[invocation].i4.xy  = ivec2(subgroupBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1));
        data[invocation].i4.xyz = ivec3(subgroupBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1));
        data[invocation].i4     = ivec4(subgroupBroadcast(lessThan(data[1].i4, ivec4(0)), 1));
    }
    else
    {
        data[invocation].f4.x   = subgroupBroadcastFirst(data[0].f4.x);
        data[invocation].f4.xy  = subgroupBroadcastFirst(data[1].f4.xy);
        data[invocation].f4.xyz = subgroupBroadcastFirst(data[2].f4.xyz);
        data[invocation].f4     = subgroupBroadcastFirst(data[3].f4);

        data[invocation].i4.x   = subgroupBroadcastFirst(data[0].i4.x);
        data[invocation].i4.xy  = subgroupBroadcastFirst(data[1].i4.xy);
        data[invocation].i4.xyz = subgroupBroadcastFirst(data[2].i4.xyz);
        data[invocation].i4     = subgroupBroadcastFirst(data[3].i4);

        data[invocation].u4.x   = subgroupBroadcastFirst(data[0].u4.x);
        data[invocation].u4.xy  = subgroupBroadcastFirst(data[1].u4.xy);
        data[invocation].u4.xyz = subgroupBroadcastFirst(data[2].u4.xyz);
        data[invocation].u4     = subgroupBroadcastFirst(data[3].u4);

        data[invocation].d4.x   = subgroupBroadcastFirst(data[0].d4.x);
        data[invocation].d4.xy  = subgroupBroadcastFirst(data[1].d4.xy);
        data[invocation].d4.xyz = subgroupBroadcastFirst(data[2].d4.xyz);
        data[invocation].d4     = subgroupBroadcastFirst(data[3].d4);

        data[invocation].i4.x   = int(subgroupBroadcastFirst(data[0].i4.x < 0));
        data[invocation].i4.xy  = ivec2(subgroupBroadcastFirst(lessThan(data[1].i4.xy, ivec2(0))));
        data[invocation].i4.xyz = ivec3(subgroupBroadcastFirst(lessThan(data[1].i4.xyz, ivec3(0))));
        data[invocation].i4     = ivec4(subgroupBroadcastFirst(lessThan(data[1].i4, ivec4(0))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupBallotNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 relMask = gl_SubgroupEqMask +
                       gl_SubgroupGeMask +
                       gl_SubgroupGtMask +
                       gl_SubgroupLeMask +
                       gl_SubgroupLtMask;

    uvec4 result = subgroupBallot(true);

    data[invocation].u4.x = subgroupBallotBitCount(result);
    data[invocation].u4.y = subgroupBallotBitExtract(result, 0) ? 1 : 0;
    data[invocation].u4.z = subgroupBallotInclusiveBitCount(result) + subgroupBallotExclusiveBitCount(result);
    data[invocation].u4.w = subgroupBallotFindLSB(result) + subgroupBallotFindMSB(result);

    data[invocation].f4.x   = subgroupBroadcast(data[0].f4.x,    invocation);  // ERROR: not constant
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupBasic.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_basic: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffer
{
    int a[];
} data;

void main()
{
    data.a[gl_SubgroupSize] = 1;
    data.a[gl_SubgroupInvocationID] = 1;
    data.a[gl_NumSubgroups] = 1;
    data.a[gl_SubgroupID] = (subgroupElect()) ? 1 : 0;
    subgroupBarrier();
    subgroupMemoryBarrier();
    subgroupMemoryBarrierBuffer();
    subgroupMemoryBarrierShared();
    subgroupMemoryBarrierImage();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupClustered.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupClusteredAdd(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredAdd(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredAdd(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredAdd(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredAdd(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredAdd(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredAdd(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredAdd(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredAdd(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredAdd(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredAdd(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredAdd(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredAdd(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredAdd(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredAdd(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMul(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMul(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMul(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMul(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMul(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMul(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMul(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMul(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMul(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMul(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMul(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMul(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMul(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMul(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMul(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMul(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMin(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMin(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMin(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMin(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMin(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMin(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMin(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMin(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMin(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMin(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMin(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMin(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMin(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMin(data[3].d4, 1);

    data[invocation].f4.x   = subgroupClusteredMax(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupClusteredMax(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupClusteredMax(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupClusteredMax(data[3].f4, 1);

    data[invocation].i4.x   = subgroupClusteredMax(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredMax(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredMax(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredMax(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredMax(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredMax(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredMax(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredMax(data[3].u4, 1);

    data[invocation].d4.x   = subgroupClusteredMax(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupClusteredMax(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupClusteredMax(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupClusteredMax(data[3].d4, 1);

    data[invocation].i4.x   = subgroupClusteredAnd(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredAnd(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredAnd(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredAnd(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredAnd(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredAnd(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredAnd(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredAnd(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredAnd(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredAnd(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredAnd(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredAnd(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].i4.x   = subgroupClusteredOr(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredOr(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredOr(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredOr(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredOr(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredOr(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredOr(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredOr(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredOr(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredOr(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredOr(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredOr(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].i4.x   = subgroupClusteredXor(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupClusteredXor(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupClusteredXor(data[3].i4, 1);

    data[invocation].u4.x   = subgroupClusteredXor(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupClusteredXor(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupClusteredXor(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupClusteredXor(data[3].u4, 1);

    data[invocation].i4.x   =   int(subgroupClusteredXor(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupClusteredXor(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupClusteredXor(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupClusteredXor(lessThan(data[1].i4, ivec4(0)), 1));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupClusteredNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    int a = 1;
    const int aConst = 1;

    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.xy  = subgroupClusteredAdd(data[1].f4.xy, 0);          // ERROR, less than 1

    data[invocation].f4.x   = subgroupClusteredMul(data[0].f4.x, 3);           // ERROR, not a power of 2

    data[invocation].i4.xy  = subgroupClusteredMin(data[1].i4.xy, 8);
    data[invocation].i4.xyz = subgroupClusteredMin(data[2].i4.xyz, 6);         // ERROR, not a power of 2

    data[invocation].f4.x   = subgroupClusteredMax(data[0].f4.x, -1);          // ERROR, less than 1

    data[invocation].i4     = subgroupClusteredAnd(data[3].i4, -3);            // ERROR, less than 1

    data[invocation].i4.x   = subgroupClusteredOr(data[0].i4.x, a);            // ERROR, not constant
    data[invocation].i4.xy  = subgroupClusteredOr(data[1].i4.xy, aConst);

    data[invocation].i4.x   = subgroupClusteredXor(data[0].i4.x, 1 + a);       // ERROR, not constant
    data[invocation].i4.xy  = subgroupClusteredXor(data[1].i4.xy, aConst + a); // ERROR, not constant
    data[invocation].i4.xyz = subgroupClusteredXor(data[2].i4.xyz, 1 + aConst);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesArithmetic.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupAdd(data[3].i8);

    data[invocation].i8.x   = subgroupMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupMul(data[3].i8);

    data[invocation].i8.x   = subgroupMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupMin(data[3].i8);

    data[invocation].i8.x   = subgroupMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupMax(data[3].i8);

    data[invocation].i8.x   = subgroupAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupAnd(data[3].i8);

    data[invocation].i8.x   = subgroupOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupOr(data[3].i8);

    data[invocation].i8.x   = subgroupXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupXor(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveAdd(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMul(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMin(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMax(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveAnd(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveOr(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveXor(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveAdd(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMul(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMin(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMax(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveAnd(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveOr(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveXor(data[3].i8);

    data[invocation].u8.x   = subgroupAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupAdd(data[3].u8);

    data[invocation].u8.x   = subgroupMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupMul(data[3].u8);

    data[invocation].u8.x   = subgroupMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupMin(data[3].u8);

    data[invocation].u8.x   = subgroupMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupMax(data[3].u8);

    data[invocation].u8.x   = subgroupAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupAnd(data[3].u8);

    data[invocation].u8.x   = subgroupOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupOr(data[3].u8);

    data[invocation].u8.x   = subgroupXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupXor(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveAdd(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMul(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMin(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMax(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveAnd(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveOr(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveXor(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveAdd(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMul(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMin(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMax(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveAnd(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveOr(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveXor(data[3].u8);

    data[invocation].i16.x   = subgroupAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupAdd(data[3].i16);

    data[invocation].i16.x   = subgroupMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupMul(data[3].i16);

    data[invocation].i16.x   = subgroupMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupMin(data[3].i16);

    data[invocation].i16.x   = subgroupMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupMax(data[3].i16);

    data[invocation].i16.x   = subgroupAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupAnd(data[3].i16);

    data[invocation].i16.x   = subgroupOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupOr(data[3].i16);

    data[invocation].i16.x   = subgroupXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupXor(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveAdd(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMul(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMin(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMax(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveAnd(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveOr(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveXor(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveAdd(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMul(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMin(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMax(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveAnd(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveOr(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveXor(data[3].i16);

    data[invocation].u16.x   = subgroupAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupAdd(data[3].u16);

    data[invocation].u16.x   = subgroupMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupMul(data[3].u16);

    data[invocation].u16.x   = subgroupMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupMin(data[3].u16);

    data[invocation].u16.x   = subgroupMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupMax(data[3].u16);

    data[invocation].u16.x   = subgroupAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupAnd(data[3].u16);

    data[invocation].u16.x   = subgroupOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupOr(data[3].u16);

    data[invocation].u16.x   = subgroupXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupXor(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveAdd(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMul(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMin(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMax(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveAnd(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveOr(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveXor(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveAdd(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMul(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMin(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMax(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveAnd(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveOr(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveXor(data[3].u16);

    data[invocation].i64.x   = subgroupAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupAdd(data[3].i64);

    data[invocation].i64.x   = subgroupMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupMul(data[3].i64);

    data[invocation].i64.x   = subgroupMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupMin(data[3].i64);

    data[invocation].i64.x   = subgroupMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupMax(data[3].i64);

    data[invocation].i64.x   = subgroupAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupAnd(data[3].i64);

    data[invocation].i64.x   = subgroupOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupOr(data[3].i64);

    data[invocation].i64.x   = subgroupXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupXor(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveAdd(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMul(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMin(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMax(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveAnd(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveOr(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveXor(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveAdd(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMul(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMin(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMax(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveAnd(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveOr(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveXor(data[3].i64);

    data[invocation].u64.x   = subgroupAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupAdd(data[3].u64);

    data[invocation].u64.x   = subgroupMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupMul(data[3].u64);

    data[invocation].u64.x   = subgroupMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupMin(data[3].u64);

    data[invocation].u64.x   = subgroupMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupMax(data[3].u64);

    data[invocation].u64.x   = subgroupAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupAnd(data[3].u64);

    data[invocation].u64.x   = subgroupOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupOr(data[3].u64);

    data[invocation].u64.x   = subgroupXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupXor(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveAdd(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMul(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMin(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMax(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveAnd(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveOr(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveXor(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveAdd(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMul(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMin(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMax(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveAnd(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveOr(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveXor(data[3].u64);

    data[invocation].f16.x   = subgroupAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupAdd(data[3].f16);

    data[invocation].f16.x   = subgroupMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupMul(data[3].f16);

    data[invocation].f16.x   = subgroupMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupMin(data[3].f16);

    data[invocation].f16.x   = subgroupMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupMax(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveAdd(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMul(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMin(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMax(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveAdd(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMul(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMin(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMax(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesArithmeticNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupAdd(data[3].i8);

    data[invocation].i8.x   = subgroupMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupMul(data[3].i8);

    data[invocation].i8.x   = subgroupMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupMin(data[3].i8);

    data[invocation].i8.x   = subgroupMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupMax(data[3].i8);

    data[invocation].i8.x   = subgroupAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupAnd(data[3].i8);

    data[invocation].i8.x   = subgroupOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupOr(data[3].i8);

    data[invocation].i8.x   = subgroupXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupXor(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveAdd(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMul(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMin(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveMax(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveAnd(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveOr(data[3].i8);

    data[invocation].i8.x   = subgroupInclusiveXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupInclusiveXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupInclusiveXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupInclusiveXor(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveAdd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveAdd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveAdd(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveAdd(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMul(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMul(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMul(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMul(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMin(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMin(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMin(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMin(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveMax(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveMax(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveMax(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveMax(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveAnd(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveAnd(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveAnd(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveAnd(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveOr(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveOr(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveOr(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveOr(data[3].i8);

    data[invocation].i8.x   = subgroupExclusiveXor(data[0].i8.x);
    data[invocation].i8.xy  = subgroupExclusiveXor(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupExclusiveXor(data[2].i8.xyz);
    data[invocation].i8     = subgroupExclusiveXor(data[3].i8);

    data[invocation].u8.x   = subgroupAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupAdd(data[3].u8);

    data[invocation].u8.x   = subgroupMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupMul(data[3].u8);

    data[invocation].u8.x   = subgroupMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupMin(data[3].u8);

    data[invocation].u8.x   = subgroupMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupMax(data[3].u8);

    data[invocation].u8.x   = subgroupAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupAnd(data[3].u8);

    data[invocation].u8.x   = subgroupOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupOr(data[3].u8);

    data[invocation].u8.x   = subgroupXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupXor(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveAdd(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMul(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMin(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveMax(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveAnd(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveOr(data[3].u8);

    data[invocation].u8.x   = subgroupInclusiveXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupInclusiveXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupInclusiveXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupInclusiveXor(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveAdd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveAdd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveAdd(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveAdd(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMul(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMul(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMul(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMul(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMin(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMin(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMin(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMin(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveMax(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveMax(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveMax(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveMax(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveAnd(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveAnd(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveAnd(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveAnd(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveOr(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveOr(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveOr(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveOr(data[3].u8);

    data[invocation].u8.x   = subgroupExclusiveXor(data[0].u8.x);
    data[invocation].u8.xy  = subgroupExclusiveXor(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupExclusiveXor(data[2].u8.xyz);
    data[invocation].u8     = subgroupExclusiveXor(data[3].u8);

    data[invocation].i16.x   = subgroupAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupAdd(data[3].i16);

    data[invocation].i16.x   = subgroupMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupMul(data[3].i16);

    data[invocation].i16.x   = subgroupMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupMin(data[3].i16);

    data[invocation].i16.x   = subgroupMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupMax(data[3].i16);

    data[invocation].i16.x   = subgroupAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupAnd(data[3].i16);

    data[invocation].i16.x   = subgroupOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupOr(data[3].i16);

    data[invocation].i16.x   = subgroupXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupXor(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveAdd(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMul(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMin(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveMax(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveAnd(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveOr(data[3].i16);

    data[invocation].i16.x   = subgroupInclusiveXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupInclusiveXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupInclusiveXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupInclusiveXor(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveAdd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveAdd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveAdd(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveAdd(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMul(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMul(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMul(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMul(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMin(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMin(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMin(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMin(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveMax(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveMax(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveMax(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveMax(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveAnd(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveAnd(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveAnd(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveAnd(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveOr(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveOr(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveOr(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveOr(data[3].i16);

    data[invocation].i16.x   = subgroupExclusiveXor(data[0].i16.x);
    data[invocation].i16.xy  = subgroupExclusiveXor(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupExclusiveXor(data[2].i16.xyz);
    data[invocation].i16     = subgroupExclusiveXor(data[3].i16);

    data[invocation].u16.x   = subgroupAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupAdd(data[3].u16);

    data[invocation].u16.x   = subgroupMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupMul(data[3].u16);

    data[invocation].u16.x   = subgroupMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupMin(data[3].u16);

    data[invocation].u16.x   = subgroupMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupMax(data[3].u16);

    data[invocation].u16.x   = subgroupAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupAnd(data[3].u16);

    data[invocation].u16.x   = subgroupOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupOr(data[3].u16);

    data[invocation].u16.x   = subgroupXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupXor(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveAdd(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMul(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMin(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveMax(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveAnd(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveOr(data[3].u16);

    data[invocation].u16.x   = subgroupInclusiveXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupInclusiveXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupInclusiveXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupInclusiveXor(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveAdd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveAdd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveAdd(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveAdd(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMul(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMul(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMul(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMul(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMin(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMin(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMin(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMin(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveMax(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveMax(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveMax(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveMax(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveAnd(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveAnd(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveAnd(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveAnd(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveOr(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveOr(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveOr(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveOr(data[3].u16);

    data[invocation].u16.x   = subgroupExclusiveXor(data[0].u16.x);
    data[invocation].u16.xy  = subgroupExclusiveXor(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupExclusiveXor(data[2].u16.xyz);
    data[invocation].u16     = subgroupExclusiveXor(data[3].u16);

    data[invocation].i64.x   = subgroupAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupAdd(data[3].i64);

    data[invocation].i64.x   = subgroupMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupMul(data[3].i64);

    data[invocation].i64.x   = subgroupMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupMin(data[3].i64);

    data[invocation].i64.x   = subgroupMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupMax(data[3].i64);

    data[invocation].i64.x   = subgroupAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupAnd(data[3].i64);

    data[invocation].i64.x   = subgroupOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupOr(data[3].i64);

    data[invocation].i64.x   = subgroupXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupXor(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveAdd(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMul(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMin(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveMax(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveAnd(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveOr(data[3].i64);

    data[invocation].i64.x   = subgroupInclusiveXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupInclusiveXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupInclusiveXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupInclusiveXor(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveAdd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveAdd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveAdd(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveAdd(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMul(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMul(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMul(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMul(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMin(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMin(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMin(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMin(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveMax(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveMax(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveMax(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveMax(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveAnd(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveAnd(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveAnd(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveAnd(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveOr(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveOr(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveOr(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveOr(data[3].i64);

    data[invocation].i64.x   = subgroupExclusiveXor(data[0].i64.x);
    data[invocation].i64.xy  = subgroupExclusiveXor(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupExclusiveXor(data[2].i64.xyz);
    data[invocation].i64     = subgroupExclusiveXor(data[3].i64);

    data[invocation].u64.x   = subgroupAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupAdd(data[3].u64);

    data[invocation].u64.x   = subgroupMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupMul(data[3].u64);

    data[invocation].u64.x   = subgroupMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupMin(data[3].u64);

    data[invocation].u64.x   = subgroupMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupMax(data[3].u64);

    data[invocation].u64.x   = subgroupAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupAnd(data[3].u64);

    data[invocation].u64.x   = subgroupOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupOr(data[3].u64);

    data[invocation].u64.x   = subgroupXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupXor(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveAdd(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMul(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMin(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveMax(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveAnd(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveOr(data[3].u64);

    data[invocation].u64.x   = subgroupInclusiveXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupInclusiveXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupInclusiveXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupInclusiveXor(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveAdd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveAdd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveAdd(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveAdd(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMul(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMul(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMul(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMul(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMin(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMin(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMin(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMin(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveMax(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveMax(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveMax(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveMax(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveAnd(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveAnd(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveAnd(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveAnd(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveOr(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveOr(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveOr(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveOr(data[3].u64);

    data[invocation].u64.x   = subgroupExclusiveXor(data[0].u64.x);
    data[invocation].u64.xy  = subgroupExclusiveXor(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupExclusiveXor(data[2].u64.xyz);
    data[invocation].u64     = subgroupExclusiveXor(data[3].u64);

    data[invocation].f16.x   = subgroupAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupAdd(data[3].f16);

    data[invocation].f16.x   = subgroupMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupMul(data[3].f16);

    data[invocation].f16.x   = subgroupMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupMin(data[3].f16);

    data[invocation].f16.x   = subgroupMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupMax(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveAdd(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMul(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMin(data[3].f16);

    data[invocation].f16.x   = subgroupInclusiveMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupInclusiveMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupInclusiveMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupInclusiveMax(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveAdd(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveAdd(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveAdd(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveAdd(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMul(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMul(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMul(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMul(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMin(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMin(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMin(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMin(data[3].f16);

    data[invocation].f16.x   = subgroupExclusiveMax(data[0].f16.x);
    data[invocation].f16.xy  = subgroupExclusiveMax(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupExclusiveMax(data[2].f16.xyz);
    data[invocation].f16     = subgroupExclusiveMax(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesBallot.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupBroadcast(data[0].i8.x,    3);
    data[invocation].i8.xy  = subgroupBroadcast(data[1].i8.xy,   3);
    data[invocation].i8.xyz = subgroupBroadcast(data[2].i8.xyz,  3);
    data[invocation].i8     = subgroupBroadcast(data[3].i8,      3);
    data[invocation].i8.x   = subgroupBroadcastFirst(data[0].i8.x);
    data[invocation].i8.xy  = subgroupBroadcastFirst(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupBroadcastFirst(data[2].i8.xyz);
    data[invocation].i8     = subgroupBroadcastFirst(data[3].i8);

    data[invocation].u8.x   = subgroupBroadcast(data[0].u8.x,    3);
    data[invocation].u8.xy  = subgroupBroadcast(data[1].u8.xy,   3);
    data[invocation].u8.xyz = subgroupBroadcast(data[2].u8.xyz,  3);
    data[invocation].u8     = subgroupBroadcast(data[3].u8,      3);
    data[invocation].u8.x   = subgroupBroadcastFirst(data[0].u8.x);
    data[invocation].u8.xy  = subgroupBroadcastFirst(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupBroadcastFirst(data[2].u8.xyz);
    data[invocation].u8     = subgroupBroadcastFirst(data[3].u8);

    data[invocation].i16.x   = subgroupBroadcast(data[0].i16.x,    3);
    data[invocation].i16.xy  = subgroupBroadcast(data[1].i16.xy,   3);
    data[invocation].i16.xyz = subgroupBroadcast(data[2].i16.xyz,  3);
    data[invocation].i16     = subgroupBroadcast(data[3].i16,      3);
    data[invocation].i16.x   = subgroupBroadcastFirst(data[0].i16.x);
    data[invocation].i16.xy  = subgroupBroadcastFirst(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupBroadcastFirst(data[2].i16.xyz);
    data[invocation].i16     = subgroupBroadcastFirst(data[3].i16);

    data[invocation].u16.x   = subgroupBroadcast(data[0].u16.x,    3);
    data[invocation].u16.xy  = subgroupBroadcast(data[1].u16.xy,   3);
    data[invocation].u16.xyz = subgroupBroadcast(data[2].u16.xyz,  3);
    data[invocation].u16     = subgroupBroadcast(data[3].u16,      3);
    data[invocation].u16.x   = subgroupBroadcastFirst(data[0].u16.x);
    data[invocation].u16.xy  = subgroupBroadcastFirst(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupBroadcastFirst(data[2].u16.xyz);
    data[invocation].u16     = subgroupBroadcastFirst(data[3].u16);

    data[invocation].i64.x   = subgroupBroadcast(data[0].i64.x,    3);
    data[invocation].i64.xy  = subgroupBroadcast(data[1].i64.xy,   3);
    data[invocation].i64.xyz = subgroupBroadcast(data[2].i64.xyz,  3);
    data[invocation].i64     = subgroupBroadcast(data[3].i64,      3);
    data[invocation].i64.x   = subgroupBroadcastFirst(data[0].i64.x);
    data[invocation].i64.xy  = subgroupBroadcastFirst(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupBroadcastFirst(data[2].i64.xyz);
    data[invocation].i64     = subgroupBroadcastFirst(data[3].i64);

    data[invocation].u64.x   = subgroupBroadcast(data[0].u64.x,    3);
    data[invocation].u64.xy  = subgroupBroadcast(data[1].u64.xy,   3);
    data[invocation].u64.xyz = subgroupBroadcast(data[2].u64.xyz,  3);
    data[invocation].u64     = subgroupBroadcast(data[3].u64,      3);
    data[invocation].u64.x   = subgroupBroadcastFirst(data[0].u64.x);
    data[invocation].u64.xy  = subgroupBroadcastFirst(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupBroadcastFirst(data[2].u64.xyz);
    data[invocation].u64     = subgroupBroadcastFirst(data[3].u64);

    data[invocation].f16.x   = subgroupBroadcast(data[0].f16.x,    3);
    data[invocation].f16.xy  = subgroupBroadcast(data[1].f16.xy,   3);
    data[invocation].f16.xyz = subgroupBroadcast(data[2].f16.xyz,  3);
    data[invocation].f16     = subgroupBroadcast(data[3].f16,      3);
    data[invocation].f16.x   = subgroupBroadcastFirst(data[0].f16.x);
    data[invocation].f16.xy  = subgroupBroadcastFirst(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupBroadcastFirst(data[2].f16.xyz);
    data[invocation].f16     = subgroupBroadcastFirst(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesBallotNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupBroadcast(data[0].i8.x,    3);
    data[invocation].i8.xy  = subgroupBroadcast(data[1].i8.xy,   3);
    data[invocation].i8.xyz = subgroupBroadcast(data[2].i8.xyz,  3);
    data[invocation].i8     = subgroupBroadcast(data[3].i8,      3);
    data[invocation].i8.x   = subgroupBroadcastFirst(data[0].i8.x);
    data[invocation].i8.xy  = subgroupBroadcastFirst(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupBroadcastFirst(data[2].i8.xyz);
    data[invocation].i8     = subgroupBroadcastFirst(data[3].i8);

    data[invocation].u8.x   = subgroupBroadcast(data[0].u8.x,    3);
    data[invocation].u8.xy  = subgroupBroadcast(data[1].u8.xy,   3);
    data[invocation].u8.xyz = subgroupBroadcast(data[2].u8.xyz,  3);
    data[invocation].u8     = subgroupBroadcast(data[3].u8,      3);
    data[invocation].u8.x   = subgroupBroadcastFirst(data[0].u8.x);
    data[invocation].u8.xy  = subgroupBroadcastFirst(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupBroadcastFirst(data[2].u8.xyz);
    data[invocation].u8     = subgroupBroadcastFirst(data[3].u8);

    data[invocation].i16.x   = subgroupBroadcast(data[0].i16.x,    3);
    data[invocation].i16.xy  = subgroupBroadcast(data[1].i16.xy,   3);
    data[invocation].i16.xyz = subgroupBroadcast(data[2].i16.xyz,  3);
    data[invocation].i16     = subgroupBroadcast(data[3].i16,      3);
    data[invocation].i16.x   = subgroupBroadcastFirst(data[0].i16.x);
    data[invocation].i16.xy  = subgroupBroadcastFirst(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupBroadcastFirst(data[2].i16.xyz);
    data[invocation].i16     = subgroupBroadcastFirst(data[3].i16);

    data[invocation].u16.x   = subgroupBroadcast(data[0].u16.x,    3);
    data[invocation].u16.xy  = subgroupBroadcast(data[1].u16.xy,   3);
    data[invocation].u16.xyz = subgroupBroadcast(data[2].u16.xyz,  3);
    data[invocation].u16     = subgroupBroadcast(data[3].u16,      3);
    data[invocation].u16.x   = subgroupBroadcastFirst(data[0].u16.x);
    data[invocation].u16.xy  = subgroupBroadcastFirst(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupBroadcastFirst(data[2].u16.xyz);
    data[invocation].u16     = subgroupBroadcastFirst(data[3].u16);

    data[invocation].i64.x   = subgroupBroadcast(data[0].i64.x,    3);
    data[invocation].i64.xy  = subgroupBroadcast(data[1].i64.xy,   3);
    data[invocation].i64.xyz = subgroupBroadcast(data[2].i64.xyz,  3);
    data[invocation].i64     = subgroupBroadcast(data[3].i64,      3);
    data[invocation].i64.x   = subgroupBroadcastFirst(data[0].i64.x);
    data[invocation].i64.xy  = subgroupBroadcastFirst(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupBroadcastFirst(data[2].i64.xyz);
    data[invocation].i64     = subgroupBroadcastFirst(data[3].i64);

    data[invocation].u64.x   = subgroupBroadcast(data[0].u64.x,    3);
    data[invocation].u64.xy  = subgroupBroadcast(data[1].u64.xy,   3);
    data[invocation].u64.xyz = subgroupBroadcast(data[2].u64.xyz,  3);
    data[invocation].u64     = subgroupBroadcast(data[3].u64,      3);
    data[invocation].u64.x   = subgroupBroadcastFirst(data[0].u64.x);
    data[invocation].u64.xy  = subgroupBroadcastFirst(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupBroadcastFirst(data[2].u64.xyz);
    data[invocation].u64     = subgroupBroadcastFirst(data[3].u64);

    data[invocation].f16.x   = subgroupBroadcast(data[0].f16.x,    3);
    data[invocation].f16.xy  = subgroupBroadcast(data[1].f16.xy,   3);
    data[invocation].f16.xyz = subgroupBroadcast(data[2].f16.xyz,  3);
    data[invocation].f16     = subgroupBroadcast(data[3].f16,      3);
    data[invocation].f16.x   = subgroupBroadcastFirst(data[0].f16.x);
    data[invocation].f16.xy  = subgroupBroadcastFirst(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupBroadcastFirst(data[2].f16.xyz);
    data[invocation].f16     = subgroupBroadcastFirst(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesClustered.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupClusteredAdd(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredAdd(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredAdd(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredAdd(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMul(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMul(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMul(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMul(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMin(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMin(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMin(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMin(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMax(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMax(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMax(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMax(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredAnd(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredAnd(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredAnd(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredAnd(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredOr(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredOr(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredOr(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredOr(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredXor(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredXor(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredXor(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredXor(data[3].i8, 1);

    data[invocation].u8.x   = subgroupClusteredAdd(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredAdd(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredAdd(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredAdd(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMul(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMul(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMul(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMul(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMin(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMin(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMin(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMin(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMax(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMax(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMax(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMax(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredAnd(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredAnd(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredAnd(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredAnd(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredOr(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredOr(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredOr(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredOr(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredXor(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredXor(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredXor(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredXor(data[3].u8, 1);

    data[invocation].i16.x   = subgroupClusteredAdd(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredAdd(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredAdd(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredAdd(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMul(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMul(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMul(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMul(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMin(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMin(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMin(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMin(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMax(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMax(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMax(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMax(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredAnd(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredAnd(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredAnd(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredAnd(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredOr(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredOr(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredOr(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredOr(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredXor(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredXor(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredXor(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredXor(data[3].i16, 1);

    data[invocation].u16.x   = subgroupClusteredAdd(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredAdd(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredAdd(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredAdd(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMul(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMul(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMul(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMul(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMin(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMin(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMin(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMin(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMax(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMax(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMax(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMax(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredAnd(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredAnd(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredAnd(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredAnd(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredOr(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredOr(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredOr(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredOr(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredXor(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredXor(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredXor(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredXor(data[3].u16, 1);

    data[invocation].i64.x   = subgroupClusteredAdd(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredAdd(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredAdd(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredAdd(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMul(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMul(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMul(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMul(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMin(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMin(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMin(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMin(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMax(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMax(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMax(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMax(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredAnd(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredAnd(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredAnd(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredAnd(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredOr(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredOr(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredOr(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredOr(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredXor(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredXor(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredXor(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredXor(data[3].i64, 1);

    data[invocation].u64.x   = subgroupClusteredAdd(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredAdd(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredAdd(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredAdd(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMul(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMul(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMul(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMul(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMin(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMin(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMin(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMin(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMax(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMax(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMax(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMax(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredAnd(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredAnd(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredAnd(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredAnd(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredOr(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredOr(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredOr(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredOr(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredXor(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredXor(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredXor(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredXor(data[3].u64, 1);

    data[invocation].f16.x   = subgroupClusteredAdd(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredAdd(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredAdd(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredAdd(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMul(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMul(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMul(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMul(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMin(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMin(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMin(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMin(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMax(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMax(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMax(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMax(data[3].f16, 1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesClusteredNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupClusteredAdd(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredAdd(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredAdd(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredAdd(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMul(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMul(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMul(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMul(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMin(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMin(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMin(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMin(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredMax(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredMax(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredMax(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredMax(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredAnd(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredAnd(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredAnd(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredAnd(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredOr(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredOr(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredOr(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredOr(data[3].i8, 1);

    data[invocation].i8.x   = subgroupClusteredXor(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupClusteredXor(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupClusteredXor(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupClusteredXor(data[3].i8, 1);

    data[invocation].u8.x   = subgroupClusteredAdd(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredAdd(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredAdd(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredAdd(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMul(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMul(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMul(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMul(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMin(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMin(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMin(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMin(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredMax(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredMax(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredMax(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredMax(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredAnd(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredAnd(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredAnd(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredAnd(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredOr(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredOr(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredOr(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredOr(data[3].u8, 1);

    data[invocation].u8.x   = subgroupClusteredXor(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupClusteredXor(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupClusteredXor(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupClusteredXor(data[3].u8, 1);

    data[invocation].i16.x   = subgroupClusteredAdd(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredAdd(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredAdd(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredAdd(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMul(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMul(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMul(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMul(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMin(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMin(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMin(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMin(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredMax(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredMax(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredMax(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredMax(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredAnd(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredAnd(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredAnd(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredAnd(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredOr(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredOr(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredOr(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredOr(data[3].i16, 1);

    data[invocation].i16.x   = subgroupClusteredXor(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupClusteredXor(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupClusteredXor(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupClusteredXor(data[3].i16, 1);

    data[invocation].u16.x   = subgroupClusteredAdd(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredAdd(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredAdd(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredAdd(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMul(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMul(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMul(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMul(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMin(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMin(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMin(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMin(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredMax(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredMax(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredMax(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredMax(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredAnd(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredAnd(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredAnd(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredAnd(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredOr(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredOr(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredOr(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredOr(data[3].u16, 1);

    data[invocation].u16.x   = subgroupClusteredXor(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupClusteredXor(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupClusteredXor(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupClusteredXor(data[3].u16, 1);

    data[invocation].i64.x   = subgroupClusteredAdd(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredAdd(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredAdd(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredAdd(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMul(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMul(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMul(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMul(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMin(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMin(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMin(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMin(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredMax(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredMax(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredMax(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredMax(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredAnd(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredAnd(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredAnd(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredAnd(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredOr(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredOr(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredOr(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredOr(data[3].i64, 1);

    data[invocation].i64.x   = subgroupClusteredXor(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupClusteredXor(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupClusteredXor(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupClusteredXor(data[3].i64, 1);

    data[invocation].u64.x   = subgroupClusteredAdd(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredAdd(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredAdd(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredAdd(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMul(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMul(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMul(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMul(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMin(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMin(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMin(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMin(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredMax(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredMax(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredMax(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredMax(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredAnd(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredAnd(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredAnd(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredAnd(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredOr(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredOr(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredOr(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredOr(data[3].u64, 1);

    data[invocation].u64.x   = subgroupClusteredXor(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupClusteredXor(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupClusteredXor(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupClusteredXor(data[3].u64, 1);

    data[invocation].f16.x   = subgroupClusteredAdd(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredAdd(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredAdd(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredAdd(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMul(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMul(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMul(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMul(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMin(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMin(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMin(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMin(data[3].f16, 1);

    data[invocation].f16.x   = subgroupClusteredMax(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupClusteredMax(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupClusteredMax(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupClusteredMax(data[3].f16, 1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesPartitioned.comp]=[
#version 450

#extension GL_NV_shader_subgroup_partitioned: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 ballot;
    ballot = subgroupPartitionNV(data[0].i8.x);
    ballot = subgroupPartitionNV(data[1].i8.xy);
    ballot = subgroupPartitionNV(data[2].i8.xyz);
    ballot = subgroupPartitionNV(data[3].i8);

    ballot = subgroupPartitionNV(data[0].u8.x);
    ballot = subgroupPartitionNV(data[1].u8.xy);
    ballot = subgroupPartitionNV(data[2].u8.xyz);
    ballot = subgroupPartitionNV(data[3].u8);

    ballot = subgroupPartitionNV(data[0].i16.x);
    ballot = subgroupPartitionNV(data[1].i16.xy);
    ballot = subgroupPartitionNV(data[2].i16.xyz);
    ballot = subgroupPartitionNV(data[3].i16);

    ballot = subgroupPartitionNV(data[0].u16.x);
    ballot = subgroupPartitionNV(data[1].u16.xy);
    ballot = subgroupPartitionNV(data[2].u16.xyz);
    ballot = subgroupPartitionNV(data[3].u16);

    ballot = subgroupPartitionNV(data[0].i64.x);
    ballot = subgroupPartitionNV(data[1].i64.xy);
    ballot = subgroupPartitionNV(data[2].i64.xyz);
    ballot = subgroupPartitionNV(data[3].i64);

    ballot = subgroupPartitionNV(data[0].u64.x);
    ballot = subgroupPartitionNV(data[1].u64.xy);
    ballot = subgroupPartitionNV(data[2].u64.xyz);
    ballot = subgroupPartitionNV(data[3].u64);

    ballot = subgroupPartitionNV(data[0].f16.x);
    ballot = subgroupPartitionNV(data[1].f16.xy);
    ballot = subgroupPartitionNV(data[2].f16.xyz);
    ballot = subgroupPartitionNV(data[3].f16);

    data[invocation].i8.x   = subgroupPartitionedAddNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedAddNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedAddNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedAddNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMulNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMulNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMulNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMulNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMinNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMinNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMinNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMinNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMaxNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMaxNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMaxNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMaxNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedAndNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedAndNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedAndNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedAndNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedOrNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedOrNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedOrNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedOrNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedXorNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedXorNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedXorNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedXorNV(data[3].i8, ballot);

    data[invocation].u8.x   = subgroupPartitionedAddNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedAddNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedAddNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedAddNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMulNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMulNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMulNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMulNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMinNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMinNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMinNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMinNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMaxNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMaxNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMaxNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMaxNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedAndNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedAndNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedAndNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedAndNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedOrNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedOrNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedOrNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedOrNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedXorNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedXorNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedXorNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedXorNV(data[3].u8, ballot);

    data[invocation].i16.x   = subgroupPartitionedAddNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedAddNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedAddNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedAddNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMulNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMulNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMulNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMulNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMinNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMinNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMinNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMinNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMaxNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMaxNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMaxNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMaxNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedAndNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedAndNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedAndNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedAndNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedOrNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedOrNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedOrNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedOrNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedXorNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedXorNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedXorNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedXorNV(data[3].i16, ballot);

    data[invocation].u16.x   = subgroupPartitionedAddNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedAddNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedAddNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedAddNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMulNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMulNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMulNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMulNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMinNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMinNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMinNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMinNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMaxNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMaxNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMaxNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMaxNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedAndNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedAndNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedAndNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedAndNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedOrNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedOrNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedOrNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedOrNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedXorNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedXorNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedXorNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedXorNV(data[3].u16, ballot);

    data[invocation].i64.x   = subgroupPartitionedAddNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedAddNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedAddNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedAddNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMulNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMulNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMulNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMulNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMinNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMinNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMinNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMinNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMaxNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMaxNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMaxNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMaxNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedAndNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedAndNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedAndNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedAndNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedOrNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedOrNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedOrNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedOrNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedXorNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedXorNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedXorNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedXorNV(data[3].i64, ballot);

    data[invocation].u64.x   = subgroupPartitionedAddNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedAddNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedAddNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedAddNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMulNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMulNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMulNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMulNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMinNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMinNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMinNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMinNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMaxNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMaxNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMaxNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMaxNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedAndNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedAndNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedAndNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedAndNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedOrNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedOrNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedOrNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedOrNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedXorNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedXorNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedXorNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedXorNV(data[3].u64, ballot);

    data[invocation].f16.x   = subgroupPartitionedAddNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedAddNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedAddNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedAddNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMulNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMulNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMulNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMulNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMinNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMinNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMinNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMinNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMaxNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMaxNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMaxNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMaxNV(data[3].f16, ballot);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesPartitionedNeg.comp]=[
#version 450

#extension GL_NV_shader_subgroup_partitioned: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 ballot;
    ballot = subgroupPartitionNV(data[0].i8.x);
    ballot = subgroupPartitionNV(data[1].i8.xy);
    ballot = subgroupPartitionNV(data[2].i8.xyz);
    ballot = subgroupPartitionNV(data[3].i8);

    ballot = subgroupPartitionNV(data[0].u8.x);
    ballot = subgroupPartitionNV(data[1].u8.xy);
    ballot = subgroupPartitionNV(data[2].u8.xyz);
    ballot = subgroupPartitionNV(data[3].u8);

    ballot = subgroupPartitionNV(data[0].i16.x);
    ballot = subgroupPartitionNV(data[1].i16.xy);
    ballot = subgroupPartitionNV(data[2].i16.xyz);
    ballot = subgroupPartitionNV(data[3].i16);

    ballot = subgroupPartitionNV(data[0].u16.x);
    ballot = subgroupPartitionNV(data[1].u16.xy);
    ballot = subgroupPartitionNV(data[2].u16.xyz);
    ballot = subgroupPartitionNV(data[3].u16);

    ballot = subgroupPartitionNV(data[0].i64.x);
    ballot = subgroupPartitionNV(data[1].i64.xy);
    ballot = subgroupPartitionNV(data[2].i64.xyz);
    ballot = subgroupPartitionNV(data[3].i64);

    ballot = subgroupPartitionNV(data[0].u64.x);
    ballot = subgroupPartitionNV(data[1].u64.xy);
    ballot = subgroupPartitionNV(data[2].u64.xyz);
    ballot = subgroupPartitionNV(data[3].u64);

    ballot = subgroupPartitionNV(data[0].f16.x);
    ballot = subgroupPartitionNV(data[1].f16.xy);
    ballot = subgroupPartitionNV(data[2].f16.xyz);
    ballot = subgroupPartitionNV(data[3].f16);

    data[invocation].i8.x   = subgroupPartitionedAddNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedAddNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedAddNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedAddNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMulNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMulNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMulNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMulNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMinNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMinNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMinNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMinNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedMaxNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedMaxNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedMaxNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedMaxNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedAndNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedAndNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedAndNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedAndNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedOrNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedOrNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedOrNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedOrNV(data[3].i8, ballot);

    data[invocation].i8.x   = subgroupPartitionedXorNV(data[0].i8.x, ballot);
    data[invocation].i8.xy  = subgroupPartitionedXorNV(data[1].i8.xy, ballot);
    data[invocation].i8.xyz = subgroupPartitionedXorNV(data[2].i8.xyz, ballot);
    data[invocation].i8     = subgroupPartitionedXorNV(data[3].i8, ballot);

    data[invocation].u8.x   = subgroupPartitionedAddNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedAddNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedAddNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedAddNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMulNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMulNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMulNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMulNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMinNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMinNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMinNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMinNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedMaxNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedMaxNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedMaxNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedMaxNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedAndNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedAndNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedAndNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedAndNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedOrNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedOrNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedOrNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedOrNV(data[3].u8, ballot);

    data[invocation].u8.x   = subgroupPartitionedXorNV(data[0].u8.x, ballot);
    data[invocation].u8.xy  = subgroupPartitionedXorNV(data[1].u8.xy, ballot);
    data[invocation].u8.xyz = subgroupPartitionedXorNV(data[2].u8.xyz, ballot);
    data[invocation].u8     = subgroupPartitionedXorNV(data[3].u8, ballot);

    data[invocation].i16.x   = subgroupPartitionedAddNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedAddNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedAddNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedAddNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMulNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMulNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMulNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMulNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMinNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMinNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMinNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMinNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedMaxNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedMaxNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedMaxNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedMaxNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedAndNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedAndNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedAndNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedAndNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedOrNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedOrNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedOrNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedOrNV(data[3].i16, ballot);

    data[invocation].i16.x   = subgroupPartitionedXorNV(data[0].i16.x, ballot);
    data[invocation].i16.xy  = subgroupPartitionedXorNV(data[1].i16.xy, ballot);
    data[invocation].i16.xyz = subgroupPartitionedXorNV(data[2].i16.xyz, ballot);
    data[invocation].i16     = subgroupPartitionedXorNV(data[3].i16, ballot);

    data[invocation].u16.x   = subgroupPartitionedAddNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedAddNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedAddNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedAddNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMulNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMulNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMulNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMulNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMinNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMinNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMinNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMinNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedMaxNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedMaxNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedMaxNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedMaxNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedAndNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedAndNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedAndNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedAndNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedOrNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedOrNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedOrNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedOrNV(data[3].u16, ballot);

    data[invocation].u16.x   = subgroupPartitionedXorNV(data[0].u16.x, ballot);
    data[invocation].u16.xy  = subgroupPartitionedXorNV(data[1].u16.xy, ballot);
    data[invocation].u16.xyz = subgroupPartitionedXorNV(data[2].u16.xyz, ballot);
    data[invocation].u16     = subgroupPartitionedXorNV(data[3].u16, ballot);

    data[invocation].i64.x   = subgroupPartitionedAddNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedAddNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedAddNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedAddNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMulNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMulNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMulNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMulNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMinNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMinNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMinNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMinNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedMaxNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedMaxNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedMaxNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedMaxNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedAndNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedAndNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedAndNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedAndNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedOrNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedOrNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedOrNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedOrNV(data[3].i64, ballot);

    data[invocation].i64.x   = subgroupPartitionedXorNV(data[0].i64.x, ballot);
    data[invocation].i64.xy  = subgroupPartitionedXorNV(data[1].i64.xy, ballot);
    data[invocation].i64.xyz = subgroupPartitionedXorNV(data[2].i64.xyz, ballot);
    data[invocation].i64     = subgroupPartitionedXorNV(data[3].i64, ballot);

    data[invocation].u64.x   = subgroupPartitionedAddNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedAddNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedAddNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedAddNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMulNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMulNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMulNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMulNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMinNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMinNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMinNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMinNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedMaxNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedMaxNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedMaxNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedMaxNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedAndNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedAndNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedAndNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedAndNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedOrNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedOrNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedOrNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedOrNV(data[3].u64, ballot);

    data[invocation].u64.x   = subgroupPartitionedXorNV(data[0].u64.x, ballot);
    data[invocation].u64.xy  = subgroupPartitionedXorNV(data[1].u64.xy, ballot);
    data[invocation].u64.xyz = subgroupPartitionedXorNV(data[2].u64.xyz, ballot);
    data[invocation].u64     = subgroupPartitionedXorNV(data[3].u64, ballot);

    data[invocation].f16.x   = subgroupPartitionedAddNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedAddNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedAddNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedAddNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMulNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMulNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMulNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMulNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMinNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMinNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMinNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMinNV(data[3].f16, ballot);

    data[invocation].f16.x   = subgroupPartitionedMaxNV(data[0].f16.x, ballot);
    data[invocation].f16.xy  = subgroupPartitionedMaxNV(data[1].f16.xy, ballot);
    data[invocation].f16.xyz = subgroupPartitionedMaxNV(data[2].f16.xyz, ballot);
    data[invocation].f16     = subgroupPartitionedMaxNV(data[3].f16, ballot);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesQuad.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_quad: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupQuadBroadcast(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupQuadBroadcast(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupQuadBroadcast(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupQuadBroadcast(data[3].i8, 1);

    data[invocation].i8.x   = subgroupQuadSwapHorizontal(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapHorizontal(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapHorizontal(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapHorizontal(data[3].i8);

    data[invocation].i8.x   = subgroupQuadSwapVertical(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapVertical(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapVertical(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapVertical(data[3].i8);

    data[invocation].i8.x   = subgroupQuadSwapDiagonal(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapDiagonal(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapDiagonal(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapDiagonal(data[3].i8);

    data[invocation].u8.x   = subgroupQuadBroadcast(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupQuadBroadcast(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupQuadBroadcast(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupQuadBroadcast(data[3].u8, 1);

    data[invocation].u8.x   = subgroupQuadSwapHorizontal(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapHorizontal(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapHorizontal(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapHorizontal(data[3].u8);

    data[invocation].u8.x   = subgroupQuadSwapVertical(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapVertical(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapVertical(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapVertical(data[3].u8);

    data[invocation].u8.x   = subgroupQuadSwapDiagonal(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapDiagonal(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapDiagonal(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapDiagonal(data[3].u8);

    data[invocation].i16.x   = subgroupQuadBroadcast(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupQuadBroadcast(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupQuadBroadcast(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupQuadBroadcast(data[3].i16, 1);

    data[invocation].i16.x   = subgroupQuadSwapHorizontal(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapHorizontal(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapHorizontal(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapHorizontal(data[3].i16);

    data[invocation].i16.x   = subgroupQuadSwapVertical(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapVertical(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapVertical(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapVertical(data[3].i16);

    data[invocation].i16.x   = subgroupQuadSwapDiagonal(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapDiagonal(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapDiagonal(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapDiagonal(data[3].i16);

    data[invocation].u16.x   = subgroupQuadBroadcast(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupQuadBroadcast(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupQuadBroadcast(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupQuadBroadcast(data[3].u16, 1);

    data[invocation].u16.x   = subgroupQuadSwapHorizontal(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapHorizontal(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapHorizontal(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapHorizontal(data[3].u16);

    data[invocation].u16.x   = subgroupQuadSwapVertical(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapVertical(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapVertical(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapVertical(data[3].u16);

    data[invocation].u16.x   = subgroupQuadSwapDiagonal(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapDiagonal(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapDiagonal(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapDiagonal(data[3].u16);

    data[invocation].i64.x   = subgroupQuadBroadcast(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupQuadBroadcast(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupQuadBroadcast(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupQuadBroadcast(data[3].i64, 1);

    data[invocation].i64.x   = subgroupQuadSwapHorizontal(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapHorizontal(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapHorizontal(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapHorizontal(data[3].i64);

    data[invocation].i64.x   = subgroupQuadSwapVertical(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapVertical(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapVertical(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapVertical(data[3].i64);

    data[invocation].i64.x   = subgroupQuadSwapDiagonal(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapDiagonal(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapDiagonal(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapDiagonal(data[3].i64);

    data[invocation].u64.x   = subgroupQuadBroadcast(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupQuadBroadcast(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupQuadBroadcast(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupQuadBroadcast(data[3].u64, 1);

    data[invocation].u64.x   = subgroupQuadSwapHorizontal(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapHorizontal(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapHorizontal(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapHorizontal(data[3].u64);

    data[invocation].u64.x   = subgroupQuadSwapVertical(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapVertical(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapVertical(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapVertical(data[3].u64);

    data[invocation].u64.x   = subgroupQuadSwapDiagonal(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapDiagonal(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapDiagonal(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapDiagonal(data[3].u64);

    data[invocation].f16.x   = subgroupQuadBroadcast(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupQuadBroadcast(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupQuadBroadcast(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupQuadBroadcast(data[3].f16, 1);

    data[invocation].f16.x   = subgroupQuadSwapHorizontal(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapHorizontal(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapHorizontal(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapHorizontal(data[3].f16);

    data[invocation].f16.x   = subgroupQuadSwapVertical(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapVertical(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapVertical(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapVertical(data[3].f16);

    data[invocation].f16.x   = subgroupQuadSwapDiagonal(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapDiagonal(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapDiagonal(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapDiagonal(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesQuadNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_quad: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupQuadBroadcast(data[0].i8.x, 1);
    data[invocation].i8.xy  = subgroupQuadBroadcast(data[1].i8.xy, 1);
    data[invocation].i8.xyz = subgroupQuadBroadcast(data[2].i8.xyz, 1);
    data[invocation].i8     = subgroupQuadBroadcast(data[3].i8, 1);

    data[invocation].i8.x   = subgroupQuadSwapHorizontal(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapHorizontal(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapHorizontal(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapHorizontal(data[3].i8);

    data[invocation].i8.x   = subgroupQuadSwapVertical(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapVertical(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapVertical(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapVertical(data[3].i8);

    data[invocation].i8.x   = subgroupQuadSwapDiagonal(data[0].i8.x);
    data[invocation].i8.xy  = subgroupQuadSwapDiagonal(data[1].i8.xy);
    data[invocation].i8.xyz = subgroupQuadSwapDiagonal(data[2].i8.xyz);
    data[invocation].i8     = subgroupQuadSwapDiagonal(data[3].i8);

    data[invocation].u8.x   = subgroupQuadBroadcast(data[0].u8.x, 1);
    data[invocation].u8.xy  = subgroupQuadBroadcast(data[1].u8.xy, 1);
    data[invocation].u8.xyz = subgroupQuadBroadcast(data[2].u8.xyz, 1);
    data[invocation].u8     = subgroupQuadBroadcast(data[3].u8, 1);

    data[invocation].u8.x   = subgroupQuadSwapHorizontal(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapHorizontal(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapHorizontal(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapHorizontal(data[3].u8);

    data[invocation].u8.x   = subgroupQuadSwapVertical(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapVertical(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapVertical(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapVertical(data[3].u8);

    data[invocation].u8.x   = subgroupQuadSwapDiagonal(data[0].u8.x);
    data[invocation].u8.xy  = subgroupQuadSwapDiagonal(data[1].u8.xy);
    data[invocation].u8.xyz = subgroupQuadSwapDiagonal(data[2].u8.xyz);
    data[invocation].u8     = subgroupQuadSwapDiagonal(data[3].u8);

    data[invocation].i16.x   = subgroupQuadBroadcast(data[0].i16.x, 1);
    data[invocation].i16.xy  = subgroupQuadBroadcast(data[1].i16.xy, 1);
    data[invocation].i16.xyz = subgroupQuadBroadcast(data[2].i16.xyz, 1);
    data[invocation].i16     = subgroupQuadBroadcast(data[3].i16, 1);

    data[invocation].i16.x   = subgroupQuadSwapHorizontal(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapHorizontal(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapHorizontal(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapHorizontal(data[3].i16);

    data[invocation].i16.x   = subgroupQuadSwapVertical(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapVertical(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapVertical(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapVertical(data[3].i16);

    data[invocation].i16.x   = subgroupQuadSwapDiagonal(data[0].i16.x);
    data[invocation].i16.xy  = subgroupQuadSwapDiagonal(data[1].i16.xy);
    data[invocation].i16.xyz = subgroupQuadSwapDiagonal(data[2].i16.xyz);
    data[invocation].i16     = subgroupQuadSwapDiagonal(data[3].i16);

    data[invocation].u16.x   = subgroupQuadBroadcast(data[0].u16.x, 1);
    data[invocation].u16.xy  = subgroupQuadBroadcast(data[1].u16.xy, 1);
    data[invocation].u16.xyz = subgroupQuadBroadcast(data[2].u16.xyz, 1);
    data[invocation].u16     = subgroupQuadBroadcast(data[3].u16, 1);

    data[invocation].u16.x   = subgroupQuadSwapHorizontal(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapHorizontal(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapHorizontal(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapHorizontal(data[3].u16);

    data[invocation].u16.x   = subgroupQuadSwapVertical(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapVertical(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapVertical(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapVertical(data[3].u16);

    data[invocation].u16.x   = subgroupQuadSwapDiagonal(data[0].u16.x);
    data[invocation].u16.xy  = subgroupQuadSwapDiagonal(data[1].u16.xy);
    data[invocation].u16.xyz = subgroupQuadSwapDiagonal(data[2].u16.xyz);
    data[invocation].u16     = subgroupQuadSwapDiagonal(data[3].u16);

    data[invocation].i64.x   = subgroupQuadBroadcast(data[0].i64.x, 1);
    data[invocation].i64.xy  = subgroupQuadBroadcast(data[1].i64.xy, 1);
    data[invocation].i64.xyz = subgroupQuadBroadcast(data[2].i64.xyz, 1);
    data[invocation].i64     = subgroupQuadBroadcast(data[3].i64, 1);

    data[invocation].i64.x   = subgroupQuadSwapHorizontal(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapHorizontal(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapHorizontal(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapHorizontal(data[3].i64);

    data[invocation].i64.x   = subgroupQuadSwapVertical(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapVertical(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapVertical(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapVertical(data[3].i64);

    data[invocation].i64.x   = subgroupQuadSwapDiagonal(data[0].i64.x);
    data[invocation].i64.xy  = subgroupQuadSwapDiagonal(data[1].i64.xy);
    data[invocation].i64.xyz = subgroupQuadSwapDiagonal(data[2].i64.xyz);
    data[invocation].i64     = subgroupQuadSwapDiagonal(data[3].i64);

    data[invocation].u64.x   = subgroupQuadBroadcast(data[0].u64.x, 1);
    data[invocation].u64.xy  = subgroupQuadBroadcast(data[1].u64.xy, 1);
    data[invocation].u64.xyz = subgroupQuadBroadcast(data[2].u64.xyz, 1);
    data[invocation].u64     = subgroupQuadBroadcast(data[3].u64, 1);

    data[invocation].u64.x   = subgroupQuadSwapHorizontal(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapHorizontal(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapHorizontal(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapHorizontal(data[3].u64);

    data[invocation].u64.x   = subgroupQuadSwapVertical(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapVertical(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapVertical(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapVertical(data[3].u64);

    data[invocation].u64.x   = subgroupQuadSwapDiagonal(data[0].u64.x);
    data[invocation].u64.xy  = subgroupQuadSwapDiagonal(data[1].u64.xy);
    data[invocation].u64.xyz = subgroupQuadSwapDiagonal(data[2].u64.xyz);
    data[invocation].u64     = subgroupQuadSwapDiagonal(data[3].u64);

    data[invocation].f16.x   = subgroupQuadBroadcast(data[0].f16.x, 1);
    data[invocation].f16.xy  = subgroupQuadBroadcast(data[1].f16.xy, 1);
    data[invocation].f16.xyz = subgroupQuadBroadcast(data[2].f16.xyz, 1);
    data[invocation].f16     = subgroupQuadBroadcast(data[3].f16, 1);

    data[invocation].f16.x   = subgroupQuadSwapHorizontal(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapHorizontal(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapHorizontal(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapHorizontal(data[3].f16);

    data[invocation].f16.x   = subgroupQuadSwapVertical(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapVertical(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapVertical(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapVertical(data[3].f16);

    data[invocation].f16.x   = subgroupQuadSwapDiagonal(data[0].f16.x);
    data[invocation].f16.xy  = subgroupQuadSwapDiagonal(data[1].f16.xy);
    data[invocation].f16.xyz = subgroupQuadSwapDiagonal(data[2].f16.xyz);
    data[invocation].f16     = subgroupQuadSwapDiagonal(data[3].f16);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesShuffle.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupShuffle(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffle(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffle(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffle(data[3].i8,      invocation);

    data[invocation].i8.x   = subgroupShuffleXor(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleXor(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleXor(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleXor(data[3].i8,      invocation);

    data[invocation].u8.x   = subgroupShuffle(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffle(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffle(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffle(data[3].u8,      invocation);

    data[invocation].u8.x   = subgroupShuffleXor(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleXor(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleXor(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleXor(data[3].u8,      invocation);

    data[invocation].i16.x   = subgroupShuffle(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffle(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffle(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffle(data[3].i16,      invocation);

    data[invocation].i16.x   = subgroupShuffleXor(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleXor(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleXor(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleXor(data[3].i16,      invocation);

    data[invocation].u16.x   = subgroupShuffle(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffle(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffle(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffle(data[3].u16,      invocation);

    data[invocation].u16.x   = subgroupShuffleXor(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleXor(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleXor(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleXor(data[3].u16,      invocation);

    data[invocation].i64.x   = subgroupShuffle(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffle(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffle(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffle(data[3].i64,      invocation);

    data[invocation].i64.x   = subgroupShuffleXor(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleXor(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleXor(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleXor(data[3].i64,      invocation);

    data[invocation].u64.x   = subgroupShuffle(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffle(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffle(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffle(data[3].u64,      invocation);

    data[invocation].u64.x   = subgroupShuffleXor(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleXor(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleXor(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleXor(data[3].u64,      invocation);

    data[invocation].f16.x   = subgroupShuffle(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffle(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffle(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffle(data[3].f16,      invocation);

    data[invocation].f16.x   = subgroupShuffleXor(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleXor(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleXor(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleXor(data[3].f16,      invocation);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesShuffleNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupShuffle(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffle(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffle(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffle(data[3].i8,      invocation);

    data[invocation].i8.x   = subgroupShuffleXor(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleXor(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleXor(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleXor(data[3].i8,      invocation);

    data[invocation].u8.x   = subgroupShuffle(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffle(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffle(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffle(data[3].u8,      invocation);

    data[invocation].u8.x   = subgroupShuffleXor(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleXor(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleXor(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleXor(data[3].u8,      invocation);

    data[invocation].i16.x   = subgroupShuffle(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffle(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffle(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffle(data[3].i16,      invocation);

    data[invocation].i16.x   = subgroupShuffleXor(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleXor(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleXor(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleXor(data[3].i16,      invocation);

    data[invocation].u16.x   = subgroupShuffle(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffle(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffle(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffle(data[3].u16,      invocation);

    data[invocation].u16.x   = subgroupShuffleXor(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleXor(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleXor(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleXor(data[3].u16,      invocation);

    data[invocation].i64.x   = subgroupShuffle(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffle(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffle(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffle(data[3].i64,      invocation);

    data[invocation].i64.x   = subgroupShuffleXor(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleXor(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleXor(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleXor(data[3].i64,      invocation);

    data[invocation].u64.x   = subgroupShuffle(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffle(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffle(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffle(data[3].u64,      invocation);

    data[invocation].u64.x   = subgroupShuffleXor(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleXor(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleXor(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleXor(data[3].u64,      invocation);

    data[invocation].f16.x   = subgroupShuffle(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffle(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffle(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffle(data[3].f16,      invocation);

    data[invocation].f16.x   = subgroupShuffleXor(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleXor(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleXor(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleXor(data[3].f16,      invocation);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesShuffleRelative.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle_relative: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupShuffleUp(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleUp(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleUp(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleUp(data[3].i8,      invocation);

    data[invocation].i8.x   = subgroupShuffleDown(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleDown(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleDown(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleDown(data[3].i8,      invocation);

    data[invocation].u8.x   = subgroupShuffleUp(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleUp(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleUp(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleUp(data[3].u8,      invocation);

    data[invocation].u8.x   = subgroupShuffleDown(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleDown(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleDown(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleDown(data[3].u8,      invocation);

    data[invocation].i16.x   = subgroupShuffleUp(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleUp(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleUp(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleUp(data[3].i16,      invocation);

    data[invocation].i16.x   = subgroupShuffleDown(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleDown(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleDown(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleDown(data[3].i16,      invocation);

    data[invocation].u16.x   = subgroupShuffleUp(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleUp(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleUp(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleUp(data[3].u16,      invocation);

    data[invocation].u16.x   = subgroupShuffleDown(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleDown(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleDown(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleDown(data[3].u16,      invocation);

    data[invocation].i64.x   = subgroupShuffleUp(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleUp(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleUp(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleUp(data[3].i64,      invocation);

    data[invocation].i64.x   = subgroupShuffleDown(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleDown(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleDown(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleDown(data[3].i64,      invocation);

    data[invocation].u64.x   = subgroupShuffleUp(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleUp(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleUp(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleUp(data[3].u64,      invocation);

    data[invocation].u64.x   = subgroupShuffleDown(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleDown(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleDown(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleDown(data[3].u64,      invocation);

    data[invocation].f16.x   = subgroupShuffleUp(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleUp(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleUp(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleUp(data[3].f16,      invocation);

    data[invocation].f16.x   = subgroupShuffleDown(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleDown(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleDown(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleDown(data[3].f16,      invocation);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesShuffleRelativeNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle_relative: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].i8.x   = subgroupShuffleUp(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleUp(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleUp(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleUp(data[3].i8,      invocation);

    data[invocation].i8.x   = subgroupShuffleDown(data[0].i8.x,    invocation);
    data[invocation].i8.xy  = subgroupShuffleDown(data[1].i8.xy,   invocation);
    data[invocation].i8.xyz = subgroupShuffleDown(data[2].i8.xyz,  invocation);
    data[invocation].i8     = subgroupShuffleDown(data[3].i8,      invocation);

    data[invocation].u8.x   = subgroupShuffleUp(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleUp(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleUp(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleUp(data[3].u8,      invocation);

    data[invocation].u8.x   = subgroupShuffleDown(data[0].u8.x,    invocation);
    data[invocation].u8.xy  = subgroupShuffleDown(data[1].u8.xy,   invocation);
    data[invocation].u8.xyz = subgroupShuffleDown(data[2].u8.xyz,  invocation);
    data[invocation].u8     = subgroupShuffleDown(data[3].u8,      invocation);

    data[invocation].i16.x   = subgroupShuffleUp(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleUp(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleUp(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleUp(data[3].i16,      invocation);

    data[invocation].i16.x   = subgroupShuffleDown(data[0].i16.x,    invocation);
    data[invocation].i16.xy  = subgroupShuffleDown(data[1].i16.xy,   invocation);
    data[invocation].i16.xyz = subgroupShuffleDown(data[2].i16.xyz,  invocation);
    data[invocation].i16     = subgroupShuffleDown(data[3].i16,      invocation);

    data[invocation].u16.x   = subgroupShuffleUp(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleUp(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleUp(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleUp(data[3].u16,      invocation);

    data[invocation].u16.x   = subgroupShuffleDown(data[0].u16.x,    invocation);
    data[invocation].u16.xy  = subgroupShuffleDown(data[1].u16.xy,   invocation);
    data[invocation].u16.xyz = subgroupShuffleDown(data[2].u16.xyz,  invocation);
    data[invocation].u16     = subgroupShuffleDown(data[3].u16,      invocation);

    data[invocation].i64.x   = subgroupShuffleUp(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleUp(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleUp(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleUp(data[3].i64,      invocation);

    data[invocation].i64.x   = subgroupShuffleDown(data[0].i64.x,    invocation);
    data[invocation].i64.xy  = subgroupShuffleDown(data[1].i64.xy,   invocation);
    data[invocation].i64.xyz = subgroupShuffleDown(data[2].i64.xyz,  invocation);
    data[invocation].i64     = subgroupShuffleDown(data[3].i64,      invocation);

    data[invocation].u64.x   = subgroupShuffleUp(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleUp(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleUp(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleUp(data[3].u64,      invocation);

    data[invocation].u64.x   = subgroupShuffleDown(data[0].u64.x,    invocation);
    data[invocation].u64.xy  = subgroupShuffleDown(data[1].u64.xy,   invocation);
    data[invocation].u64.xyz = subgroupShuffleDown(data[2].u64.xyz,  invocation);
    data[invocation].u64     = subgroupShuffleDown(data[3].u64,      invocation);

    data[invocation].f16.x   = subgroupShuffleUp(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleUp(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleUp(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleUp(data[3].f16,      invocation);

    data[invocation].f16.x   = subgroupShuffleDown(data[0].f16.x,    invocation);
    data[invocation].f16.xy  = subgroupShuffleDown(data[1].f16.xy,   invocation);
    data[invocation].f16.xyz = subgroupShuffleDown(data[2].f16.xyz,  invocation);
    data[invocation].f16     = subgroupShuffleDown(data[3].f16,      invocation);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesVote.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_EXT_shader_subgroup_extended_types_int8: enable
#extension GL_EXT_shader_subgroup_extended_types_int16: enable
#extension GL_EXT_shader_subgroup_extended_types_int64: enable
#extension GL_EXT_shader_subgroup_extended_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
    int r;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    if (subgroupAll(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].i8.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i8.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i8.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i8));

        data[invocation].r = int(subgroupAllEqual(data[0].u8.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u8.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u8.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u8));

        data[invocation].r = int(subgroupAllEqual(data[0].i16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i16));

        data[invocation].r = int(subgroupAllEqual(data[0].u16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u16));
    }
    else if (subgroupAny(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].i64.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i64.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i64.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i64));
        
        data[invocation].r = int(subgroupAllEqual(data[0].u64.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u64.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u64.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u64));
        
        data[invocation].r = int(subgroupAllEqual(data[0].f16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].f16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].f16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].f16));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupExtendedTypesVoteNeg.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    i8vec4 i8;
    u8vec4 u8;
    i16vec4 i16;
    u16vec4 u16;
    i64vec4 i64;
    u64vec4 u64;
    f16vec4 f16;
    int r;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    if (subgroupAll(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].i8.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i8.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i8.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i8));

        data[invocation].r = int(subgroupAllEqual(data[0].u8.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u8.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u8.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u8));

        data[invocation].r = int(subgroupAllEqual(data[0].i16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i16));

        data[invocation].r = int(subgroupAllEqual(data[0].u16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u16));
    }
    else if (subgroupAny(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].i64.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i64.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i64.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i64));
        
        data[invocation].r = int(subgroupAllEqual(data[0].u64.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u64.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u64.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u64));
        
        data[invocation].r = int(subgroupAllEqual(data[0].f16.x));
        data[invocation].r = int(subgroupAllEqual(data[1].f16.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].f16.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].f16));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupPartitioned.comp]=[
#version 450

#extension GL_NV_shader_subgroup_partitioned: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 ballot = subgroupPartitionNV(invocation);

    data[invocation].u4 = subgroupPartitionNV(data[0].f4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4);

    data[invocation].u4 = subgroupPartitionNV(data[0].i4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4);

    data[invocation].u4 = subgroupPartitionNV(data[0].u4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4);

    data[invocation].u4 = subgroupPartitionNV(data[0].d4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4);

    data[invocation].u4 = subgroupPartitionNV(bool(data[0].i4.x));
    data[invocation].u4 = subgroupPartitionNV(bvec2(data[0].i4.xy));
    data[invocation].u4 = subgroupPartitionNV(bvec3(data[0].i4.xyz));
    data[invocation].u4 = subgroupPartitionNV(bvec4(data[0].i4));

    data[invocation].f4.x   = subgroupPartitionedAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedInclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedExclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupQuad.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_quad: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupQuadBroadcast(data[0].f4.x, 1);
    data[invocation].f4.xy  = subgroupQuadBroadcast(data[1].f4.xy, 1);
    data[invocation].f4.xyz = subgroupQuadBroadcast(data[2].f4.xyz, 1);
    data[invocation].f4     = subgroupQuadBroadcast(data[3].f4, 1);

    data[invocation].i4.x   = subgroupQuadBroadcast(data[0].i4.x, 1);
    data[invocation].i4.xy  = subgroupQuadBroadcast(data[1].i4.xy, 1);
    data[invocation].i4.xyz = subgroupQuadBroadcast(data[2].i4.xyz, 1);
    data[invocation].i4     = subgroupQuadBroadcast(data[3].i4, 1);

    data[invocation].u4.x   = subgroupQuadBroadcast(data[0].u4.x, 1);
    data[invocation].u4.xy  = subgroupQuadBroadcast(data[1].u4.xy, 1);
    data[invocation].u4.xyz = subgroupQuadBroadcast(data[2].u4.xyz, 1);
    data[invocation].u4     = subgroupQuadBroadcast(data[3].u4, 1);

    data[invocation].d4.x   = subgroupQuadBroadcast(data[0].d4.x, 1);
    data[invocation].d4.xy  = subgroupQuadBroadcast(data[1].d4.xy, 1);
    data[invocation].d4.xyz = subgroupQuadBroadcast(data[2].d4.xyz, 1);
    data[invocation].d4     = subgroupQuadBroadcast(data[3].d4, 1);

    data[invocation].i4.x   =   int(subgroupQuadBroadcast(data[0].i4.x < 0, 1));
    data[invocation].i4.xy  = ivec2(subgroupQuadBroadcast(lessThan(data[1].i4.xy, ivec2(0)), 1));
    data[invocation].i4.xyz = ivec3(subgroupQuadBroadcast(lessThan(data[1].i4.xyz, ivec3(0)), 1));
    data[invocation].i4     = ivec4(subgroupQuadBroadcast(lessThan(data[1].i4, ivec4(0)), 1));

    data[invocation].f4.x   = subgroupQuadSwapHorizontal(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapHorizontal(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapHorizontal(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapHorizontal(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapHorizontal(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapHorizontal(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapHorizontal(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapHorizontal(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapHorizontal(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapHorizontal(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapHorizontal(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapHorizontal(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapHorizontal(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapHorizontal(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapHorizontal(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapHorizontal(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapHorizontal(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapHorizontal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapHorizontal(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupQuadSwapVertical(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapVertical(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapVertical(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapVertical(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapVertical(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapVertical(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapVertical(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapVertical(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapVertical(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapVertical(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapVertical(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapVertical(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapVertical(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapVertical(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapVertical(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapVertical(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapVertical(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapVertical(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapVertical(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapVertical(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupQuadSwapDiagonal(data[0].f4.x);
    data[invocation].f4.xy  = subgroupQuadSwapDiagonal(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupQuadSwapDiagonal(data[2].f4.xyz);
    data[invocation].f4     = subgroupQuadSwapDiagonal(data[3].f4);

    data[invocation].i4.x   = subgroupQuadSwapDiagonal(data[0].i4.x);
    data[invocation].i4.xy  = subgroupQuadSwapDiagonal(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupQuadSwapDiagonal(data[2].i4.xyz);
    data[invocation].i4     = subgroupQuadSwapDiagonal(data[3].i4);

    data[invocation].u4.x   = subgroupQuadSwapDiagonal(data[0].u4.x);
    data[invocation].u4.xy  = subgroupQuadSwapDiagonal(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupQuadSwapDiagonal(data[2].u4.xyz);
    data[invocation].u4     = subgroupQuadSwapDiagonal(data[3].u4);

    data[invocation].d4.x   = subgroupQuadSwapDiagonal(data[0].d4.x);
    data[invocation].d4.xy  = subgroupQuadSwapDiagonal(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupQuadSwapDiagonal(data[2].d4.xyz);
    data[invocation].d4     = subgroupQuadSwapDiagonal(data[3].d4);

    data[invocation].i4.x   =   int(subgroupQuadSwapDiagonal(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupQuadSwapDiagonal(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupQuadSwapDiagonal(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupShuffle.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupShuffle(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffle(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffle(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffle(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffle(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffle(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffle(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffle(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffle(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffle(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffle(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffle(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffle(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffle(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffle(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffle(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffle(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffle(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffle(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffle(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[invocation].f4.x   = subgroupShuffleXor(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleXor(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleXor(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleXor(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleXor(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleXor(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleXor(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleXor(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleXor(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleXor(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleXor(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleXor(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleXor(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleXor(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleXor(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleXor(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleXor(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleXor(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleXor(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleXor(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupShuffleRelative.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_shuffle_relative: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupShuffleUp(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleUp(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleUp(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleUp(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleUp(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleUp(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleUp(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleUp(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleUp(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleUp(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleUp(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleUp(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleUp(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleUp(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleUp(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleUp(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleUp(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleUp(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleUp(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleUp(lessThan(data[1].i4, ivec4(0)),     invocation));

    data[invocation].f4.x   = subgroupShuffleDown(data[0].f4.x,    invocation);
    data[invocation].f4.xy  = subgroupShuffleDown(data[1].f4.xy,   invocation);
    data[invocation].f4.xyz = subgroupShuffleDown(data[2].f4.xyz,  invocation);
    data[invocation].f4     = subgroupShuffleDown(data[3].f4,      invocation);

    data[invocation].i4.x   = subgroupShuffleDown(data[0].i4.x,    invocation);
    data[invocation].i4.xy  = subgroupShuffleDown(data[1].i4.xy,   invocation);
    data[invocation].i4.xyz = subgroupShuffleDown(data[2].i4.xyz,  invocation);
    data[invocation].i4     = subgroupShuffleDown(data[3].i4,      invocation);

    data[invocation].u4.x   = subgroupShuffleDown(data[0].u4.x,    invocation);
    data[invocation].u4.xy  = subgroupShuffleDown(data[1].u4.xy,   invocation);
    data[invocation].u4.xyz = subgroupShuffleDown(data[2].u4.xyz,  invocation);
    data[invocation].u4     = subgroupShuffleDown(data[3].u4,      invocation);

    data[invocation].d4.x   = subgroupShuffleDown(data[0].d4.x,    invocation);
    data[invocation].d4.xy  = subgroupShuffleDown(data[1].d4.xy,   invocation);
    data[invocation].d4.xyz = subgroupShuffleDown(data[2].d4.xyz,  invocation);
    data[invocation].d4     = subgroupShuffleDown(data[3].d4,      invocation);

    data[invocation].i4.x   =   int(subgroupShuffleDown(data[0].i4.x < 0,                   invocation));
    data[invocation].i4.xy  = ivec2(subgroupShuffleDown(lessThan(data[1].i4.xy, ivec2(0)),  invocation));
    data[invocation].i4.xyz = ivec3(subgroupShuffleDown(lessThan(data[1].i4.xyz, ivec3(0)), invocation));
    data[invocation].i4     = ivec4(subgroupShuffleDown(lessThan(data[1].i4, ivec4(0)),     invocation));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupUniformControlFlow.vert]=[
#version 460

#ifdef GL_EXT_subgroup_uniform_control_flow

#extension GL_EXT_subgroup_uniform_control_flow : enable

[[random(4)]] void main() [[subgroup_uniform_control_flow]]
{
}

#endif

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subgroupVote.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_vote: enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
    int r;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    if (subgroupAll(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].f4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].f4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].f4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].f4));

        data[invocation].r = int(subgroupAllEqual(data[0].i4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].i4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].i4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].i4));

        data[invocation].r = int(subgroupAllEqual(data[0].u4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].u4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].u4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].u4));
    }
    else if (subgroupAny(data[invocation].r < 0))
    {
        data[invocation].r = int(subgroupAllEqual(data[0].d4.x));
        data[invocation].r = int(subgroupAllEqual(data[1].d4.xy));
        data[invocation].r = int(subgroupAllEqual(data[2].d4.xyz));
        data[invocation].r = int(subgroupAllEqual(data[3].d4));

        data[invocation].r = int(int(subgroupAllEqual(data[0].i4.x < 0)));
        data[invocation].r = int(ivec2(subgroupAllEqual(lessThan(data[1].i4.xy, ivec2(0)))));
        data[invocation].r = int(ivec3(subgroupAllEqual(lessThan(data[1].i4.xyz, ivec3(0)))));
        data[invocation].r = int(ivec4(subgroupAllEqual(lessThan(data[1].i4, ivec4(0)))));
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.subpass.frag]=[
#version 400

layout(input_attachment_index = 1) uniform subpassInput sub;
layout(input_attachment_index = 2) uniform subpassInputMS subMS;
layout(input_attachment_index = 3) uniform isubpassInput isub;
layout(input_attachment_index = 4) uniform isubpassInputMS isubMS;
layout(input_attachment_index = 5) uniform usubpassInput usub;
layout(input_attachment_index = 6) uniform usubpassInputMS usubMS;

out vec4 color;
out ivec4 icolor;
out uvec4 ucolor;

void foo(isubpassInputMS sb)
{
    icolor += subpassLoad(sb, 3);
}

void main()
{
    color = subpassLoad(sub);
    color += subpassLoad(subMS, 3);
    icolor = subpassLoad(isub);
    icolor += subpassLoad(isubMS, 3);
    ucolor = subpassLoad(usub);
    ucolor += subpassLoad(usubMS, 3);

    foo(isubMS);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.switch.frag]=[
#version 310 es
precision mediump float;
flat in int c, d;
in float x;
out float color;
in vec4 v;

vec4 foo1(vec4 v1, vec4 v2, int i1)
{
    switch (i1)
    {
    case 0:
        return v1;
    case 2:
    case 1:
        return v2;
    case 3:
        return v1 * v2;
    }

    return vec4(0.0);
}

vec4 foo2(vec4 v1, vec4 v2, int i1)
{
    switch (i1)
    {
    case 0:
        return v1;
    case 2:
        return vec4(1.0);
    case 1:
        return v2;
    case 3:
        return v1 * v2;
    }

    return vec4(0.0);
}

void main()
{
    float f;
    int a[2];
    int local = c;

    switch(++local)
    {
    }

    switch (c) {
    case 1:
        f = sin(x);
        break;
    case 2:
        f = cos(x);
        break;
    default:
        f = tan(x);
    }

    switch (c) {
    case 1:
        f += sin(x);
    case 2:
        f += cos(x);
        break;
    default:
        f += tan(x);
    }

    switch (c) {
    case 1:
        f += sin(x);
        break;
    case 2:
        f += cos(x);
        break;
    }

    switch (c) {
    case 1:
        f += sin(x);
        break;
    case 2:
        switch (d) {
        case 1:
            f += x * x * x;
            break;
        case 2:
            f += x * x;
            break;
        }
        break;
    default:
        f += tan(x);
    }

    for (int i = 0; i < 10; ++i) {
        switch (c) {
        case 1:
            f += sin(x);
            for (int j = 20; j < 30; ++j) {
                ++f;
                if (f < 100.2)
                    break;
            }
            break;
        case 2:
            f += cos(x);
            break;
            break;
        default:
            f += tan(x);
        }

        if (f < 3.43)
            break;
    }

    switch (c) {
    case 1:
        f += sin(x);
        break;
    case 2:
        // test no statements at end
    }

    color = f + float(local);

    color += foo1(v,v,c).y;
    color += foo2(v,v,c).z;

    switch (c) {
    case 0: break;
    default:
    }

    switch (c) {
    default:
    }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.swizzle.frag]=[
#version 140

in float blend;
in vec4 u;
bool p;

in vec2 t;

void main()
{
    float blendscale = 1.789;

    vec4 w = u;
    vec4 w_undef;       // test undef
    vec4 w_dep = u;     // test dependent swizzles
    vec4 w_reorder = u; // test reordering
    vec4 w2 = u;
    vec4 w_flow = u;    // test flowControl

    w_reorder.z = blendscale;

    w.wy = t;

    w_reorder.x = blendscale;

    w2.xyzw = u.zwxy;

    w_reorder.y = blendscale;

    w_dep.xy = w2.xz;
    w_dep.zw = t;

    w_undef.xy = u.zw;

    if (p)
        w_flow.x = t.x;
    else
        w_flow.x = t.y;

    gl_FragColor = mix(w_reorder, w_undef, w * w2 * w_dep * w_flow);

    vec2 c = t;
    vec4 rep = vec4(0.0, 0.0, 0.0, 1.0);

    if (c.x < 0.0)
        c.x *= -1.0;

    if (c.x <= 1.0)
        rep.x = 3.4;

    gl_FragColor += rep;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.swizzleInversion.frag]=[
#version 450

in vec4 in4;
in vec3 in3;

void main()
{
    vec3 v43 = interpolateAtCentroid(in4.wzx);
    vec2 v42 = interpolateAtSample(in4.zx, 1);
    vec4 v44 = interpolateAtOffset(in4.zyxw, vec2(2.0));
    float v41 = interpolateAtOffset(in4.y, vec2(2.0));

    vec3 v33 = interpolateAtCentroid(in3.yzx);
    vec2 v32 = interpolateAtSample(in3.zx, 1);
    float v31 = interpolateAtOffset(in4.y, vec2(2.0));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.targetOpenGL.vert]=[
#version 450

layout(constant_id = 3) const int a = 2;
layout(location = 2) uniform float f;
layout(location = 4, binding = 1) uniform sampler2D s1;
layout(binding = 2) uniform sampler2D s2;

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.targetVulkan.vert]=[
#version 450

layout(constant_id = 3) const int a = 2;

layout(push_constant) uniform pc { float f; };

void main()
{
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.terminate.frag]=[
#version 400

#extension GL_EXT_terminate_invocation : enable

void main()
{
    terminateInvocation;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.test.frag]=[
#version 400

uniform sampler2D texSampler2D;
uniform sampler3D texSampler3D;

in float blend;
in vec2 scale;
in vec4 u;

in vec2 t;
in vec3 coords;

void main()
{  
    float blendscale = 1.789;

    vec4 v = texture(texSampler2D, (t + scale) / scale ).wzyx;

	vec4 w = texture(texSampler3D, coords) + v;
    
    gl_FragColor = mix(w, u, blend * blendscale);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.test.vert]=[
#version 140

in mat4 transform;

attribute vec4 position;
in vec2 uv_in;

out vec2 uv;

void main()
{
    uv = uv_in;
    gl_Position = transform * position;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.texture.frag]=[
#version 140

uniform sampler1D       texSampler1D;
uniform sampler2D       texSampler2D;
uniform sampler3D       texSampler3D;
uniform samplerCube	    texSamplerCube;
uniform sampler1DShadow shadowSampler1D;
uniform sampler2DShadow shadowSampler2D;

varying float blend;
varying vec2 scale;
varying vec4 u;

in  vec2 t;
in  vec2 coords2D;

void main()
{  
    float blendscale = 1.789;
    float bias       = 2.0;
    float lod		 = 3.0;
    float proj       = 2.0;
    float coords1D   = 1.789;
    vec3  coords3D   = vec3(1.789, 2.718, 3.453);
    vec4  coords4D   = vec4(1.789, 2.718, 3.453, 2.0);
    vec4  color      = vec4(0.0, 0.0, 0.0, 0.0);

    color += texture    (texSampler1D, coords1D);
    color += texture    (texSampler1D, coords1D, bias);
    color += textureProj(texSampler1D, coords2D);
    color += textureProj(texSampler1D, coords4D);
    color += textureProj(texSampler1D, coords2D, bias);
    color += textureProj(texSampler1D, coords4D, bias);
    
    color += texture        (texSampler2D, coords2D);
    color += texture        (texSampler2D, coords2D, bias);
    color += textureProj    (texSampler2D, coords3D);
    color += textureProj    (texSampler2D, coords4D, bias);

    color += texture        (texSampler3D, coords3D);
    color += texture        (texSampler3D, coords3D, bias);
    color += textureProj    (texSampler3D, coords4D);
    color += textureProj    (texSampler3D, coords4D, bias);

    color += texture    (texSamplerCube, coords3D);
    color += texture    (texSamplerCube, coords3D, bias);
    
    color += texture       (shadowSampler1D, coords3D);
    color += texture       (shadowSampler1D, coords3D, bias);
    color += texture       (shadowSampler2D, coords3D);
    color += texture       (shadowSampler2D, coords3D, bias);
    color += textureProj   (shadowSampler1D, coords4D);
    color += textureProj   (shadowSampler1D, coords4D, bias);
    color += textureProj   (shadowSampler2D, coords4D);
    color += textureProj   (shadowSampler2D, coords4D, bias);

    ivec2 iCoords2D = ivec2(0, 5);
    int iLod = 1;

    color += texelFetch(texSampler2D, iCoords2D, iLod);

    vec2 gradX = dFdx(coords2D);
    vec2 gradY = dFdy(coords2D);
    const ivec2 offset = ivec2(3, -7);

    color += textureGrad(texSampler2D, coords2D, gradX, gradY);
    color += textureProjGrad(texSampler2D, vec3(coords2D, proj), gradX, gradY);
    color += textureGradOffset(texSampler2D, coords2D, gradX, gradY, offset);
    color += textureProjGradOffset(texSampler2D, coords3D, gradX, gradY, offset);
    color += textureGrad(shadowSampler2D, vec3(coords2D, lod), gradX, gradY);
    
    gl_FragColor = mix(color, u, blend * blendscale);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.texture.sampler.transform.frag]=[
#version 440

uniform sampler smp;
uniform texture2D tex;

in vec2 coord;

out vec4 color;

void main()
{
  color = texture(sampler2D(tex, smp), coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.texture.vert]=[
#version 140

uniform sampler1D       texSampler1D;
uniform sampler2D       texSampler2D;
uniform sampler3D       texSampler3D;
uniform samplerCube	    texSamplerCube;
uniform sampler1DShadow shadowSampler1D;
uniform sampler2DShadow shadowSampler2D;

in vec2 coords2D;

void main()
{  
    float lod		 = 3.0;
    float coords1D   = 1.789;
    vec3  coords3D   = vec3(1.789, 2.718, 3.453);
    vec4  coords4D   = vec4(1.789, 2.718, 3.453, 2.0);
    vec4  color      = vec4(0.0, 0.0, 0.0, 0.0);

    color += textureLod(texSampler1D, coords1D, lod);
    color += textureProjLod(texSampler1D, coords2D, lod);
    color += textureProjLod(texSampler1D, coords4D, lod);
    
    color += textureLod     (texSampler2D, coords2D, lod);
    color += textureProjLod (texSampler2D, coords3D, lod);
    color += textureProjLod (texSampler2D, coords4D, lod);

    color += textureLod     (texSampler3D, coords3D, lod);
    color += textureProjLod (texSampler3D, coords4D, lod);
    
    color += textureLod (texSamplerCube, coords3D, lod);

    color += textureLod    (shadowSampler1D, coords3D, lod);
    color += textureLod    (shadowSampler2D, coords3D, lod);
    color += textureProjLod(shadowSampler1D, coords4D, lod);
    color += textureProjLod(shadowSampler2D, coords4D, lod);

    gl_Position = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.textureBuffer.vert]=[
#version 450

uniform textureBuffer tBuf;
uniform sampler s;
uniform samplerBuffer sBuf;

uniform utextureBuffer utBuf;
uniform itextureBuffer itBuf;

void main()
{
    texelFetch(samplerBuffer(tBuf, s), 13);
    texelFetch(sBuf, 13);
    texelFetch(tBuf, 13);
    texelFetch(utBuf, 13);
    texelFetch(itBuf, 13);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.textureGatherBiasLod.frag]=[
#version 450 core

#extension GL_ARB_sparse_texture2: enable
#extension GL_AMD_texture_gather_bias_lod: enable

uniform sampler2D           s2D;
uniform sampler2DArray      s2DArray;
uniform samplerCube         sCube;
uniform samplerCubeArray    sCubeArray;

in vec2 c2;
in vec3 c3;
in vec4 c4;

in float lod;
in float bias;

out vec4 fragColor;

void main()
{
    vec4 texel  = vec4(0.0);
    vec4 result = vec4(0.0);

    const ivec2 offsets[4] = { ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1) };

    texel += textureGather(s2D,        c2, 0, bias);
    texel += textureGather(s2DArray,   c3, 1, bias);
    texel += textureGather(sCube,      c3, 2, bias);
    texel += textureGather(sCubeArray, c4, 3, bias);

    texel += textureGatherOffset(s2D,        c2, offsets[0], 0, bias);
    texel += textureGatherOffset(s2DArray,   c3, offsets[1], 1, bias);

    texel += textureGatherOffsets(s2D,        c2, offsets, 0, bias);
    texel += textureGatherOffsets(s2DArray,   c3, offsets, 1, bias);

    sparseTextureGatherARB(s2D,        c2, result, 0, bias);
    texel += result;
    sparseTextureGatherARB(s2DArray,   c3, result, 1, bias);
    texel += result;
    sparseTextureGatherARB(sCube,      c3, result, 2, bias);
    texel += result;
    sparseTextureGatherARB(sCubeArray, c4, result, 2, bias);
    texel += result;

    sparseTextureGatherOffsetARB(s2D,      c2, offsets[0], result, 0, bias);
    texel += result;
    sparseTextureGatherOffsetARB(s2DArray, c3, offsets[1], result, 1, bias);
    texel += result;

    sparseTextureGatherOffsetsARB(s2D,      c2, offsets, result, 0, bias);
    texel += result;
    sparseTextureGatherOffsetsARB(s2DArray, c3, offsets, result, 1, bias);
    texel += result;

    texel += textureGatherLodAMD(s2D,        c2, lod);
    texel += textureGatherLodAMD(s2DArray,   c3, lod, 1);
    texel += textureGatherLodAMD(sCube,      c3, lod, 2);
    texel += textureGatherLodAMD(sCubeArray, c4, lod, 3);

    texel += textureGatherLodOffsetAMD(s2D,        c2, lod, offsets[0]);
    texel += textureGatherLodOffsetAMD(s2DArray,   c3, lod, offsets[1], 1);

    texel += textureGatherLodOffsetsAMD(s2D,       c2, lod, offsets);
    texel += textureGatherLodOffsetsAMD(s2DArray,  c3, lod, offsets, 1);

    sparseTextureGatherLodAMD(s2D,        c2, lod, result);
    texel += result;
    sparseTextureGatherLodAMD(s2DArray,   c3, lod, result, 1);
    texel += result;
    sparseTextureGatherLodAMD(sCube,      c3, lod, result, 2);
    texel += result;
    sparseTextureGatherLodAMD(sCubeArray, c4, lod, result, 2);
    texel += result;

    sparseTextureGatherLodOffsetAMD(s2D,      c2, lod, offsets[0], result);
    texel += result;
    sparseTextureGatherLodOffsetAMD(s2DArray, c3, lod, offsets[1], result, 1);
    texel += result;

    sparseTextureGatherLodOffsetsAMD(s2D,      c2, lod, offsets, result);
    texel += result;
    sparseTextureGatherLodOffsetsAMD(s2DArray, c3, lod, offsets, result, 1);
    texel += result;

    fragColor = texel;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.types.frag]=[
#version 140

bool  u_b;
bvec2 u_b2;
bvec3 u_b3;
bvec4 u_b4;
flat in int   u_i;
flat in ivec2 u_i2;
flat in ivec3 u_i3;
flat in ivec4 u_i4;
     in float u_f;
     in vec2 u_f2;
     in vec3 u_f3;
     in vec4 u_f4;
bool  i_b;
bvec2 i_b2;
bvec3 i_b3;
bvec4 i_b4;

flat in int   i_i;
flat in ivec2 i_i2;
flat in ivec3 i_i3;
flat in ivec4 i_i4;

in float i_f;
in vec2 i_f2;
in vec3 i_f3;
in vec4 i_f4;

void main()
{
    bool  b = u_b && i_b;
    bvec2 b2 = bvec2(u_b2.x && i_b2.x && u_b2.y && i_b2.y);
    bvec3 b3 = bvec3(u_b3.x && i_b3.x && u_b3.y && i_b3.y && u_b3.z && i_b3.z);
    bvec4 b4 = bvec4(u_b4.x && i_b4.x && u_b4.y && i_b4.y && u_b4.z && i_b4.z && u_b4.w && i_b4.w);

    int   i = u_i + i_i;
    ivec2 i2 = u_i2 + i_i2;
    ivec3 i3 = u_i3 + i_i3;
    ivec4 i4 = u_i4 + i_i4;

    float f = u_f + i_f;
    vec2  f2 = u_f2 + i_f2;
    vec3  f3 = u_f3 + i_f3;
    vec4  f4 = u_f4 + i_f4;

    gl_FragColor = 
        b || 
        b2.x ||
        b2.y ||
        b3.x ||
        b3.y ||
        b3.z ||
        b4.x ||
        b4.y ||
        b4.z ||
        b4.w ? vec4(
        i  +
        i2.x +
        i2.y +
        i3.x +
        i3.y +
        i3.z +
        i4.x +
        i4.y +
        i4.z +
        i4.w +
        f  +
        f2.x +
        f2.y +
        f3.x +
        f3.y +
        f3.z +
        f4.x +
        f4.y +
        f4.z +
        f4.w) : vec4(1.0);        
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.uint.frag]=[
#version 310 es
precision mediump float;
flat in uvec2 t;
in float f;
in vec2 tc;

flat in uvec4 v;
flat in int i;
bool b;

out uvec4 c;

uniform mediump usampler2D usampler;

void main()
{
    int count = 1;

    uint u = t.y + 3u;
    const uint cu1 = 0xFFFFFFFFU;
    const uint cu2 = -1u;              // 0xFFFFFFFF
    const uint cu3 = 1U;
    const uint cu4 = 1u;

    if (cu1 == cu2)
        count *= 2;  // 2
    if (cu3 == cu4)
        count *= 3;  // 6
    if (cu2 == cu3)
        count *= 5;  // not done

    const  int  cshiftedii      = 0xFFFFFFFF  >> 10;
    const uint cushiftedui      = 0xFFFFFFFFu >> 10;
    const  int  cshiftediu      = 0xFFFFFFFF  >> 10u;
    const uint cushifteduu      = 0xFFFFFFFFu >> 10u;

    if (cshiftedii == cshiftediu)
        count *= 7;  // 42
    if (cushiftedui == cushifteduu)
        count *= 11; // 462
    if (cshiftedii == int(cushiftedui))
        count *= 13; // not done

     int shiftedii      = 0xFFFFFFFF  >> 10;
    uint shiftedui      = 0xFFFFFFFFu >> 10;
     int shiftediu      = 0xFFFFFFFF  >> 10u;
    uint shifteduu      = 0xFFFFFFFFu >> 10u;

    if (shiftedii == shiftediu)
        c = texture(usampler, tc);
    if (shiftedui == shifteduu)
        c = texture(usampler, tc + float(1u));
    if (shiftedii == int(shiftedui))
        c = texture(usampler, tc - vec2(2u));

    if (t.x > 4u) {
        float af = float(u);
        bool ab = bool(u);
        int ai = int(u);

        c += uvec4(uint(af), uint(ab), uint(ai), count);
    }

    const uint cmask1 = 0x0A1u;
    const uint cmask2 = 0xA10u;
    const uint cmask3 = cmask1 << 4;
    const uint cmask4 = 0xAB1u;

    if (cmask3 == cmask2)
        count *= 17;  // 7854

    if ((cmask3 & cmask1) != 0u)
        count *= 19; // not done

    if ((cmask1 | cmask3) == cmask4)
        count *= 23; // 180642

    if ((cmask1 ^ cmask4) == 0xA10u)
        count *= 27; // 4877334

    uint mask1 = 0x0A1u;
    uint mask2 = 0xA10u;
    uint mask3 = mask1 << 4;
    uint mask4 = 0xAB1u;

    if (mask3 == mask2)
        count *= 2;  // 9754668

    if ((mask3 & mask1) != 0u)
        count *= 3;  // not done

    if ((mask1 | mask3) == mask4)
        count *= 5;  // 48773340

    if ((mask1 ^ mask4) == 0xA10u)
        count *= 7;  // 341413380

    c += uvec4(count);

    #define UINT_MAX  4294967295u
    c.x += UINT_MAX;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.uniformInitializer.frag]=[
#version 450

layout (location = 0) out vec4 color;

layout (location = 0) uniform vec4 in_color = vec4(0.0, 1.0, 0.0, 1.0);

void main()
{
	color = in_color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.uniformInitializerSpecConstant.frag]=[
#version 450

layout (location = 0) out vec4 color;

layout (constant_id = 1) const float opacity = 0.5;

layout (location = 0) uniform vec3 in_color = vec3(1.0, 0.5, 0);

layout (location = 4) uniform float foo = opacity;

void main()
{
	color = vec4(in_color, foo);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.uniformInitializerStruct.frag]=[
#version 450

layout (location = 0) out vec4 color;

layout (location = 0) uniform struct {
        float r;
        float g;
        float b;
} parts[2] = { { 1.0, 1.0, 1.0}, { 0.0, 1.0, 0.0 } };

void main() {
  color = vec4(0.0, 0.0, 0.0, 1.0);

  for (int i = 0; i < 2; i++) {
    color.r += parts[i].r;
    color.g += parts[i].g;
    color.b += parts[i].b;
  }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.unit1.frag]=[
#version 460

float f;
float a1;

float foo();

out float cout;

void main()
{
    f = 10;
    float g = foo();
    f += g;
    f += gl_FragCoord.y;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.unit2.frag]=[
#version 410
// a different version number makes different id's for the same shared symbol

float a2;
float f;

float bar();

out float cout;
in float cin;

float foo()
{
    float h2 = 2 * f + cin;
    float g2 = bar();
    return h2 + g2 + gl_FragCoord.y;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.unit3.frag]=[
#version 460

float f;
float h3 = 3.0;

out float cout;
in float cin;

float bar()
{
    h3 *= f;
    float g3 = 2 * h3;
    cout = g3;
    return h3 + g3 + gl_FragCoord.y;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.vecMatConstruct.frag]=[
#version 450

void main()
{
    mat4x3 m;

    vec2 v2 = vec2(m);
    vec3 v3 = vec3(m);
    vec4 v4 = vec4(m);

    ivec2 iv2 = ivec2(m);
    ivec3 iv3 = ivec3(m);
    ivec4 iv4 = ivec4(m);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.viewportindex.tese]=[
#version 450

#extension GL_ARB_shader_viewport_layer_array : require

layout(triangles) in;
void main() {
  gl_ViewportIndex = 1;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.voidFunction.frag]=[
#version 400

in vec4 bigColor;
in vec4 BaseColor;
in float d;

float bar = 2.0;

void foo()
{
    bar++;

	return;
}

void foo2()
{
    bar++;
}

void main()
{
	vec4 outColor = bigColor;

	foo();

	foo2();

	outColor.x += bar;

    gl_FragColor = outColor;

	return;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.volatileAtomic.comp]=[
#version 450 core

layout(set=0, binding=3) volatile buffer D { uint d[]; } d;

void main()
{
    atomicExchange(d.d[0], 0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.vulkan100.subgroupArithmetic.comp]=[
#version 450

#extension GL_KHR_shader_subgroup_arithmetic: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    data[invocation].f4.x   = subgroupAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupAdd(data[3].f4);

    data[invocation].i4.x   = subgroupAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAdd(data[3].i4);

    data[invocation].u4.x   = subgroupAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAdd(data[3].u4);

    data[invocation].d4.x   = subgroupAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupAdd(data[3].d4);

    data[invocation].f4.x   = subgroupMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupMul(data[3].f4);

    data[invocation].i4.x   = subgroupMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupMul(data[3].i4);

    data[invocation].u4.x   = subgroupMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupMul(data[3].u4);

    data[invocation].d4.x   = subgroupMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupMul(data[3].d4);

    data[invocation].f4.x   = subgroupMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupMin(data[3].f4);

    data[invocation].i4.x   = subgroupMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupMin(data[3].i4);

    data[invocation].u4.x   = subgroupMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupMin(data[3].u4);

    data[invocation].d4.x   = subgroupMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupMin(data[3].d4);

    data[invocation].f4.x   = subgroupMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupMax(data[3].f4);

    data[invocation].i4.x   = subgroupMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupMax(data[3].i4);

    data[invocation].u4.x   = subgroupMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupMax(data[3].u4);

    data[invocation].d4.x   = subgroupMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupMax(data[3].d4);

    data[invocation].i4.x   = subgroupAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupAnd(data[3].i4);

    data[invocation].u4.x   = subgroupAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupOr(data[3].i4);

    data[invocation].u4.x   = subgroupOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupXor(data[3].i4);

    data[invocation].u4.x   = subgroupXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupInclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupInclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupInclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupInclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupInclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupInclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupInclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupInclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupInclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupInclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupInclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupInclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupInclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupInclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupInclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupInclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupInclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupInclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupInclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupInclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupInclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupInclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupInclusiveXor(lessThan(data[1].i4, ivec4(0))));

    data[invocation].f4.x   = subgroupExclusiveAdd(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveAdd(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveAdd(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveAdd(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveAdd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAdd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAdd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAdd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAdd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAdd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAdd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAdd(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveAdd(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveAdd(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveAdd(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveAdd(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMul(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMul(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMul(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMul(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMul(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMul(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMul(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMul(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMul(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMul(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMul(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMul(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMul(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMul(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMul(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMul(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMin(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMin(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMin(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMin(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMin(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMin(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMin(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMin(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMin(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMin(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMin(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMin(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMin(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMin(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMin(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMin(data[3].d4);

    data[invocation].f4.x   = subgroupExclusiveMax(data[0].f4.x);
    data[invocation].f4.xy  = subgroupExclusiveMax(data[1].f4.xy);
    data[invocation].f4.xyz = subgroupExclusiveMax(data[2].f4.xyz);
    data[invocation].f4     = subgroupExclusiveMax(data[3].f4);

    data[invocation].i4.x   = subgroupExclusiveMax(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveMax(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveMax(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveMax(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveMax(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveMax(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveMax(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveMax(data[3].u4);

    data[invocation].d4.x   = subgroupExclusiveMax(data[0].d4.x);
    data[invocation].d4.xy  = subgroupExclusiveMax(data[1].d4.xy);
    data[invocation].d4.xyz = subgroupExclusiveMax(data[2].d4.xyz);
    data[invocation].d4     = subgroupExclusiveMax(data[3].d4);

    data[invocation].i4.x   = subgroupExclusiveAnd(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveAnd(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveAnd(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveAnd(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveAnd(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveAnd(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveAnd(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveAnd(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveAnd(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveAnd(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveAnd(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveAnd(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveOr(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveOr(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveOr(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveOr(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveOr(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveOr(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveOr(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveOr(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveOr(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveOr(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveOr(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveOr(lessThan(data[1].i4, ivec4(0))));

    data[invocation].i4.x   = subgroupExclusiveXor(data[0].i4.x);
    data[invocation].i4.xy  = subgroupExclusiveXor(data[1].i4.xy);
    data[invocation].i4.xyz = subgroupExclusiveXor(data[2].i4.xyz);
    data[invocation].i4     = subgroupExclusiveXor(data[3].i4);

    data[invocation].u4.x   = subgroupExclusiveXor(data[0].u4.x);
    data[invocation].u4.xy  = subgroupExclusiveXor(data[1].u4.xy);
    data[invocation].u4.xyz = subgroupExclusiveXor(data[2].u4.xyz);
    data[invocation].u4     = subgroupExclusiveXor(data[3].u4);

    data[invocation].i4.x   =   int(subgroupExclusiveXor(data[0].i4.x < 0));
    data[invocation].i4.xy  = ivec2(subgroupExclusiveXor(lessThan(data[1].i4.xy, ivec2(0))));
    data[invocation].i4.xyz = ivec3(subgroupExclusiveXor(lessThan(data[1].i4.xyz, ivec3(0))));
    data[invocation].i4     = ivec4(subgroupExclusiveXor(lessThan(data[1].i4, ivec4(0))));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.vulkan100.subgroupPartitioned.comp]=[
#version 450

#extension GL_NV_shader_subgroup_partitioned: enable

layout (local_size_x = 8) in;

layout(binding = 0) buffer Buffers
{
    vec4  f4;
    ivec4 i4;
    uvec4 u4;
    dvec4 d4;
} data[4];

void main()
{
    uint invocation = (gl_SubgroupInvocationID + gl_SubgroupSize) % 4;

    uvec4 ballot = subgroupPartitionNV(invocation);

    data[invocation].u4 = subgroupPartitionNV(data[0].f4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].f4);

    data[invocation].u4 = subgroupPartitionNV(data[0].i4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].i4);

    data[invocation].u4 = subgroupPartitionNV(data[0].u4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].u4);

    data[invocation].u4 = subgroupPartitionNV(data[0].d4.x);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xy);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4.xyz);
    data[invocation].u4 = subgroupPartitionNV(data[0].d4);

    data[invocation].u4 = subgroupPartitionNV(bool(data[0].i4.x));
    data[invocation].u4 = subgroupPartitionNV(bvec2(data[0].i4.xy));
    data[invocation].u4 = subgroupPartitionNV(bvec3(data[0].i4.xyz));
    data[invocation].u4 = subgroupPartitionNV(bvec4(data[0].i4));

    data[invocation].f4.x   = subgroupPartitionedAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedInclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedInclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedInclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedInclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedInclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedInclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedInclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedInclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedInclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedInclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedInclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedInclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedInclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedInclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedInclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedInclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedInclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedInclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].f4.x   = subgroupPartitionedExclusiveAddNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveAddNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveAddNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveAddNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAddNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAddNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAddNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAddNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAddNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAddNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAddNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAddNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveAddNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveAddNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveAddNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveAddNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMulNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMulNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMulNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMulNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMulNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMulNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMulNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMulNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMulNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMulNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMulNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMulNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMulNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMulNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMulNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMulNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMinNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMinNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMinNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMinNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMinNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMinNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMinNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMinNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMinNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMinNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMinNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMinNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMinNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMinNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMinNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMinNV(data[3].d4, ballot);

    data[invocation].f4.x   = subgroupPartitionedExclusiveMaxNV(data[0].f4.x, ballot);
    data[invocation].f4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].f4.xy, ballot);
    data[invocation].f4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].f4.xyz, ballot);
    data[invocation].f4     = subgroupPartitionedExclusiveMaxNV(data[3].f4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveMaxNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveMaxNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveMaxNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveMaxNV(data[3].u4, ballot);

    data[invocation].d4.x   = subgroupPartitionedExclusiveMaxNV(data[0].d4.x, ballot);
    data[invocation].d4.xy  = subgroupPartitionedExclusiveMaxNV(data[1].d4.xy, ballot);
    data[invocation].d4.xyz = subgroupPartitionedExclusiveMaxNV(data[2].d4.xyz, ballot);
    data[invocation].d4     = subgroupPartitionedExclusiveMaxNV(data[3].d4, ballot);

    data[invocation].i4.x   = subgroupPartitionedExclusiveAndNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveAndNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveAndNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveAndNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveAndNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveAndNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveAndNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveAndNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveAndNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveAndNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveOrNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveOrNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveOrNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveOrNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveOrNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveOrNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveOrNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveOrNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveOrNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveOrNV(lessThan(data[1].i4, ivec4(0)), ballot));

    data[invocation].i4.x   = subgroupPartitionedExclusiveXorNV(data[0].i4.x, ballot);
    data[invocation].i4.xy  = subgroupPartitionedExclusiveXorNV(data[1].i4.xy, ballot);
    data[invocation].i4.xyz = subgroupPartitionedExclusiveXorNV(data[2].i4.xyz, ballot);
    data[invocation].i4     = subgroupPartitionedExclusiveXorNV(data[3].i4, ballot);

    data[invocation].u4.x   = subgroupPartitionedExclusiveXorNV(data[0].u4.x, ballot);
    data[invocation].u4.xy  = subgroupPartitionedExclusiveXorNV(data[1].u4.xy, ballot);
    data[invocation].u4.xyz = subgroupPartitionedExclusiveXorNV(data[2].u4.xyz, ballot);
    data[invocation].u4     = subgroupPartitionedExclusiveXorNV(data[3].u4, ballot);

    data[invocation].i4.x   =   int(subgroupPartitionedExclusiveXorNV(data[0].i4.x < 0, ballot));
    data[invocation].i4.xy  = ivec2(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xy, ivec2(0)), ballot));
    data[invocation].i4.xyz = ivec3(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4.xyz, ivec3(0)), ballot));
    data[invocation].i4     = ivec4(subgroupPartitionedExclusiveXorNV(lessThan(data[1].i4, ivec4(0)), ballot));
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.vulkan110.int16.frag]=[
#version 450

#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int32: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_float32: require
#extension GL_EXT_shader_explicit_arithmetic_types_float64: require

layout(binding = 0) uniform Uniforms
{
    uint index;
};

layout(std140, binding = 1) uniform Block
{
    int16_t   i16;
    i16vec2   i16v2;
    i16vec3   i16v3;
    i16vec4   i16v4;
    uint16_t  u16;
    u16vec2   u16v2;
    u16vec3   u16v3;
    u16vec4   u16v4;
} block;

void main()
{
}

void literal()
{
    const int16_t i16Const[3] =
    {
        int16_t(-0x1111),           // Hex
        int16_t(-1),                // Dec
        int16_t(040000),            // Oct
    };

    int16_t i16 = i16Const[index];

    const uint16_t u16Const[] =
    {
        uint16_t(0xFFFF),             // Hex
        uint16_t(65535),              // Dec
        uint16_t(077777),             // Oct
    };

    uint16_t u16 = u16Const[index];
}

void typeCast16()
{
    i8vec2 i8v;
    u8vec2 u8v;
    i16vec2 i16v;
    u16vec2 u16v;
    i32vec2 i32v;
    u32vec2 u32v;
    i64vec2 i64v;
    u64vec2 u64v;
    f16vec2 f16v;
    f32vec2 f32v;
    f64vec2 f64v;
    bvec2   bv;

    i32v = i16v;     // int16_t  ->   int32_t
    i32v = u16v;     // uint16_t ->   int32_t
    u16v = i16v;     // int16_t  ->  uint16_t
    u32v = i16v;     // int16_t  ->  uint32_t
    i64v = i16v;     // int16_t  ->   int64_t
    u64v = i16v;     // int16_t  ->  uint64_t
    u32v = u16v;     // uint16_t ->  uint32_t
    i64v = u16v;     // uint16_t ->   int64_t
    u64v = u16v;     // uint16_t ->  uint64_t
    f16v = i16v;     // int16_t  ->  float16_t
    f32v = i16v;     // int16_t  ->  float32_t
    f64v = i16v;     // int16_t  ->  float64_t
    f16v = u16v;     // uint16_t ->  float16_t
    f32v = u16v;     // uint16_t ->  float32_t
    f64v = u16v;     // uint16_t ->  float64_t

    i32v = i32vec2(i16v);     // int16_t  ->   int32_t
    i32v = i32vec2(u16v);     // uint16_t ->   int32_t
    u16v = u16vec2(i16v);     // int16_t  ->  uint16_t
    u32v = u32vec2(i16v);     // int16_t  ->  uint32_t
    i64v = i64vec2(i16v);     // int16_t  ->   int64_t
    u64v = i64vec2(i16v);     // int16_t  ->  uint64_t
    u32v = u32vec2(u16v);     // uint16_t ->  uint32_t
    i64v = i64vec2(u16v);     // uint16_t ->   int64_t
    u64v = i64vec2(u16v);     // uint16_t ->  uint64_t
    f16v = f16vec2(i16v);     // int16_t  ->  float16_t
    f32v = f32vec2(i16v);     // int16_t  ->  float32_t
    f64v = f64vec2(i16v);     // int16_t  ->  float64_t
    f16v = f16vec2(u16v);     // uint16_t ->  float16_t
    f32v = f32vec2(u16v);     // uint16_t ->  float32_t
    f64v = f64vec2(u16v);     // uint16_t ->  float64_t

    i8v  = i8vec2(i16v);      // int16_t  ->   int8_t
    i8v  = i8vec2(u16v);      // uint16_t ->   int8_t
    u8v  = u8vec2(i16v);      // int16_t  ->  uint8_t
    u8v  = u8vec2(u16v);      // uint16_t ->  uint8_t
    i16v = u8vec2(u16v);      // uint16_t ->   int16_t
    i16v = i16vec2(bv);       // bool     ->   int16
    u16v = u16vec2(bv);       // bool     ->   uint16
    bv   = bvec2(i16v);       // int16    ->   bool
    bv   = bvec2(u16v);       // uint16   ->   bool
}
void operators()
{
    u16vec3 u16v;
    int16_t i16;
    uvec3   uv;
    int32_t i;
    int64_t i64;
    bool    b;

    // Unary
    u16v++;
    i16--;
    ++i16;
    --u16v;

    u16v = ~u16v;

    i16 = +i16;
    u16v = -u16v;

    // Arithmetic
    i16  += i16;
    u16v -= u16v;
    i  *= i16;
    uv /= u16v;
    uv %= i16;

    uv = u16v + uv;
    i64  = i16 - i64;
    uv = u16v * uv;
    i64  = i16 * i64;
    i  = i16 % i;

    // Shift
    u16v <<= i16;
    i16  >>= u16v.y;

    i16  = i16 << u16v.z;
    uv = u16v << i;

    // Relational
    b = (u16v.x != i16);
    b = (i16 == u16v.x);
    b = (u16v.x > uv.y);
    b = (i16 < i);
    b = (u16v.y >= uv.x);
    b = (i16 <= i);

    // Bitwise
    uv |= i16;
    i  = i16 | i;
    i64  &= i16;
    uv = u16v & uv;
    uv ^= i16;
    u16v = u16v ^ i16;
}

void builtinFuncs()
{
    i16vec2  i16v;
    i16vec4  i16v4;
    u16vec3  u16v;
    u16vec2  u16v2;
    u16vec4  u16v4;
    bvec3   bv;
    int16_t i16;
    uint16_t u16;
    int32_t i32;
    uint32_t u32;
    int64_t i64;
    uint64_t u64;

    // abs()
    i16v = abs(i16v);

    // sign()
    i16  = sign(i16);

    // min()
    i16v = min(i16v, i16);
    i16v = min(i16v, i16vec2(-1));
    u16v = min(u16v, u16);
    u16v = min(u16v, u16vec3(0));

    // max()
    i16v = max(i16v, i16);
    i16v = max(i16v, i16vec2(-1));
    u16v = max(u16v, u16);
    u16v = max(u16v, u16vec3(0));

    // clamp()
    i16v = clamp(i16v, -i16, i16);
    i16v = clamp(i16v, -i16v, i16v);
    u16v = clamp(u16v, -u16, u16);
    u16v = clamp(u16v, -u16v, u16v);

    // mix()
    i16  = mix(i16v.x, i16v.y, true);
    i16v = mix(i16vec2(i16), i16vec2(-i16), bvec2(false));
    u16  = mix(u16v.x, u16v.y, true);
    u16v = mix(u16vec3(u16), u16vec3(-u16), bvec3(false));

    //pack
    i32 = pack32(i16v);
    i64 = pack64(i16v4);
    u32 = pack32(u16v2);
    u64 = pack64(u16v4);

    i16v  = unpack16(i32);
    i16v4 = unpack16(i64);
    u16v2 = unpack16(u32);
    u16v4 = unpack16(u64);

    // lessThan()
    bv    = lessThan(u16v, u16vec3(u16));
    bv.xy = lessThan(i16v, i16vec2(i16));

    // lessThanEqual()
    bv    = lessThanEqual(u16v, u16vec3(u16));
    bv.xy = lessThanEqual(i16v, i16vec2(i16));

    // greaterThan()
    bv    = greaterThan(u16v, u16vec3(u16));
    bv.xy = greaterThan(i16v, i16vec2(i16));

    // greaterThanEqual()
    bv    = greaterThanEqual(u16v, u16vec3(u16));
    bv.xy = greaterThanEqual(i16v, i16vec2(i16));

    // equal()
    bv    = equal(u16v, u16vec3(u16));
    bv.xy = equal(i16v, i16vec2(i16));

    // notEqual()
    bv    = notEqual(u16v, u16vec3(u16));
    bv.xy = notEqual(i16v, i16vec2(i16));
}

// Type conversion for specialization constant
layout(constant_id = 100) const int16_t  si16 = int16_t(-10);
layout(constant_id = 101) const uint16_t su16 = uint16_t(20);

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.vulkan110.storageBuffer.vert]=[
#version 450

#pragma use_storage_buffer

uniform ub {
    vec4 a;
} ubi;

buffer bb {
    vec4 b;
} bbi;

void main()
{
    gl_Position = ubi.a + bbi.b;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.while-continue-break.vert]=[
#version 310 es
void main() {
  int i = 0;
  int A, B, C, D;
  while (i<10) {
    A = 1;
    if (i%2 == 0) {
      B = 2;
      continue;
      C = 2;
    }
    if (i%5 == 0) {
      B = 2;
      break;
      C = 2;
    }
    i++;
  }
  D = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.while-simple.vert]=[
#version 310 es
void main() {
  int i = 0;
  while (i<10) {
    i++;
  }
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.whileLoop.frag]=[
#version 140

in vec4 bigColor;
in vec4 BaseColor;
in float d;

void main()
{
    vec4 color = BaseColor;

    while (color.x < d) {
        color += bigColor;
    }

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfb.vert]=[
#version 450

layout(xfb_buffer = 3) out;
layout(xfb_stride = 48) out;
layout(xfb_offset = 12, location = 0) out float out1;

layout(xfb_buffer = 2) out;
layout(location=1) out outXfb {
    layout(xfb_buffer = 2, xfb_stride = 32, xfb_offset = 8) float out2;
};

layout(xfb_buffer = 1, location=3) out outXfb2 {
    layout(xfb_stride = 64, xfb_offset = 60) float out3;
};

layout(location = 4, xfb_buffer = 0, xfb_offset = 4) out float out4;

void main()
{
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfb2.vert]=[
#version 450

layout (location = 0) in vec4 position;
layout (binding = 5) uniform ComponentsBlock
{
    vec4 c1;
    vec2 c2;
} components;

layout (xfb_buffer = 3, xfb_offset = 16) out gl_PerVertex
{
    vec4 gl_Position;
};

void main()
{
    gl_Position = position + components.c1 + vec4(components.c2, 0.0, 0.0);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfb3.vert]=[
#version 450

layout (location = 0) in vec4 position;
layout (binding = 5) uniform ComponentsBlock
{
    vec4 c1;
    vec2 c2;
} components;

layout (xfb_buffer = 3, xfb_offset = 16) out gl_PerVertex
{
    layout(xfb_stride = 80) vec4 gl_Position;
};

void main()
{
    gl_Position = position + components.c1 + vec4(components.c2, 0.0, 0.0);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfbOffsetOnBlockMembersAssignment.vert]=[
#version 450

layout(xfb_buffer=2) out;
layout(location=5, xfb_offset=0) out block2 {
   float y1_out;
   vec4 y2_out;
};

void main() {
   y1_out = 7.0;
   y2_out = vec4(1.0, 0.0, 0.0, 1.0);
   gl_Position = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfbOffsetOnStructMembersAssignment.vert]=[
#version 450

layout(xfb_buffer=2) out;

struct S {
   float x1_out;
   float x2_out;
};

layout(location=0, xfb_offset = 16) out S s1;

layout(location=5, xfb_buffer=1, xfb_offset=8) out struct S2 {
   float y1_out;
   vec4 y2_out;
}s2;

void main() {
   s1.x1_out = 5.0;
   s1.x2_out = 6.0;
   s2.y1_out = 7.0;
   s2.y2_out = vec4(1.0, 0.0, 0.0, 1.0);
   gl_Position = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfbOverlapOffsetCheckWithBlockAndMember.vert]=[
#version 450

/* block definition from GLSL spec 4.60, section 4.4.2, Output Layout Qualifiers */

layout(location=5, xfb_buffer = 3, xfb_offset = 12) out block2 {
   vec4 v; // v will be written to byte offsets 12 through 27 of buffer
   float u; // u will be written to offset 28
   layout(xfb_offset = 40) vec4 w;
   vec4 x; // x will be written to offset 56, the next available offset
};

void main() {
   v = vec4(1.0, 0.0, 1.0, 0.0);
   u = 5.0;
   w = vec4(1.0, 0.0, 0.0, 1.0);
   x = vec4(5.0, 0.0, 0.0, 0.0);

   gl_Position = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[spv.xfbStrideJustOnce.vert]=[
#version 450

layout(xfb_buffer=2) out;

layout(location=5, xfb_stride=20) out block {
   float y1_out;
   vec4 y2_out;
};

void main() {
   y1_out = 7.0;
   y2_out = vec4(1.0, 0.0, 0.0, 1.0);
   gl_Position = vec4(0.0);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[stringToDouble.vert]=[
#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
void main()
{
    float w1   = 00000.000;
    float w2   = 1.0;
    float w3   = 007.00;
    float w4   = 000130000.0;
    float w5   = 123456789.0000;
    double w6  = 1234567890123456.0;
    double w7  = 12345678901234567.0;
    double w8  = 123456789012345678.0;
    double w9  = 12345678901234567893.0;
    double w10 = 1234567890123456789012345.0;

    float e1 = 0e0;
    float e2 = 1e0;
    float e3 = 0e14;
    float e4 = 1e15;
    float e5 = 1e16;
    float e6 = 0e-14;
    float e7 = 1e-15;
    float e8 = 1e-16;
    double e9 = 1e100;
    double e10 = 1e+308;
    double e11 = 1e-307; // Was 1e-323, but that's flushed to zero sometimes. 1e-308 can be flushed to 0.
    double e12 = 1e+309;
    double e13 = 1e-324;
    double e24 = 1e+999;
    double e25 = 1e-999;

    double f1 = 0.5;
    double f2 = 0.125;
    double f31 = 0.1;
    double f32 = 0.2;
    double f33 = 0.3;
    double f34 = 0.4;
    double f35 = 0.5;
    double f36 = 0.6;
    double f37 = 0.7;
    double f38 = 0.8;
    double f39 = 0.9;
    double f4 = 0.33333333333333333333333333333333333333333333333333333333333333333333333333333;
    double f51 = 0.000000000000000000000000000000000000783475;
    double f52 = 0.0000000000000000000000000000000000007834750;
    double f53 = .00000000000000000000000000000000000078347500;
    double f54 = 0.000000000000000000000000000000000000783475000000;
    double f61 = 4.;
    double f62 = 40.;
    double f63 = 0.;
    double f64 = 04.;
    double f65 = .0;
    double f66 = .004;
    double f67 = .400;
    double f68 = .04000;

    double c1  = .081e-2;
    double c2  = .073e2;
    double c3  = 34.5e-1;
    double c4  = 35.7e-4;
    double c5  = 43.9e1;
    double c6  = 52.2e4;
    double c7  = 000610000e2;
    double c8  = 000610000e-6;
    double c9  = 000001234567890123450000.0;
    double c10 = 000999999999999999999000.0;
    double c11 = 0001230000.0045600000;
    double c12 = 0001230000.00405600000e-3;
    double c13 = 0001230000.004500600000e-4;
    double c14 = 00010230000.0045600000e-5;
    double c15 = 000120030000.0045600000e4;
    double c16 = 0001230000.0045600000e5;
    double c17 = 0001230000.0045600000e6;
    double c18 = 0001230000.00456007e6;

    double b11 = 72057594037927928.0;
    double b12 = 72057594037927936.0;
    double b13 = 72057594037927932.0;
    double b14 = 7205759403792793199999e-5;
    double b15 = 7205759403792793200001e-5;
    double b21 = 9223372036854774784.0;
    double b22 = 9223372036854775808.0;
    double b23 = 9223372036854775296.0;
    double b24 = 922337203685477529599999e-5;
    double b25 = 922337203685477529600001e-5;
    double b31 = 10141204801825834086073718800384.0;
    double b32 = 10141204801825835211973625643008.0;
    double b33 = 10141204801825834649023672221696.0;
    double b34 = 1014120480182583464902367222169599999e-5;
    double b35 = 1014120480182583464902367222169600001e-5;
    double b41 = 5708990770823838890407843763683279797179383808.0;
    double b42 = 5708990770823839524233143877797980545530986496.0;
    double b43 = 5708990770823839207320493820740630171355185152.0;
    double b44 = 5708990770823839207320493820740630171355185151999e-3;
    double b45 = 5708990770823839207320493820740630171355185152001e-3;

    float pi1 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679f;
    float pi2 = 3.14159265358979f;
    float pi3 = 3.141592653589793f;

    double dpi1 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679;
    double dpi2 = 3.14159265358979;
    double dpi3 = 3.141592653589793;

    float dfpi1 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679f;
    float dfpi2 = 3.14159265358979f;
    float dfpi3 = 3.141592653589793f;

    double lfpi1 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679LF;
    double lfpi2 = 3.14159265358979Lf;
    double lfpi3 = 3.141592653589793lF;

    double hfpi1 = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679hF;
    double hfpi2 = 3.14159265358979hF;
    double hfpi3 = 3.141592653589793hf;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[structAssignment.frag]=[
#version 130

uniform sampler2D sampler;
varying mediump vec2 coord;

struct lunarStruct1 {
    int i;
    float f;
};

struct lunarStruct2 {
    int i;
    float f;
	lunarStruct1 s1_1;
};

struct lunarStruct3 {
	lunarStruct2 s2_1;
    int i;
    float f;
	lunarStruct1 s1_1;
};
.
.
uniform lunarStruct1 foo;
uniform lunarStruct2 foo2;
uniform lunarStruct3 foo3;

void main()
{
	lunarStruct2 locals2;

	if (foo3.s2_1.i > 0)
		locals2 = foo3.s2_1;
	else
		locals2 = foo2;

	gl_FragColor =  locals2.s1_1.f * texture2D(sampler, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[structDeref.frag]=[
#version 130

uniform sampler2D sampler;
varying vec2 coord;

struct s0 {
    int i;
};

struct s00 {
    s0 s0_0;
};

struct s1 {
    int i;
    float f;
    s0 s0_1;
};

struct s2 {
    int i;
    float f;
    s1 s1_1;
};

struct s3 {
    s2[12] s2_1;
    int i;
    float f;
    s1 s1_1;
};
.
.
uniform s0 foo0;
uniform s1 foo1;
uniform s2 foo2;
uniform s3 foo3;

uniform s00 foo00;

void main()
{
    s0 locals0;
    s2 locals2;
    s00 locals00;

    float[6] fArray;

    s1[10] locals1Array;

    if (foo3.s2_1[9].i > 0) {
        locals2.f = 1.0;
        locals2.s1_1 = s1(0, 1.0, s0(0));
        fArray = float[6]( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        locals1Array[6] = foo1;
        locals0 = s0(0);
        locals00 = s00(s0(0));
    } else {
        locals2.f = coord.x;
        locals2.s1_1 = s1(1, coord.y, foo0);
        fArray = float[6]( 0.0, 1.0, 2.0, 3.0, 4.0, 5.0);
        locals1Array[6] = locals2.s1_1;
        locals0 = foo1.s0_1;
        locals00 = foo00;
    }

    if (locals0.i > 5)
        locals0 = locals00.s0_0;

    gl_FragColor = (float(locals0.i) + locals1Array[6].f + fArray[3] + locals2.s1_1.f) * texture2D(sampler, coord);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[structure.frag]=[
#version 130
uniform sampler2D sampler;
varying vec2 coord;

struct lunarStruct1 {
    int i;
	float f[4];
	vec4 color[5];
};

struct lunarStruct2 {
    int i[5];
    float f;
	lunarStruct1 s1_1[7];
};

uniform lunarStruct1 foo;
uniform lunarStruct2 foo2[5];

void main()
{
	float scale = 0.0;

	if (foo2[3].i[4] > 0)
		scale = foo2[3].s1_1[2].color[3].x;
	else
		scale = foo2[3].s1_1[2].f[3];

	gl_FragColor =  scale * texture2D(sampler, coord);
}
.
.
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[switch.frag]=[
#version 300 es
precision highp float;
uniform int c, d;
in highp float x;

void main()
{
    float f;
    int a[2];

    switch(f) {      // ERROR
    }

    switch(a) {      // ERROR
    }

    switch(c)
    {
    }

    switch(c)        // WARNING, not enough stuff after last label
    {
    case 2:
    }

    switch(c)
    {
        f = sin(x);   // ERRROR
    case 2:
        f = cos(x);
        break;
    }

    switch (c) {
    default:
        break;
    case 1:
        f = sin(x);
        break;
    case 2:
        f = cos(x);
        break;
    default:           // ERROR, 2nd default
        f = tan(x);
    }

    switch (c) {
    case 1:
        f = sin(x);
        break;
    case 2:
        switch (d) {
        case 1:
            f = x * x * x;
            break;
        case 2:
            f = x * x;
            break;
        }
        break;
    default:
        f = tan(x);
    case 1:           // ERROR, 2nd 'case 1'
        break;
    case 3.8:         // ERROR, non-int
        break;
    case c:           // ERROR, non-constant
        break;       
    }

    switch (c) {      // a no-error normal switch
    case 1:
        f = sin(x);
        break;
    case 2:
        switch (d) {
        case 1:
            f = x * x * x;
            break;
        case 2:
            f = x * x;
            break;
        }
        break;
    default:
        f = tan(x);
    }

    break;            // ERROR

    switch (c) {
    case 1:
        f = sin(x);
        break;
    case 2:
        switch (d) {
        case 1:
            {
                case 4:        // ERROR
                    break;
            }
            f = x * x * x;
            if (c < d) {
                case 2:         // ERROR
                    f = x * x;
            }
            if (d < c)
                case 3:         // ERROR
            break;
        }
        break;
    case 4:
        f = tan(x);
        if (f < 0.0)
            default:            // ERROR
                break;
    }

    case 5:  // ERROR
    default: // ERROR

    switch (0) {
        default:
        int onlyInSwitch = 0;
    }
    onlyInSwitch;   // ERROR
   
    switch (0) {
        default:
            int x;  // WARNING (was "no statement" ERROR, but spec. changed because unclear what a statement is)
    }

    switch (c) {
    case 1:
    {
        int nestedX;
        break;
    }
    case 2:
        nestedX;    // ERROR
        int nestedZ;
        float a;    // okay, hiding outer 'a'
        break;
    case 3:
        int linearZ;
        break;
        break;
    case 4:
        int linearY = linearZ;
        break;
    case 5:         // okay that branch bypassed an initializer
        const int linearC = 4;
        break;
    case 6:         // okay that branch bypassed an initializer
        linearC;
    }
    nestedZ;        // ERROR, no longer in scope
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[swizzle.frag]=[
#version 110

uniform float blend;
uniform vec4 u;
uniform bool p;

varying vec2 t;

void main()
{
    float blendscale = 1.789;

    vec4 w = u;
    vec4 w_undef;       // test undef
    vec4 w_dep = u;     // test dependent swizzles
    vec4 w_reorder = u; // test reordering
    vec4 w2 = u;
    vec4 w_flow = u;    // test flowControl

    w_reorder.z = blendscale;

    w.wy = t;

    w_reorder.x = blendscale;

    w2.xyzw = u.zwxy;

    w_reorder.y = blendscale;

    w_dep.xy = w2.xz;
    w_dep.zw = t;

    w_undef.xy = u.zw;

    if (p)
        w_flow.x = t.x;
    else
        w_flow.x = t.y;

    gl_FragColor = mix(w_reorder, w_undef, w * w2 * w_dep * w_flow);

    vec2 c = t;
    vec4 rep = vec4(0.0, 0.0, 0.0, 1.0);

    if (c.x < 0.0)
        c.x *= -1.0;

    if (c.x <= 1.0)
        rep.x = 3.4;

    gl_FragColor += rep;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[syntaxError.frag]=[
#version 120

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

void main()
{
    vec5 color = BaseColor;

    do {
        color += bigColor;
    } while (color.x < d);

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[terminate.frag]=[
#version 400

void foo() { terminateInvocation; } // ERROR: identifier undeclared

#extension GL_EXT_terminate_invocation : enable

void main()
{
    int terminateInvocation;  // syntax ERROR
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[terminate.vert]=[
#version 400

void foo() { terminateInvocation; } // ERROR: identifier undeclared

#extension GL_EXT_terminate_invocation : enable

void main()
{
    terminateInvocation;  // ERROR: wrong stage
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[test.frag]=[
#version 110

uniform sampler2D texSampler2D;
uniform sampler3D texSampler3D;

uniform float blend;
uniform vec2 scale;
uniform vec4 u;

varying vec2 t;
varying vec3 coords;

void main()
{  
    float blendscale = 1.789;

    vec4 v = texture2D(texSampler2D, (t + scale) / scale ).wzyx;

	vec4 w = texture3D(texSampler3D, coords) + v;
    
    gl_FragColor = mix(w, u, blend * blendscale);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[texture.frag]=[
#version 130

uniform sampler1D       texSampler1D;
uniform sampler2D       texSampler2D;
uniform sampler3D       texSampler3D;
uniform samplerCube	    texSamplerCube;
uniform sampler1DShadow shadowSampler1D;
uniform sampler2DShadow shadowSampler2D;

uniform float blend;
uniform vec2 scale;
uniform vec4 u;

varying vec2 t;
varying vec2 coords2D;

void main()
{  
    float blendscale = 1.789;
    float bias       = 2.0;
    float lod		 = 3.0;
    float proj       = 2.0;
    float coords1D   = 1.789;
    vec3  coords3D   = vec3(1.789, 2.718, 3.453);
    vec4  coords4D   = vec4(1.789, 2.718, 3.453, 2.0);
    vec4  color      = vec4(0.0, 0.0, 0.0, 0.0);

    color += texture1D    (texSampler1D, coords1D);
    color += texture1D    (texSampler1D, coords1D, bias);
    color += texture1DProj(texSampler1D, coords2D);
    color += texture1DProj(texSampler1D, coords4D);
    color += texture1DProj(texSampler1D, coords2D, bias);
    color += texture1DProj(texSampler1D, coords4D, bias);
    
    color += texture2D        (texSampler2D, coords2D);
    color += texture2D        (texSampler2D, coords2D, bias);
    color += texture2DProj    (texSampler2D, coords3D);
    color += texture2DProj    (texSampler2D, coords4D, bias);

    color += texture3D        (texSampler3D, coords3D);
    color += texture3D        (texSampler3D, coords3D, bias);
    color += texture3DProj    (texSampler3D, coords4D);
    color += texture3DProj    (texSampler3D, coords4D, bias);

    color += textureCube    (texSamplerCube, coords3D);
    color += textureCube    (texSamplerCube, coords3D, bias);
    
    color += shadow1D       (shadowSampler1D, coords3D);
    color += shadow1D       (shadowSampler1D, coords3D, bias);
    color += shadow2D       (shadowSampler2D, coords3D);
    color += shadow2D       (shadowSampler2D, coords3D, bias);
    color += shadow1DProj   (shadowSampler1D, coords4D);
    color += shadow1DProj   (shadowSampler1D, coords4D, bias);
    color += shadow2DProj   (shadowSampler2D, coords4D);
    color += shadow2DProj   (shadowSampler2D, coords4D, bias);

    ivec2 iCoords2D = ivec2(0, 5);
    int iLod = 1;

    color += texelFetch(texSampler2D, iCoords2D, iLod);

    vec2 gradX = dFdx(coords2D);
    vec2 gradY = dFdy(coords2D);
    const ivec2 offset = ivec2(3, -7);

    color += textureGrad(texSampler2D, coords2D, gradX, gradY);
    color += textureProjGrad(texSampler2D, vec3(coords2D, proj), gradX, gradY);
    color += textureGradOffset(texSampler2D, coords2D, gradX, gradY, offset);
    color += textureProjGradOffset(texSampler2D, coords3D, gradX, gradY, offset);
    color += textureGrad(shadowSampler2D, vec3(coords2D, lod), gradX, gradY);
    
    gl_FragColor = mix(color, u, blend * blendscale);
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[tokenLength.vert]=[
#version 300 es
//#pragma glslang_binary_double_output
// 1023 characters
in float BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789;

// 1024 characters (okay)
in float ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789;

int E1 = 5000000000;  // ERROR
int E2 = 50000000000;  // ERROR
int B = 4294967295;  // okay

int OE = 0777777777777777777777;  // ERROR
int HE = 0x1234567890ABCDEF0;     // ERROR

// 1023 character fraction
float F = 1.0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890;

// 1024 character value
float G = 1.01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678890;

// 1025 character fraction
float E3 = 1.012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012;

void main()
{
	gl_Position = vec4(ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789,
		               B, F, G);
}

// super long
float BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789;
int superH = 0xBCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789BCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789;
int superO = 0777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777077777777777777777777707777777777777777777770777777777777777777777;
int superI = 429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295;
float superF = 1.012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890121234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901212345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012;

// Boundary cases
#extension a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhh01234 : enable
#extension a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhh012345 : enable

// Super long
#extension A29496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295429496729542949672954294967295

// Boundary cases
#if 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
#error in long non-zero #if
#endif
#if 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 == 0
#error in long zero #if
#endif
#if 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 == 0
#error in too long #if
#endif

#if A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
#error in long macro #if
#endif
#if A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
#error in long macro #if
#endif
#if A0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
#error in too long macro #if
#endif

// Super long
#if 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
#error in super long #if
#endif
#if A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
#error in super long macro #if
#endif

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[types.frag]=[
#version 130

uniform bool  u_b;
uniform bvec2 u_b2;
uniform bvec3 u_b3;
uniform bvec4 u_b4;

uniform int   u_i;
uniform ivec2 u_i2;
uniform ivec3 u_i3;
uniform ivec4 u_i4;
 
uniform float u_f;
uniform vec2 u_f2;
uniform vec3 u_f3;
uniform vec4 u_f4;

uniform bool  i_b;
uniform bvec2 i_b2;
uniform bvec3 i_b3;
uniform bvec4 i_b4;

flat in int   i_i;
flat in ivec2 i_i2;
flat in ivec3 i_i3;
flat in ivec4 i_i4;

in float i_f;
in vec2 i_f2;
in vec3 i_f3;
in vec4 i_f4;

void main()
{
    bool  b = u_b && i_b;
    bvec2 b2 = bvec2(u_b2.x && i_b2.x && u_b2.y && i_b2.y);
    bvec3 b3 = bvec3(u_b3.x && i_b3.x && u_b3.y && i_b3.y && u_b3.z && i_b3.z);
    bvec4 b4 = bvec4(u_b4.x && i_b4.x && u_b4.y && i_b4.y && u_b4.z && i_b4.z && u_b4.w && i_b4.w);

    int   i = u_i + i_i;
    ivec2 i2 = u_i2 + i_i2;
    ivec3 i3 = u_i3 + i_i3;
    ivec4 i4 = u_i4 + i_i4;

    float f = u_f + i_f;
    vec2  f2 = u_f2 + i_f2;
    vec3  f3 = u_f3 + i_f3;
    vec4  f4 = u_f4 + i_f4;

    gl_FragColor = 
        b || 
        b2.x ||
        b2.y ||
        b3.x ||
        b3.y ||
        b3.z ||
        b4.x ||
        b4.y ||
        b4.z ||
        b4.w ? vec4(
        i  +
        i2.x +
        i2.y +
        i3.x +
        i3.y +
        i3.z +
        i4.x +
        i4.y +
        i4.z +
        i4.w +
        f  +
        f2.x +
        f2.y +
        f3.x +
        f3.y +
        f3.z +
        f4.x +
        f4.y +
        f4.z +
        f4.w) : vec4(1.0);        
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[uint.frag]=[
#version 300 es
in uvec2 badu;  // ERROR
flat in uvec2 t;
in highp float f;
in highp vec2 tc;
in bool bad;    // ERROR
uniform uvec4 v;
uniform int i;
uniform bool b;

out uvec4 c;

uniform lowp usampler2D usampler;

void main()
{
    int count = 1;

    uint u = t.y + 3u;
    const uint cu1error = 0xFFFFFFFF;  // ERROR
    const uint cu1 = 0xFFFFFFFFU;
    const uint cu2 = -1u;              // 0xFFFFFFFF
    const uint cu3 = 1U;
    const uint cu4error = 1;           // ERROR
    const uint cu4 = 1u;

    if (cu1 == cu2)
        count *= 2;  // done
    if (cu3 == cu4)
        count *= 3;  // done
    if (cu2 == cu3)
        count *= 5;  // not done

    const uint cushiftediierror = 0xFFFFFFFF  >> 10;   // ERROR
    const  int  cshiftedii      = 0xFFFFFFFF  >> 10;
    const uint cushiftedui      = 0xFFFFFFFFu >> 10;
    const uint cushiftediuerror = 0xFFFFFFFF  >> 10u;  // ERROR
    const  int  cshiftediu      = 0xFFFFFFFF  >> 10u;
    const uint cushifteduu      = 0xFFFFFFFFu >> 10u;

    if (cshiftedii == cshiftediu)
        count *= 7;  // done
    if (cushiftedui == cushifteduu)
        count *= 11; // done
    if (cshiftedii == int(cushiftedui))
        count *= 13; // not done

    uint shiftediierror = 0xFFFFFFFF  >> 10;   // ERROR
     int shiftedii      = 0xFFFFFFFF  >> 10;
    uint shiftedui      = 0xFFFFFFFFu >> 10;
    uint shiftediuerror = 0xFFFFFFFF  >> 10u;  // ERROR
     int shiftediu      = 0xFFFFFFFF  >> 10u;
    uint shifteduu      = 0xFFFFFFFFu >> 10u;

    if (shiftedii == shiftediu)
        c = texture(usampler, tc);
    if (shiftedui == shifteduu)
        c = texture(usampler, tc + float(1u));
    if (shiftedii == int(shiftedui))
        c = texture(usampler, tc - vec2(2u));

    if (t.x > 4u) {
        float af = float(u);
        bool ab = bool(u);
        int ai = int(u);

        c += uvec4(uint(af), uint(ab), uint(ai), count);
    }

    const uint cmask1 = 0x0A1u;
    const uint cmask2 = 0xA10u;
    const uint cmask3 = cmask1 << 4;
    const uint cmask4 = 0xAB1u;

    if (cmask3 == cmask2)
        count *= 17;  // done

    if ((cmask3 & cmask1) != 0u)
        count *= 19; // not done

    if ((cmask1 | cmask3) == cmask4)
        count *= 23; // done

    if ((cmask1 ^ cmask4) == 0xA10u)
        count *= 27; // done

    uint mask1 = 0x0A1u;
    uint mask2 = 0xA10u;
    uint mask3 = mask1 << 4;
    uint mask4 = 0xAB1u;

    if (mask3 == mask2)
        count *= 100;

    if ((mask3 & mask1) != 0u)
        count *= 101;

    if ((mask1 | mask3) == mask4)
        count *= 102;

    if ((mask1 ^ mask4) == 0xA10u)
        count *= 103;

    c += uvec4(count);	
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[versionsClean.frag]=[
//
//Copyright (C) 2012 LunarG, Inc.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of LunarG Inc. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 300 es

in highp vec3 color;
out highp vec4 foo;

uniform highp sampler2DArrayShadow bar;

void main()
{
    foo = vec4(color, 142.0f);
    discard;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[versionsClean.vert]=[
//
//Copyright (C) 2012 LunarG, Inc.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of LunarG Inc. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 420 compatibility

attribute vec3 color;

uniform sampler2DRect foo;

void main()
{
    gl_Position = vec4(color, 142.0f);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[versionsErrors.frag]=[
//
//Copyright (C) 2012 LunarG, Inc.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of LunarG Inc. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 110 es

#extension GL_ARB_texture_rectangle : disable

attribute vec3 color;

uniform sampler2DRect foo;

void main()
{
    gl_FragColor = vec4(color, 142.0f);
    discard;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[versionsErrors.vert]=[
//
//Copyright (C) 2012 LunarG, Inc.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above
//    copyright notice, this list of conditions and the following
//    disclaimer in the documentation and/or other materials provided
//    with the distribution.
//
//    Neither the name of LunarG Inc. nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.
//
#version 420 core

#extension GL_ARB_texture_rectangle : enable

attribute vec3 color;

uniform sampler2DRect foo;

void main()
{
    gl_Position = vec4(color, 142.0f);
    discard;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.changeSet.frag]=[
#version 460

layout(location = 0) out vec4 fragColor;

uniform sampler2D sTexture;

in vec4 Color;
in vec2 UV;

void main()
{
    fragColor = Color * texture(sTexture, UV.st).r;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.changeSet.vert]=[
#version 460

in vec2 aPos;
in vec2 aUV;
in vec4 aColor;
uniform mat4 projectionMatrix;

out vec4 Color;
out vec2 UV;

void main()
{
    Color = aColor;
    UV = aUV;
    gl_Position = projectionMatrix * vec4(aPos, 0, 1);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.errorcheck.frag]=[
#version 460

layout (location = 0) in vec4 io;

out vec4 o;

// default uniforms will be gathered into a uniform block
uniform vec4 a;     // declared in both stages with different types

vec4 foo() {
    return a;
}

void main() {
    o = io + foo();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.errorcheck.vert]=[
#version 460

layout (location = 0) out vec4 io;

// default uniforms will be gathered into a uniform block
// final global block will merge uniforms from all linked files
uniform vec2 a;     // declared in both stages with different type

vec4 foo() {
    return a.xyxy;
}

void main() {
    io = foo();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.frag]=[
#version 460

out vec4 o;

// default uniforms will be gathered into a uniform block
uniform vec4 a;
uniform vec2 b = vec2(0, 0);            // initializer will be ignored
layout(location = 0) uniform vec2 c;    // location qualifier will be ignored
uniform vec4 d[10];
uniform struct e {                      
    vec2 x;
    float y;
    uint z;
} structUniform; 

// opaque types will not be grouped into uniform block
uniform sampler2D t1;

// shared and packed layout qualifier are silently ignored
layout(shared) uniform UniformBlock {
    float j;
    vec4 k;
};

layout(packed) buffer BufferBlock {
    float j;
    vec4 k;
} bufferInstance;

// atomic_uint will be converted to uint and gathered in a buffer block
layout(binding = 0) uniform atomic_uint counter1; // offset not used
layout(binding = 0) uniform atomic_uint counter2; // offset not used
layout(binding = 1) uniform atomic_uint counter3; // offset not used

// atomic counter functions will be converted to equivalent integer atomic operations
uint bar() {
    uint j = 0;
    j = atomicCounterIncrement(counter1);
    j = atomicCounterDecrement(counter1);
    j = atomicCounter(counter1);

    j = atomicCounterAdd(counter1, 1);
    j = atomicCounterAdd(counter1, -1);
    j = atomicCounterSubtract(counter1, 1);

    j = atomicCounterMin(counter1, j);
    j = atomicCounterMax(counter1, j);
    j = atomicCounterAnd(counter1, j);

    j = atomicCounterOr(counter1, j);
    j = atomicCounterXor(counter1, j);
    
    j = atomicCounterExchange(counter1, j);
    j = atomicCounterCompSwap(counter1, 0, j);

    atomicCounterIncrement(counter2);
    atomicCounterIncrement(counter3);

    memoryBarrierAtomicCounter();
    
    return j;
}

vec4 foo() {
    float f = j + bufferInstance.j + structUniform.y + structUniform.z;
    vec2 v2 = b + c + structUniform.x;
    vec4 v4 = a + d[0] + d[1] + d[2] + k + bufferInstance.k + texture(t1, vec2(0, 0));
    return vec4(f) * vec4(v2, 1, 1) * v4;
}

void main() {
    float j = float(bar());
    o = j * foo();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.link1.frag]=[
#version 460

out vec4 o;

// default uniforms will be gathered into a uniform block
// final global block will merge uniforms from all linked files
uniform vec4 a;     // declared in both stages
uniform vec2 b1;    // declaration order swapped in other stage
uniform vec2 b2;
uniform vec4 c1;    // not delcared in other file
uniform vec4 d;

// final global buffer will berge buffers from all linked files
layout (binding = 0) uniform atomic_uint counter1;
layout (binding = 0) uniform atomic_uint counter2;

vec4 foo();

vec4 bar() {
    uint j = atomicCounterIncrement(counter1) + atomicCounterDecrement(counter2);
    vec4 v = a + vec4(b1.x, b1.y, b2.x, b2.y) + c1 + d;

    return float(j) * v;
}

void main() {
    o = foo() + bar();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.link2.frag]=[
#version 460

// default uniforms will be gathered into a uniform block
// final global block will merge uniforms from all linked files
uniform vec4 a;     // declared in both stages
uniform vec2 b2;    // declaration order swapped in other stage
uniform vec2 b1;
uniform vec4 c2;    // not delcared in other file
uniform vec4 d;

layout (binding = 0) uniform atomic_uint counter3;
layout (binding = 0) uniform atomic_uint counter2;

vec4 foo() {
    uint j = atomicCounterIncrement(counter2) + atomicCounterDecrement(counter3);
    vec4 v = a + vec4(b1.x, b1.y, b2.x, b2.y) + c2 + d;

    return float(j) * v;
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.stagelink.frag]=[
#version 460

layout (location = 0) in vec4 io;

out vec4 o;

// default uniforms will be gathered into a uniform block
// final global block will merge uniforms from all linked files
uniform vec4 a;     // declared in both stages
uniform vec2 b1;    // declaration order swapped in other stage
uniform vec2 b2;
uniform vec4 c1;    // not delcared in other file
uniform vec4 d;

// final global buffer will berge buffers from all linked files
layout (binding = 0) uniform atomic_uint counter1;
layout (binding = 0) uniform atomic_uint counter2;

vec4 foo() {
    uint j = atomicCounterIncrement(counter1) + atomicCounterDecrement(counter2);
    vec4 v = a + vec4(b1.x, b1.y, b2.x, b2.y) + c1 + d;

    return float(j) * v;
}

void main() {
    o = io + foo();
}
<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vk.relaxed.stagelink.vert]=[
#version 460

layout (location = 0) out vec4 io;

// default uniforms will be gathered into a uniform block
// final global block will merge uniforms from all linked files
uniform vec4 a;     // declared in both stages
uniform vec2 b2;    // declaration order swapped in other stage
uniform vec2 b1;
uniform vec4 c2;    // not delcared in other file
uniform vec4 d;

uniform vec4 s[4];

layout (binding = 0) uniform atomic_uint counter3;
layout (binding = 0) uniform atomic_uint counter2;

vec4 foo() {
    uint j = atomicCounterIncrement(counter2) + atomicCounterDecrement(counter3);
    vec4 v = a + vec4(b1.x, b1.y, b2.x, b2.y) + c2 + d;

    return float(j) * v;
}

void main() {

    vec4 v = foo();
    v = v + s[gl_VertexID - gl_VertexIndex];
    v.x = v.x - float(gl_InstanceID - gl_InstanceIndex);
    io = v;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[voidFunction.frag]=[
#version 120

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

float bar = 2.0;

void foo()
{
    bar++;

	return;
}

void foo2()
{
    bar++;
}

void main()
{
	vec4 outColor = bigColor;

	foo();

	foo2();

	outColor.x += bar;

    gl_FragColor = outColor;

	return;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vulkan.ast.vert]=[
#version 450

layout(constant_id = 200) const float scf1 = 1.0;
layout(constant_id = 201) const bool scbt = true;
layout(constant_id = 202) const int sci2 = 2;

void main()
{
    bool(scf1);   // not a spec-const
    bool(scbt);   // spec-const
    bool(sci2);   // spec-const

    float(scf1);   // not a spec-const
    float(scbt);   // not a spec-const
    float(sci2);   // not a spec-const

    int(scf1);   // not a spec-const
    int(scbt);   // spec-const
    int(sci2);   // spec-const

    scf1 * scf1;   // not a spec-const
    scbt || scbt;  // spec-const
    sci2 * sci2;   // spec-const
    scf1 + sci2;   // implicit conversion not a spec-const

    -scf1;     // not a spec-const
    !scbt;     // spec-const
    -sci2;     // spec-const

    scf1 > scf1;   // not a spec-const
    sci2 > sci2;   // spec-const

    scf1 != scf1;  // not a spec-const
    scbt != scbt;  // spec-const
    sci2 != sci2;  // spec-const

    ivec2(sci2, sci2);   // spec-const
    ivec2[2](ivec2(sci2, sci2), ivec2(sci2, sci2)); // not a spec-const

    vec2(scf1, scf1);   // spec-const
    vec2[2](vec2(scf1, scf1), vec2(scf1, scf1)); // not a spec-const
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vulkan.comp]=[
#version 450

layout(local_size_x_id = 18, local_size_z_id = 19) in;
layout(local_size_x = 32, local_size_y = 32) in;
layout(local_size_z_id = 14) in;  // ERROR, can't change this

void main()
{
    gl_WorkGroupSize;
    int i = { };  // ERROR, need an extension
}

layout(local_size_y_id = 19) in; // ERROR, already used: TODO not yet reported

shared float f = { };  // ERROR, need an extension
float g = { };         // ERROR, need an extension

#extension GL_EXT_null_initializer : enable

shared float f2 = { };
float g2 = { };

void foo()
{
    int i = { };
    float fa[] = { };
}

struct samp {
    sampler2D s2D;
} sampVar = { };

atomic_uint a = { };

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vulkan.frag]=[
#version 450

uniform sampler s;         // ERROR, no binding
uniform sampler sA[4];     // ERROR, no binding
uniform texture2D t2d;     // ERROR, no binding
uniform texture3D t3d[4];  // ERROR, no binding
int i;
uniform samplerShadow sShadow;
uniform texture3D t3d5[5];
writeonly uniform image2D i2d;

void badConst()
{
    sampler2D(t2d);       // ERROR, need 2 args
    sampler2D(s, s);      // ERROR, wrong type
    sampler2D(i, i);      // ERROR, wrong type
    sampler2D(t2d, i);    // ERROR, wrong type
    sampler2D(t2d, t2d);  // ERROR, wrong type
    sampler2D(t2d, sA);   // ERROR, wrong type

    sampler3D[4](t3d5, sA[2]);    // ERROR, can't make array
    sampler2D(i2d, s);            // ERROR, image instead of texture
    sampler2D(t3d[1], s);         // ERROR, 3D not 2D
    sampler2D(t2d, sShadow);
    sampler2DShadow(t2d, s);
}

sampler2D s2D = sampler2D(t2d, s);            // ERROR, no sampler constructor
sampler3D s3d[4] = sampler3D[4](t3d, sA[2]);  // ERROR, no sampler constructor

out vec4 color; // ERROR, no location

void main()
{
    color = texture(s2D, vec2(0.5));
    color += texture(s3d[i], vec3(0.5));
}

layout(push_constant) buffer pcb {            // ERROR, not on a buffer
    int a;
} pcbInst;

layout(push_constant) uniform float pcfloat;  // ERROR 2X: not on a non-block, and non-opaque outside block

layout(push_constant) uniform;                // ERROR, needs an object
layout(std430, push_constant) uniform pcb1 { int a; } pcb1inst;
layout(push_constant) uniform pcb2 {
    int a;
};                                            // Okay now to have no instance name

layout(input_attachment_index = 2) uniform subpassInput subD;
layout(input_attachment_index = 3) uniform texture2D subDbad1;          // ERROR, not a texture
layout(input_attachment_index = 4) writeonly uniform image2D subDbad2;  // ERROR, not an image
uniform subpassInput subDbad3;                                          // ERROR, need attachment number
layout(input_attachment_index = 2) uniform subpassInputMS subDMS;

void foo()
{
    vec4 v = subpassLoad(subD);
    v += subpassLoadMS(subD);      // ERROR, no such function
    v += subpassLoad(subD, 2);     // ERROR, no such sig.
    v += subpassLoad(subDMS, 2);
    v += subpassLoadMS(subDMS, 2); // ERROR, no such function
}

subroutine int fooS;                              // ERROR, not in SPV
subroutine int fooSub();                          // ERROR, not in SPV

uniform vec4 dv4;                                 // ERROR, no default uniforms

void fooTex()
{
    texture(t2d, vec2(1.0));                 // ERROR, need a sampler, not a pure texture
    imageStore(t2d, ivec2(4, 5), vec4(1.2)); // ERROR, need an image, not a pure texture
}

precision highp float;

layout(location=0) in vec2 vTexCoord;
layout(location=0) out vec4 FragColor;

vec4 userTexture(mediump sampler2D samp, vec2 coord)
{
    return texture(samp, coord);
}

bool cond;

void callUserTexture()
{
    userTexture(sampler2D(t2d,s), vTexCoord);                            // ERROR, not point of use
    userTexture((sampler2D(t2d,s)), vTexCoord);                          // ERROR, not point of use
    userTexture((sampler2D(t2d,s), sampler2D(t2d,s)), vTexCoord);        // ERROR, not point of use
    userTexture(cond ? sampler2D(t2d,s) : sampler2D(t2d,s), vTexCoord);  // ERROR, no ?:, not point of use

    gl_NumSamples;   // ERROR, not for Vulkan
}

void noise()
{
    noise1(dv4);
    noise2(4.0);
    noise3(vec2(3));
    noise4(dv4);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[vulkan.vert]=[
#version 450

layout(input_attachment_index = 2) uniform subpassInput subD1;     // ERROR, not this stage
layout(input_attachment_index = 2) uniform isubpassInput subD2;    // ERROR, not this stage
layout(input_attachment_index = 2) uniform usubpassInput subD3;    // ERROR, not this stage
layout(input_attachment_index = 2) uniform subpassInputMS subD4;   // ERROR, not this stage
layout(input_attachment_index = 2) uniform isubpassInputMS subD5;  // ERROR, not this stage
layout(input_attachment_index = 2) uniform usubpassInputMS subD6;  // ERROR, not this stage

out vec4 color;

layout(constant_id = 17) const ivec2 arraySizes = ivec2(12,13);    // ERROR, not a scalar
layout(constant_id = 17) uniform sampler2D s2D;                    // ERROR, not the right type or qualifier
layout(constant_id = 4000) const int c1 = 12;                      // ERROR, too big
layout(constant_id = 4) const float c2[2] = float[2](1.0, 2.0);    // ERROR, not a scalar
layout(constant_id = 4) in;

void main()
{
    color = subpassLoad(subD1); // ERROR, no such function in this stage
}

layout(binding = 0) uniform atomic_uint aui;   // ERROR, no atomics in Vulkan
layout(shared, binding = 1) uniform ub1n { int a; } ub1i;   // ERROR, no shared
layout(packed, binding = 2) uniform ub2n { int a; } ub2i;   // ERROR, no packed

layout(constant_id=222) const int arraySize = 4;

void foo()
{
    int a1[arraySize];
    int a2[arraySize] = a1;  // ERROR, can't use in initializer

    a1 = a2;      // ERROR, can't assign, even though the same type
    if (a1 == a2) // ERROR, can't compare either
        ++color;
}

layout(set = 1, push_constant) uniform badpc { int a; } badpcI;  // ERROR, no descriptor set with push_constant

#ifndef VULKAN
#error VULKAN should be defined
#endif

#if VULKAN != 100
#error VULKAN should be 100
#endif

float AofA0[2][arraySize];
float AofA1[arraySize][arraySize];
float AofA2[arraySize][2 + arraySize];
float AofA3[arraySize][2];

out ban1 {                              // ERROR, only outer dimension
    float f;
} bai1[2][arraySize];

out ban2 {
    float f;
} bai2[arraySize][2];

layout(binding = 3000) uniform sampler2D s3000;
layout(binding = 3001) uniform b3001 { int a; };
layout(location = 10) in vec4 in1;
layout(location = 10) in vec4 in2;  // ERROR, no location aliasing

layout(constant_id = 400) const int nonLit = 1;
layout(location = nonLit, component = nonLit) in vec4 nonLit1;  // ERROR, non literal
layout(binding = nonLit, set = nonLit) uniform nonLitBN {       // ERROR, non literal
    layout(offset = nonLit) vec4 nonLit1;                       // ERROR, non literal
    layout(align = nonLit) vec4 nonLit3;                        // ERROR, non literal
    layout(xfb_offset = nonLit) vec4 nonLit4;                   // ERROR, non literal
    layout(xfb_buffer = nonLit) vec4 nonLit5;                   // ERROR, non literal
    layout(xfb_stride = nonLit) vec4 nonLit6;                   // ERROR, non literal
} nonLitBI;
layout(input_attachment_index = nonLit) vec4 nonLit3;           // ERROR, non literal
layout(constant_id = nonLit) vec4 nonLit4;                      // ERROR, non literal

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.basic.vert]=[
#version 310 es

layout(location = 2) in vec4 inv4;
layout(location = 1) out vec4 outv4;

layout(binding = 3) uniform uBlock {
    vec4 a;
    ivec4 b;
    uvec4 c;
} uInst;

void main()
{
    outv4 = normalize(inv4) * uInst.a * vec4(uInst.b) * vec4(uInst.c);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.builtins.frag]=[
#version 310 es

precision lowp float;
layout(location = 4) in float c1D;
layout(location = 5) in vec2  c2D;
layout(location = 6) in vec3  c3D;
layout(location = 7) in smooth vec4  c4D;

layout(location = 1) flat in int   ic1D;
layout(location = 2) flat in ivec3 ic3D;
layout(location = 3) flat in ivec4 ic4D;

const ivec2 ic2D = ivec2(2, 3);

struct s {
    int i;
    sampler2D s;
};

struct S2 {
    vec3 c;
    float f;
};

layout(location = 8) in S2 s2;

layout(location = 0) out vec3 sc;
layout(location = 1) out float sf;

void main()
{
    float f = gl_FragCoord.y;
    gl_FragDepth = f;

    sc = s2.c;
    sf = s2.f;

    sinh(c1D) +
    cosh(c1D) * tanh(c2D);
    asinh(c4D) + acosh(c4D);
    atanh(c3D);
}

void foo324(void)
{
    float p = pow(3.2, 4.6);
    p += sin(0.4);
    p += distance(vec2(10.0, 11.0), vec2(13.0, 15.0)); // 5
    p += dot(vec3(2,3,5), vec3(-2,-1,4));              // 13
    vec3 c3 = cross(vec3(3,-3,1), vec3(4,9,2));        // (-15, -2, 39)
    c3 += faceforward(vec3(1,2,3), vec3(2,3,5), vec3(-2,-1,4));     // (-1,-2,-3)
    c3 += faceforward(vec3(1,2,3), vec3(-2,-3,-5), vec3(-2,-1,4));  // (1,2,3)
    vec2 c2 = reflect(vec2(1,3), vec2(0,1));           // (1,-3)
    c2 += refract(vec2(1,3), vec2(0,1), 1.0);          // (1,-3)
    c2 += refract(vec2(1,3), vec2(0,1), 3.0);
    c2 += refract(vec2(1,0.1), vec2(0,1), 5.0);        // (0,0)
    mat3x2 m32 = outerProduct(vec2(2,3), vec3(5,7,11));// rows: (10, 14, 22), (15, 21, 33)
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.builtins.vert]=[
#version 310 es

layout(location = 0) in mediump float ps;

invariant gl_Position;

void main()
{
    gl_Position = vec4(ps);
    gl_Position *= float(4 - gl_VertexIndex);

    gl_PointSize = ps; 
    gl_PointSize *= float(5 - gl_InstanceIndex);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.comp]=[
#version 310 es

layout(local_size_x_id = 18, local_size_z_id = 19) in;

layout(local_size_x = 2) in;
layout(local_size_y = 5) in;
layout(local_size_z = 7) in;

const int total = gl_MaxComputeWorkGroupCount.x
                + gl_MaxComputeWorkGroupCount.y
                + gl_MaxComputeWorkGroupCount.z
                + gl_MaxComputeUniformComponents
                + gl_MaxComputeTextureImageUnits;

shared vec4 s[total];

int arrX[gl_WorkGroupSize.x];
int arrY[gl_WorkGroupSize.y];
int arrZ[gl_WorkGroupSize.z];

layout(binding = 0, set = 0) buffer bName {
    int size;
    uvec3 count;
    vec4 data[];
} bInst;

void main()
{
    barrier();

    bInst.data[bInst.size / 2] *= vec4(7.0);

    memoryBarrier();
    groupMemoryBarrier();
    memoryBarrierShared();
    memoryBarrierBuffer();

    s[3] = vec4(0, arrX[0], arrY[0], arrZ[0]);
    bInst.count = gl_NumWorkGroups + gl_WorkGroupSize + gl_WorkGroupID + gl_LocalInvocationID +
                  gl_GlobalInvocationID * gl_LocalInvocationIndex;

    atomicAdd(bInst.size, 2);
    atomicMin(bInst.size, 2);
    atomicMax(bInst.size, 2);
    atomicAnd(bInst.size, 2);
    atomicOr(bInst.size, 2);
    atomicXor(bInst.size, 2);
    atomicExchange(bInst.size, 2);
    atomicCompSwap(bInst.size, 5, 2);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.controlFlow.frag]=[
#version 310 es

precision mediump float;
precision highp int;

int c, d;
layout(location = 0) in highp float x;
layout(location = 1) in vec4 bigColor;
layout(location = 2) in vec4 BaseColor;
layout(location = 3) in float f;

layout(location = 4) flat in int Count;
layout(location = 5) flat in uvec4 v4;

layout(location = 0) out vec4 outColor;

void main()
{
    float f;
    int a[2];

    switch(c)
    {
    }

    switch (c) {      // a no-error normal switch
    case 1:
        f = sin(x);
        break;
    case 2:
        switch (d) {
        case 1:
            f = x * x * x;
            break;
        case 2:
            f = x * x;
            break;
        }
        break;
    default:
        f = tan(x);
    }

    vec4 color = BaseColor;

    for (int i = 0; i < Count; ++i) {
        color += bigColor;
    }

    outColor = color;

    float sum = 0.0;
    for (int i = 0; i < 4; ++i)
        sum += float(v4[i]);

    vec4 tv4;

    for (int i = 0; i < 4; ++i)
        tv4[i] = float(v4[i] * 4u);

    outColor += vec4(sum) + tv4;

    vec4 r;
    r.xyz = BaseColor.xyz;

    for (int i = 0; i < Count; ++i)
        r.w = f;

    outColor.xyz += r.xyz;

    for (int i = 0; i < 16; i += 4)
        outColor *= f;

    int i = 0;
    int A, B, C, D;
    while (i<10) {
        A = 1;
        if (i%2 == 0) {
            B = 2;
            continue;
            C = 2;
        }
        if (i%5 == 0) {
            B = 2;
            break;
            C = 2;
        }
        i++;
    }
    D = 3;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.operations.frag]=[
#version 310 es

precision highp float;

layout(binding = 0) uniform block {
    mediump float f;
} instanceName;

struct S {
    int i;
} s;

float a[5];

void main()
{
    bool b;
    float f;
    int i;
    uint u;
    bvec3 b3;
    vec3 v3;
    ivec3 iv3;
    uvec3 uv3;
    vec4 v4;
    ivec4 iv4;
    uvec4 uv4;
    mat2 m2;
    mat4 m4;

    f * v4;
    u + u;
    uv4 / u;
    iv3 -= iv3;
    
    i %= 3;
    uv3 % 4u;
    --m2;
    iv4++;

    m4 != m4;
    m2 == m2;
    i <= i;
    a == a;
    s != s;

    b && b;
    b || b;
    b ^^ b;

    !b, uv3;

    ~i;
    ~u;
    ~uv3;
    ~iv3;

    uv3 <<= i;
    i >> i;
    u << u;
    iv3 >> iv3;

    i & i;
    u | u;
    iv3 ^ iv3;
    u & uv3;
    uv3 | u;
    uv3 &= u;
    int arr[0x222 & 0xf];
    arr[1]; // size 2
    int arr2[(uvec2(0, 0x2) | 0x1u).y];
    arr2[2]; // size 3
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.separate.frag]=[
#version 310 es

precision highp sampler;
precision highp samplerShadow;
precision highp texture2DArray;
precision highp itexture2D;
precision highp itexture3D;
precision highp itextureCube;
precision highp itexture2DArray;
precision highp utexture2D;
precision highp utexture3D;
precision highp utextureCube;
precision highp utexture2DArray;
precision highp texture3D;
precision highp float;

layout(binding = 0) uniform sampler s;
layout(binding = 1) uniform samplerShadow sShadow;
layout(binding = 2) uniform sampler sA[4];
layout(binding = 3) uniform texture2D t2d;
layout(binding = 4) uniform texture3D t3d[4];
layout(location = 0) flat in int i;

layout(location = 0) out vec4 color;

void main()
{
    color = texture(sampler2D(t2d, s), vec2(0.5));
    color += texture(sampler3D(t3d[1], sA[2]), vec3(0.5));
    color += texture(sampler2D(t2d, s), vec2(0.5));
}

layout(binding =  5) uniform texture2D                 tex2D;
layout(binding =  6) uniform textureCube               texCube;
layout(binding = 15) uniform texture2DArray            tex2DArray;
layout(binding = 16) uniform itexture2D                itex2D;
layout(binding = 17) uniform itexture3D                itex3D;
layout(binding = 18) uniform itextureCube              itexCube;
layout(binding = 19) uniform itexture2DArray           itex2DArray;
layout(binding = 20) uniform utexture2D                utex2D;
layout(binding = 21) uniform utexture3D                utex3D;
layout(binding = 22) uniform utextureCube              utexCube;
layout(binding = 23) uniform utexture2DArray           utex2DArray;
layout(binding = 36) uniform texture3D                 tex3D;

void foo()
{
    sampler2D              (tex2D, s);
    samplerCube            (texCube, s);
    samplerCubeShadow      (texCube, sShadow);
    sampler2DArray         (tex2DArray, s);
    sampler2DArrayShadow   (tex2DArray, sShadow);
    isampler2D             (itex2D, s);
    isampler3D             (itex3D, s);
    isamplerCube           (itexCube, s);
    isampler2DArray        (itex2DArray, s);
    usampler2D             (utex2D, s);
    usampler3D             (utex3D, s);
    usamplerCube           (utexCube, s);
    usampler2DArray        (utex2DArray, s);
    sampler3D              (tex3D, s);
    sampler2DShadow        (tex2D, sShadow);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[web.texture.frag]=[
#version 310 es
layout(binding = 1) uniform sampler2D s2D;
layout(binding = 2) uniform lowp sampler3D s3D;
layout(binding = 3) uniform samplerCube sCube;
layout(binding = 4) uniform lowp samplerCubeShadow sCubeShadow;
layout(binding = 5) uniform lowp sampler2DShadow s2DShadow;
layout(binding = 6) uniform lowp sampler2DArray s2DArray;
layout(binding = 7) uniform lowp sampler2DArrayShadow s2DArrayShadow;
layout(binding = 8) uniform lowp isampler2D is2D;
layout(binding = 9) uniform lowp isampler3D is3D;
layout(binding = 10) uniform lowp isamplerCube isCube;
layout(binding = 11) uniform lowp isampler2DArray is2DArray;
layout(binding = 12) uniform lowp usampler2D us2D;
layout(binding = 13) uniform lowp usampler3D us3D;
layout(binding = 14) uniform lowp usamplerCube usCube;
layout(binding = 15) uniform lowp usampler2DArray us2DArray;

precision lowp float;
layout(location = 4) in float c1D;
layout(location = 5) in vec2  c2D;
layout(location = 6) in vec3  c3D;
layout(location = 7) in smooth vec4  c4D;

layout(location = 1) flat in int   ic1D;
layout(location = 2) flat in ivec3 ic3D;
layout(location = 3) flat in ivec4 ic4D;

const ivec2 ic2D = ivec2(2, 3);

struct s {
    int i;
    sampler2D s;
};

struct S2 {
    vec3 c;
    float f;
};

layout(location = 8) in S2 s2;

layout(location = 0) out vec3 sc;
layout(location = 1) out float sf;

layout(binding = 0) uniform sampler2D arrayedSampler[5];

void main()
{
    float f;
    vec4 v;
    v = texture(s2D, c2D);
    v = textureProj(s3D, c4D);
    v = textureLod(s2DArray, c3D, 1.2);
    v = texelFetch(s3D, ic3D, ic1D);
    f = textureLodOffset(s2DShadow, c3D, c1D, ic2D);
    v = textureProjLodOffset(s2D, c3D, c1D, ic2D);
    v = textureGrad(sCube, c3D, c3D, c3D);
    f = textureGradOffset(s2DArrayShadow, c4D, c2D, c2D, ic2D);
    v = textureProjGrad(s3D, c4D, c3D, c3D);
    v = textureProjGradOffset(s2D, c3D, c2D, c2D, ic2D);

    ivec4 iv;
    iv = texture(is2D, c2D);
    iv = textureProjOffset(is2D, c4D, ic2D);
    iv = textureProjLod(is2D, c3D, c1D);
    iv = textureProjGrad(is2D, c3D, c2D, c2D);
    iv = texture(is3D, c3D, 4.2);
    iv = textureLod(isCube, c3D, c1D);
    iv = texelFetch(is2DArray, ic3D, ic1D);

    iv.xy = textureSize(sCubeShadow, 2);
}

void foo23()
{
    textureOffset(s2DShadow, c3D, ivec2(-8, 7), c1D);
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testGlslangErrors[whileLoop.frag]=[
#version 110

uniform vec4 bigColor;
varying vec4 BaseColor;
uniform float d;

void main()
{
    vec4 color = BaseColor;

    while (color.x < d) {
        color += bigColor;
    }

    gl_FragColor = color;
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

]


testParsedTree[uniformTest.glsl]=[
layout (location = 0) attribute vec4 b, c;
uniform sampler2D Sampler;
uniform vec2 bar;
attribute vec4 tang;

uniform bool uniformDecl = true;
const bool constDecl = true;

layout(std140, binding = 0) uniform ubo_DynamicState {
    mat4 ModelViewMat;
    mat4 ProjMat;
};

void main() {
  const uint baz = 4;
  foo = a[3].f;
  foo = b.length();
}

<><><><><><><><><><><><><><><><><><><><><><><><><>
TranslationUnitContext
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||LayoutQualifierContext
------+layout
------+(
|||||||LayoutQualifierIdContext
-------+location
-------+=
||||||||ConstantExpressionContext
|||||||||ConditionalExpressionContext
||||||||||LogicalOrExpressionContext
|||||||||||LogicalXorExpressionContext
||||||||||||LogicalAndExpressionContext
|||||||||||||InclusiveOrExpressionContext
||||||||||||||ExclusiveOrExpressionContext
|||||||||||||||AndExpressionContext
||||||||||||||||EqualityExpressionContext
|||||||||||||||||RelationalExpressionContext
||||||||||||||||||ShiftExpressionContext
|||||||||||||||||||AdditiveExpressionContext
||||||||||||||||||||MultiplicativeExpressionContext
|||||||||||||||||||||UnaryExpressionContext
||||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||||PrimaryExpressionContext
-----------------------+0
------+)
||||||StorageQualifierContext
------+attribute
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierParseableContext
-------+vec4
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+b
----+,
|||||DeclarationMemberContext
-----+c
--+;
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||StorageQualifierContext
------+uniform
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierFixedContext
-------+sampler2D
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+Sampler
--+;
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||StorageQualifierContext
------+uniform
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierParseableContext
-------+vec2
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+bar
--+;
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||StorageQualifierContext
------+attribute
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierParseableContext
-------+vec4
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+tang
--+;
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||StorageQualifierContext
------+uniform
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierParseableContext
-------+bool
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+uniformDecl
-----+=
||||||InitializerContext
|||||||AssignmentExpressionContext
||||||||ConditionalExpressionContext
|||||||||LogicalOrExpressionContext
||||||||||LogicalXorExpressionContext
|||||||||||LogicalAndExpressionContext
||||||||||||InclusiveOrExpressionContext
|||||||||||||ExclusiveOrExpressionContext
||||||||||||||AndExpressionContext
|||||||||||||||EqualityExpressionContext
||||||||||||||||RelationalExpressionContext
|||||||||||||||||ShiftExpressionContext
||||||||||||||||||AdditiveExpressionContext
|||||||||||||||||||MultiplicativeExpressionContext
||||||||||||||||||||UnaryExpressionContext
|||||||||||||||||||||PostfixExpressionContext
||||||||||||||||||||||PrimaryExpressionContext
----------------------+true
--+;
|ExternalDeclarationContext
||DeclarationContext
|||InitDeclaratorListContext
||||FullySpecifiedTypeContext
|||||TypeQualifierContext
||||||StorageQualifierContext
------+const
|||||TypeSpecifierContext
||||||TypeSpecifierNonarrayContext
|||||||BuiltinTypeSpecifierParseableContext
-------+bool
||||DeclarationMemberListContext
|||||DeclarationMemberContext
-----+constDecl
-----+=
||||||InitializerContext
|||||||AssignmentExpressionContext
||||||||ConditionalExpressionContext
|||||||||LogicalOrExpressionContext
||||||||||LogicalXorExpressionContext
|||||||||||LogicalAndExpressionContext
||||||||||||InclusiveOrExpressionContext
|||||||||||||ExclusiveOrExpressionContext
||||||||||||||AndExpressionContext
|||||||||||||||EqualityExpressionContext
||||||||||||||||RelationalExpressionContext
|||||||||||||||||ShiftExpressionContext
||||||||||||||||||AdditiveExpressionContext
|||||||||||||||||||MultiplicativeExpressionContext
||||||||||||||||||||UnaryExpressionContext
|||||||||||||||||||||PostfixExpressionContext
||||||||||||||||||||||PrimaryExpressionContext
----------------------+true
--+;
|ExternalDeclarationContext
||DeclarationContext
|||TypeQualifierContext
||||LayoutQualifierContext
----+layout
----+(
|||||LayoutQualifierIdContext
-----+std140
----+,
|||||LayoutQualifierIdContext
-----+binding
-----+=
||||||ConstantExpressionContext
|||||||ConditionalExpressionContext
||||||||LogicalOrExpressionContext
|||||||||LogicalXorExpressionContext
||||||||||LogicalAndExpressionContext
|||||||||||InclusiveOrExpressionContext
||||||||||||ExclusiveOrExpressionContext
|||||||||||||AndExpressionContext
||||||||||||||EqualityExpressionContext
|||||||||||||||RelationalExpressionContext
||||||||||||||||ShiftExpressionContext
|||||||||||||||||AdditiveExpressionContext
||||||||||||||||||MultiplicativeExpressionContext
|||||||||||||||||||UnaryExpressionContext
||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||PrimaryExpressionContext
---------------------+0
----+)
||||StorageQualifierContext
----+uniform
--+ubo_DynamicState
--+{    \}
|||StructDeclarationListContext
||||StructDeclarationContext
|||||FullySpecifiedTypeContext
||||||TypeSpecifierContext
|||||||TypeSpecifierNonarrayContext
||||||||BuiltinTypeSpecifierParseableContext
--------+mat4
|||||StructDeclaratorListContext
||||||StructDeclaratorContext
------+ModelViewMat
----+;
||||StructDeclarationContext
|||||FullySpecifiedTypeContext
||||||TypeSpecifierContext
|||||||TypeSpecifierNonarrayContext
||||||||BuiltinTypeSpecifierParseableContext
--------+mat4
|||||StructDeclaratorListContext
||||||StructDeclaratorContext
------+ProjMat
----+;
--+}
--+;
|ExternalDeclarationContext
||FunctionDefinitionContext
|||FunctionPrototypeContext
||||FunctionHeaderContext
|||||FullySpecifiedTypeContext
||||||TypeSpecifierContext
|||||||TypeSpecifierNonarrayContext
||||||||BuiltinTypeSpecifierFixedContext
--------+void
----+main
---+(
||||FunctionParameterListContext
---+)
|||CompoundStatementContext
---+{    \}
||||StatementContext
|||||SimpleStatementContext
||||||DeclarationStatementContext
|||||||DeclarationContext
||||||||InitDeclaratorListContext
|||||||||FullySpecifiedTypeContext
||||||||||TypeQualifierContext
|||||||||||StorageQualifierContext
-----------+const
||||||||||TypeSpecifierContext
|||||||||||TypeSpecifierNonarrayContext
||||||||||||BuiltinTypeSpecifierParseableContext
------------+uint
|||||||||DeclarationMemberListContext
||||||||||DeclarationMemberContext
----------+baz
----------+=
|||||||||||InitializerContext
||||||||||||AssignmentExpressionContext
|||||||||||||ConditionalExpressionContext
||||||||||||||LogicalOrExpressionContext
|||||||||||||||LogicalXorExpressionContext
||||||||||||||||LogicalAndExpressionContext
|||||||||||||||||InclusiveOrExpressionContext
||||||||||||||||||ExclusiveOrExpressionContext
|||||||||||||||||||AndExpressionContext
||||||||||||||||||||EqualityExpressionContext
|||||||||||||||||||||RelationalExpressionContext
||||||||||||||||||||||ShiftExpressionContext
|||||||||||||||||||||||AdditiveExpressionContext
||||||||||||||||||||||||MultiplicativeExpressionContext
|||||||||||||||||||||||||UnaryExpressionContext
||||||||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||||||||PrimaryExpressionContext
---------------------------+4
-------+;
||||StatementContext
|||||SimpleStatementContext
||||||ExpressionStatementContext
|||||||ExpressionContext
||||||||AssignmentExpressionContext
|||||||||UnaryExpressionContext
||||||||||PostfixExpressionContext
|||||||||||PrimaryExpressionContext
||||||||||||VariableIdentifierContext
------------+foo
|||||||||AssignmentOperatorContext
---------+=
|||||||||AssignmentExpressionContext
||||||||||ConditionalExpressionContext
|||||||||||LogicalOrExpressionContext
||||||||||||LogicalXorExpressionContext
|||||||||||||LogicalAndExpressionContext
||||||||||||||InclusiveOrExpressionContext
|||||||||||||||ExclusiveOrExpressionContext
||||||||||||||||AndExpressionContext
|||||||||||||||||EqualityExpressionContext
||||||||||||||||||RelationalExpressionContext
|||||||||||||||||||ShiftExpressionContext
||||||||||||||||||||AdditiveExpressionContext
|||||||||||||||||||||MultiplicativeExpressionContext
||||||||||||||||||||||UnaryExpressionContext
|||||||||||||||||||||||PostfixExpressionContext
||||||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||||||PostfixExpressionContext
||||||||||||||||||||||||||PrimaryExpressionContext
|||||||||||||||||||||||||||VariableIdentifierContext
---------------------------+a
------------------------+[
|||||||||||||||||||||||||ExpressionContext
||||||||||||||||||||||||||AssignmentExpressionContext
|||||||||||||||||||||||||||ConditionalExpressionContext
||||||||||||||||||||||||||||LogicalOrExpressionContext
|||||||||||||||||||||||||||||LogicalXorExpressionContext
||||||||||||||||||||||||||||||LogicalAndExpressionContext
|||||||||||||||||||||||||||||||InclusiveOrExpressionContext
||||||||||||||||||||||||||||||||ExclusiveOrExpressionContext
|||||||||||||||||||||||||||||||||AndExpressionContext
||||||||||||||||||||||||||||||||||EqualityExpressionContext
|||||||||||||||||||||||||||||||||||RelationalExpressionContext
||||||||||||||||||||||||||||||||||||ShiftExpressionContext
|||||||||||||||||||||||||||||||||||||AdditiveExpressionContext
||||||||||||||||||||||||||||||||||||||MultiplicativeExpressionContext
|||||||||||||||||||||||||||||||||||||||UnaryExpressionContext
||||||||||||||||||||||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||||||||||||||||||||||PrimaryExpressionContext
-----------------------------------------+3
------------------------+]
-----------------------+.
-----------------------+f
------+;
||||StatementContext
|||||SimpleStatementContext
||||||ExpressionStatementContext
|||||||ExpressionContext
||||||||AssignmentExpressionContext
|||||||||UnaryExpressionContext
||||||||||PostfixExpressionContext
|||||||||||PrimaryExpressionContext
||||||||||||VariableIdentifierContext
------------+foo
|||||||||AssignmentOperatorContext
---------+=
|||||||||AssignmentExpressionContext
||||||||||ConditionalExpressionContext
|||||||||||LogicalOrExpressionContext
||||||||||||LogicalXorExpressionContext
|||||||||||||LogicalAndExpressionContext
||||||||||||||InclusiveOrExpressionContext
|||||||||||||||ExclusiveOrExpressionContext
||||||||||||||||AndExpressionContext
|||||||||||||||||EqualityExpressionContext
||||||||||||||||||RelationalExpressionContext
|||||||||||||||||||ShiftExpressionContext
||||||||||||||||||||AdditiveExpressionContext
|||||||||||||||||||||MultiplicativeExpressionContext
||||||||||||||||||||||UnaryExpressionContext
|||||||||||||||||||||||PostfixExpressionContext
||||||||||||||||||||||||PostfixExpressionContext
|||||||||||||||||||||||||PrimaryExpressionContext
||||||||||||||||||||||||||VariableIdentifierContext
--------------------------+b
-----------------------+.
||||||||||||||||||||||||MethodCallContext
|||||||||||||||||||||||||VariableIdentifierContext
-------------------------+length
|||||||||||||||||||||||||CallParameterListContext
-------------------------+(
-------------------------+)
------+;
---+}
+<EOF>

]