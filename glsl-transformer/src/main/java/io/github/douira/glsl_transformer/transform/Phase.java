package io.github.douira.glsl_transformer.transform;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.pattern.ParseTreeMatch;
import org.antlr.v4.runtime.tree.pattern.ParseTreePattern;
import org.antlr.v4.runtime.tree.xpath.XPath;

import io.github.douira.glsl_transformer.GLSLLexer;
import io.github.douira.glsl_transformer.GLSLParser;
import io.github.douira.glsl_transformer.GLSLParserBaseListener;
import io.github.douira.glsl_transformer.GLSLParser.ExternalDeclarationContext;
import io.github.douira.glsl_transformer.generic.EmptyTerminalNode;
import io.github.douira.glsl_transformer.generic.ExtendedContext;

abstract class Phase extends GLSLParserBaseListener {
  private PhaseCollector collector;

  void setParent(PhaseCollector parent) {
    this.collector = parent;
  }

  protected Parser getParser() {
    return collector.getParser();
  }

  /**
   * Gets the sibling nodes of a given node. It looks up the parent and then
   * returns the parent's children.
   * 
   * @param node The node to get the siblings for
   * @return The siblings of the given node. {@code null} if the node has no
   *         parent.
   */
  protected static List<ParseTree> getSiblings(ExtendedContext node) {
    var parent = node.getParent();
    return parent == null ? null : parent.children;
  }

  private void replaceNode(ExtendedContext removeNode, ParseTree newNode) {
    var children = getSiblings(removeNode);
    children.set(children.indexOf(removeNode), newNode);
    removeNode.omitTokens();
  }

  /**
   * Replaces the given node in its parent with a new node generated by parsing
   * the given string with the given method of the parser. See
   * {@link #createLocalRoot(String, RuleContext, Function)} for details of
   * creating parsed
   * nodes.
   * 
   * @param node        The node to be replaced
   * @param newContents The string from which a new node is generated
   * @param parseMethod The method with which the string will be parsed
   */
  protected void replaceNode(ExtendedContext node, String newContents,
      Function<GLSLParser, ExtendedContext> parseMethod) {
    replaceNode(node, createLocalRoot(newContents, node.getParent(), parseMethod));
  }

  /**
   * Removes the given node from its parent's child list.
   * 
   * @implNote The empty space is filled in with an empty terminal node in order
   *           to not mess up the walker's iteration.
   * @param node The node to remove
   */
  protected void removeNode(ExtendedContext node) {
    // the node needs to be replaced with something to preserve the containing
    // array's length or there's a NullPointerException in the walker
    replaceNode(node, new EmptyTerminalNode());
  }

  protected XPath compilePath(String xpath) {
    return new XPath(getParser(), xpath);
  }

  protected ParseTreePattern compilePattern(String pattern, int rootRule) {
    return getParser().compileParseTreePattern(pattern, rootRule);
  }

  /**
   * This method uses a statically constructed xpath so it doesn't need to be
   * repeatedly constructed. The subtrees yielded by the xpath need to start with
   * the rule that the pattern was constructed with or nothing will match.
   * 
   * Adapted from ANTLR's implementation of
   * {@link org.antlr.v4.runtime.tree.pattern.ParseTreePattern#findAll(ParseTree, String)}.
   * 
   * @param tree    The parse tree to find and match in
   * @param xpath   The xpath that leads to a subtree for matching
   * @param pattern The pattern that tests the subtrees for matches
   * @return A list of all matches resulting from the subtrees
   */
  public List<ParseTreeMatch> findAndMatch(ParseTree tree, XPath xpath, ParseTreePattern pattern) {
    var subtrees = xpath.evaluate(tree);
    var matches = new ArrayList<ParseTreeMatch>();
    for (ParseTree sub : subtrees) {
      ParseTreeMatch match = pattern.match(sub);
      if (match.succeeded()) {
        matches.add(match);
      }
    }
    return matches;
  }

  /**
   * Overwrite this method to add a check of if this phase should be run at all.
   * Especially for WalkPhase this is important since it reduces the number of
   * listeners that need to be processed.
   * 
   * @return If the phase should run. {@code true} by default.
   */
  protected boolean isActive() {
    return true;
  }

  /**
   * This method is called right after this phase is collected by the phase
   * collector. It can be used to compile xpaths and pattern matchers.
   */
  protected void init() {
  }

  /**
   * Parses the given string using the given parser method. Since the parser
   * doesn't know which part of the parse tree any string would be part of, we
   * need to tell it. In many cases multiple methods would produce a correct
   * result. However, this can lead to a truncated parse tree when the resulting
   * node is inserted into a bigger parse tree. The parsing method should be
   * chosen such that when the resulting node is inserted into a parse tree, the
   * tree has the same structure as if it had been parsed as one piece.
   * 
   * For example, the code fragment {@code foo()} could be parsed as a
   * {@code functionCall}, a {@code primaryExpression}, an {@code expression} or
   * other enclosing parse rules. If it's inserted into an expression, it should
   * be parsed as an {@code expression} so that this rule isn't missing from the
   * parse tree. Using the wrong parse method often doesn't matter but it can
   * cause tree matchers to not find the node if they are, for example, looking
   * for an {@code expression} specifically.
   * 
   * All nodes inserted into the parse tree must have properly configured parent
   * references or looking up a node's local root won't work. Other things in
   * ANTLR may also break if non-root nodes are missing their parent references.
   * 
   * @param str         The string to be parsed
   * @param parent      The parent to be set on the node. All nodes will
   *                    eventually end up in the a main tree so some parent will
   *                    be available. Getting the siblings of the new node will
   *                    not work if no parent is set.
   * @param parseMethod The parser method with which the string is parsed
   * @return The resulting parsed node
   */
  public <RuleType extends ExtendedContext> RuleType createLocalRoot(String str, ExtendedContext parent,
      Function<GLSLParser, RuleType> parseMethod) {
    var commonTokenStream = new CommonTokenStream(new GLSLLexer(CharStreams.fromString(str)));
    var node = parseMethod.apply(new GLSLParser(commonTokenStream));
    node.setParent(parent);
    node.makeLocalRoot(commonTokenStream);
    return node;
  }

  /**
   * The code is structured as follows: version, directives (#define etc.),
   * declarations (layout etc.), functions (void main etc.). These injection
   * points can be used to insert nodes into the translation unit's child list.
   * 
   * An injection will happen before the syntax feature it describes or any that
   * follow it in the list.
   */
  public enum InjectionPoint {
    BEFORE_VERSION,
    BEFORE_DIRECTIVES,
    BEFORE_DECLARATIONS,
    BEFORE_FUNCTIONS,
    BEFORE_EOF
  }

  /**
   * Injects the given external declaration rule context into the translation unit
   * context root node at the given injection point.
   * 
   * @implNote Since ANTLR's rule context stores children in an {@link ArrayList},
   *           this operation runs in O(n) where n is the number of external
   *           declarations in the root node. Also make sure not to use this
   *           method during tree walking as it will modify the child array's
   *           length which the tree walker can't handle.
   * 
   * @param node
   * @param location
   */
  public void injectExternalDeclaration(ExternalDeclarationContext node, InjectionPoint location) {
    // TODO
  }
}
