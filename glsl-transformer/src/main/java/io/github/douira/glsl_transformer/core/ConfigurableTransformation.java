package io.github.douira.glsl_transformer.core;

import java.util.Collection;
import java.util.function.Supplier;

import io.github.douira.glsl_transformer.transform.*;

/**
 * Extends a transformation with methods for making it easily configurable. The
 * intended structure for each configurable property of the core transformation
 * is as follows:
 * 
 * - The property foo as a field that holds a supplier that gives the actual
 * value of the property
 * - Public setters foo that accept both a supplier or just a value (which is
 * then packaged into a ValueSupplier). If they are caching setters they're
 * registered in order to be notified of invalidation events (new job
 * parameters, new transformation job etc).
 * - An internal getter foo that returns the value generated by the supplier in
 * field foo and optionally applies something like an activation function.
 * - A protected getter getFoo method that creates default structures. This
 * method is to be overwritten by extending subclasses. It uses the internal
 * getters like bar and baz.
 */
public class ConfigurableTransformation<T extends JobParameters> extends Transformation<T> {
  private Collection<CachingSupplier<?>> cachingSuppliers;
  private T lastJobParameters;

  protected <V> Supplier<V> swapSupplier(Supplier<V> currentSupplier, Supplier<V> newSupplier) {
    removeSupplier(currentSupplier);
    return addSupplier(newSupplier);
  }

  protected <V> Supplier<V> swapSupplier(Supplier<V> currentSupplier, V newValue) {
    return swapSupplier(currentSupplier, new ValueSupplier<V>(newValue));
  }

  protected void removeSupplier(Supplier<?> currentSupplier) {
    if (currentSupplier == null) {
      throw new IllegalStateException("The current supplier is null!");
    }
    if (CachingSupplier.class.isInstance(currentSupplier)) {
      cachingSuppliers.remove((CachingSupplier<?>) currentSupplier);
    }
  }

  protected <V> Supplier<V> addSupplier(Supplier<V> newSupplier) {
    if (newSupplier == null) {
      throw new IllegalStateException("The new supplier is null!");
    }
    if (CachingSupplier.class.isInstance(newSupplier)) {
      cachingSuppliers.remove((CachingSupplier<V>) newSupplier);
    }
    return newSupplier;
  }

  protected <V> Supplier<V> cachingSupplier(CachePolicy cachePolicy, Supplier<V> newSupplier) {
    return addSupplier(CachingSupplier.of(cachePolicy, newSupplier));
  }

  protected <V> Supplier<V> value(V newValue) {
    return new ValueSupplier<V>(newValue);
  }

  protected <V> Supplier<V> once(Supplier<V> supplier) {
    return cachingSupplier(CachePolicy.ONCE, supplier);
  }

  private void invalidateCachingSuppliers(CachePolicy fulfilledPolicy) {
    for (CachingSupplier<?> supplier : cachingSuppliers) {
      supplier.invalidate(fulfilledPolicy);
    }
  }

  @Override
  protected void triggerJobInternal() {
    var newJobParameters = getJobParameters();
    if (lastJobParameters == null || !lastJobParameters.equals(newJobParameters)) {
      invalidateCachingSuppliers(CachePolicy.ON_FIXED_PARAMETER_CHANGE);
      lastJobParameters = newJobParameters;
    } else {
      invalidateCachingSuppliers(CachePolicy.ON_JOB);
    }
  }
}
